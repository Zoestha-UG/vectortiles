!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).MapboxDirections=t()}}(function(){return function t(e,n,r){function i(s,a){if(!n[s]){if(!e[s]){var u="function"==typeof require&&require;if(!a&&u)return u(s,!0);if(o)return o(s,!0);var c=new Error("Cannot find module '"+s+"'");throw c.code="MODULE_NOT_FOUND",c}var l=n[s]={exports:{}};e[s][0].call(l.exports,function(t){var n=e[s][1][t];return i(n||t)},l,l.exports,t,e,n,r)}return n[s].exports}for(var o="function"==typeof require&&require,s=0;s<r.length;s++)i(r[s]);return i}({1:[function(t,e,n){function r(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function i(t){return"function"==typeof t}function o(t){return"object"==typeof t&&null!==t}function s(t){return void 0===t}e.exports=r,r.EventEmitter=r,r.prototype._events=void 0,r.prototype._maxListeners=void 0,r.defaultMaxListeners=10,r.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||isNaN(t))throw TypeError("n must be a positive number");return this._maxListeners=t,this},r.prototype.emit=function(t){var e,n,r,a,u,c;if(this._events||(this._events={}),"error"===t&&(!this._events.error||o(this._events.error)&&!this._events.error.length)){if((e=arguments[1])instanceof Error)throw e;var l=new Error('Uncaught, unspecified "error" event. ('+e+")");throw l.context=e,l}if(s(n=this._events[t]))return!1;if(i(n))switch(arguments.length){case 1:n.call(this);break;case 2:n.call(this,arguments[1]);break;case 3:n.call(this,arguments[1],arguments[2]);break;default:a=Array.prototype.slice.call(arguments,1),n.apply(this,a)}else if(o(n))for(a=Array.prototype.slice.call(arguments,1),r=(c=n.slice()).length,u=0;u<r;u++)c[u].apply(this,a);return!0},r.prototype.addListener=function(t,e){var n;if(!i(e))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",t,i(e.listener)?e.listener:e),this._events[t]?o(this._events[t])?this._events[t].push(e):this._events[t]=[this._events[t],e]:this._events[t]=e,o(this._events[t])&&!this._events[t].warned&&(n=s(this._maxListeners)?r.defaultMaxListeners:this._maxListeners)&&n>0&&this._events[t].length>n&&(this._events[t].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[t].length),"function"==typeof console.trace&&console.trace()),this},r.prototype.on=r.prototype.addListener,r.prototype.once=function(t,e){if(!i(e))throw TypeError("listener must be a function");var n=!1;function r(){this.removeListener(t,r),n||(n=!0,e.apply(this,arguments))}return r.listener=e,this.on(t,r),this},r.prototype.removeListener=function(t,e){var n,r,s,a;if(!i(e))throw TypeError("listener must be a function");if(!this._events||!this._events[t])return this;if(s=(n=this._events[t]).length,r=-1,n===e||i(n.listener)&&n.listener===e)delete this._events[t],this._events.removeListener&&this.emit("removeListener",t,e);else if(o(n)){for(a=s;a-- >0;)if(n[a]===e||n[a].listener&&n[a].listener===e){r=a;break}if(r<0)return this;1===n.length?(n.length=0,delete this._events[t]):n.splice(r,1),this._events.removeListener&&this.emit("removeListener",t,e)}return this},r.prototype.removeAllListeners=function(t){var e,n;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[t]&&delete this._events[t],this;if(0===arguments.length){for(e in this._events)"removeListener"!==e&&this.removeAllListeners(e);return this.removeAllListeners("removeListener"),this._events={},this}if(i(n=this._events[t]))this.removeListener(t,n);else if(n)for(;n.length;)this.removeListener(t,n[n.length-1]);return delete this._events[t],this},r.prototype.listeners=function(t){return this._events&&this._events[t]?i(this._events[t])?[this._events[t]]:this._events[t].slice():[]},r.prototype.listenerCount=function(t){if(this._events){var e=this._events[t];if(i(e))return 1;if(e)return e.length}return 0},r.listenerCount=function(t,e){return t.listenerCount(e)}},{}],2:[function(t,e,n){var r,i,o=e.exports={};function s(t){if(r===setTimeout)return setTimeout(t,0);try{return r(t,0)}catch(e){try{return r.call(null,t,0)}catch(e){return r.call(this,t,0)}}}!function(){try{r=setTimeout}catch(t){r=function(){throw new Error("setTimeout is not defined")}}try{i=clearTimeout}catch(t){i=function(){throw new Error("clearTimeout is not defined")}}}();var a,u=[],c=!1,l=-1;function f(){c&&a&&(c=!1,a.length?u=a.concat(u):l=-1,u.length&&d())}function d(){if(!c){var t=s(f);c=!0;for(var e=u.length;e;){for(a=u,u=[];++l<e;)a&&a[l].run();l=-1,e=u.length}a=null,c=!1,function(t){if(i===clearTimeout)return clearTimeout(t);try{i(t)}catch(e){try{return i.call(null,t)}catch(e){return i.call(this,t)}}}(t)}}function p(t,e){this.fun=t,this.array=e}function h(){}o.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];u.push(new p(t,e)),1!==u.length||c||s(d)},p.prototype.run=function(){this.fun.apply(null,this.array)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=h,o.addListener=h,o.once=h,o.off=h,o.removeListener=h,o.removeAllListeners=h,o.emit=h,o.binding=function(t){throw new Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(t){throw new Error("process.chdir is not supported")},o.umask=function(){return 0}},{}],3:[function(t,e,n){"use strict";var r=t("is-obj"),i=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable;function s(t,e,n){var o=e[n];if(null!=o){if(i.call(t,n)&&(void 0===t[n]||null===t[n]))throw new TypeError("Cannot convert undefined or null to object ("+n+")");i.call(t,n)&&r(o)?t[n]=a(Object(t[n]),e[n]):t[n]=o}}function a(t,e){if(t===e)return t;for(var n in e=Object(e))i.call(e,n)&&s(t,e,n);if(Object.getOwnPropertySymbols)for(var r=Object.getOwnPropertySymbols(e),a=0;a<r.length;a++)o.call(e,r[a])&&s(t,e,r[a]);return t}e.exports=function(t){t=function(t){if(null==t)throw new TypeError("Sources cannot be null or undefined");return Object(t)}(t);for(var e=1;e<arguments.length;e++)a(t,arguments[e]);return t}},{"is-obj":4}],4:[function(t,e,n){"use strict";e.exports=function(t){var e=typeof t;return null!==t&&("object"===e||"function"===e)}},{}],5:[function(t,e,n){(function(t){var n="Expected a function",r=NaN,i="[object Symbol]",o=/^\s+|\s+$/g,s=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,u=/^0o[0-7]+$/i,c=parseInt,l="object"==typeof t&&t&&t.Object===Object&&t,f="object"==typeof self&&self&&self.Object===Object&&self,d=l||f||Function("return this")(),p=Object.prototype.toString,h=Math.max,v=Math.min,y=function(){return d.Date.now()};function g(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function m(t){if("number"==typeof t)return t;if(function(t){return"symbol"==typeof t||function(t){return!!t&&"object"==typeof t}(t)&&p.call(t)==i}(t))return r;if(g(t)){var e="function"==typeof t.valueOf?t.valueOf():t;t=g(e)?e+"":e}if("string"!=typeof t)return 0===t?t:+t;t=t.replace(o,"");var n=a.test(t);return n||u.test(t)?c(t.slice(2),n?2:8):s.test(t)?r:+t}e.exports=function(t,e,r){var i,o,s,a,u,c,l=0,f=!1,d=!1,p=!0;if("function"!=typeof t)throw new TypeError(n);function b(e){var n=i,r=o;return i=o=void 0,l=e,a=t.apply(r,n)}function _(t){var n=t-c;return void 0===c||n>=e||n<0||d&&t-l>=s}function w(){var t=y();if(_(t))return O(t);u=setTimeout(w,function(t){var n=e-(t-c);return d?v(n,s-(t-l)):n}(t))}function O(t){return u=void 0,p&&i?b(t):(i=o=void 0,a)}function E(){var t=y(),n=_(t);if(i=arguments,o=this,c=t,n){if(void 0===u)return function(t){return l=t,u=setTimeout(w,e),f?b(t):a}(c);if(d)return u=setTimeout(w,e),b(c)}return void 0===u&&(u=setTimeout(w,e)),a}return e=m(e)||0,g(r)&&(f=!!r.leading,s=(d="maxWait"in r)?h(m(r.maxWait)||0,e):s,p="trailing"in r?!!r.trailing:p),E.cancel=function(){void 0!==u&&clearTimeout(u),l=0,i=c=o=u=void 0},E.flush=function(){return void 0===u?a:O(y())},E}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],6:[function(t,e,n){(function(t){var r=200,i="__lodash_hash_undefined__",o=1,s=2,a=9007199254740991,u="[object Arguments]",c="[object Array]",l="[object Boolean]",f="[object Date]",d="[object Error]",p="[object Function]",h="[object GeneratorFunction]",v="[object Map]",y="[object Number]",g="[object Object]",m="[object RegExp]",b="[object Set]",_="[object String]",w="[object Symbol]",O="[object ArrayBuffer]",E="[object DataView]",x=/^\[object .+?Constructor\]$/,j=/^(?:0|[1-9]\d*)$/,I={};I["[object Float32Array]"]=I["[object Float64Array]"]=I["[object Int8Array]"]=I["[object Int16Array]"]=I["[object Int32Array]"]=I["[object Uint8Array]"]=I["[object Uint8ClampedArray]"]=I["[object Uint16Array]"]=I["[object Uint32Array]"]=!0,I[u]=I[c]=I[O]=I[l]=I[E]=I[f]=I[d]=I[p]=I[v]=I[y]=I[g]=I[m]=I[b]=I[_]=I["[object WeakMap]"]=!1;var S="object"==typeof t&&t&&t.Object===Object&&t,T="object"==typeof self&&self&&self.Object===Object&&self,k=S||T||Function("return this")(),N="object"==typeof n&&n&&!n.nodeType&&n,C=N&&"object"==typeof e&&e&&!e.nodeType&&e,R=C&&C.exports===N&&S.process,A=function(){try{return R&&R.binding("util")}catch(t){}}(),D=A&&A.isTypedArray;function M(t,e){for(var n=-1,r=t?t.length:0;++n<r;)if(e(t[n],n,t))return!0;return!1}function L(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"")}catch(t){}return e}function P(t){var e=-1,n=Array(t.size);return t.forEach(function(t,r){n[++e]=[r,t]}),n}function F(t){var e=-1,n=Array(t.size);return t.forEach(function(t){n[++e]=t}),n}var q,U,$,G=Array.prototype,Q=Function.prototype,W=Object.prototype,z=k["__core-js_shared__"],B=(q=/[^.]+$/.exec(z&&z.keys&&z.keys.IE_PROTO||""))?"Symbol(src)_1."+q:"",H=Q.toString,V=W.hasOwnProperty,Y=W.toString,K=RegExp("^"+H.call(V).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),J=k.Symbol,X=k.Uint8Array,Z=W.propertyIsEnumerable,tt=G.splice,et=(U=Object.keys,$=Object,function(t){return U($(t))}),nt=St(k,"DataView"),rt=St(k,"Map"),it=St(k,"Promise"),ot=St(k,"Set"),st=St(k,"WeakMap"),at=St(Object,"create"),ut=Nt(nt),ct=Nt(rt),lt=Nt(it),ft=Nt(ot),dt=Nt(st),pt=J?J.prototype:void 0,ht=pt?pt.valueOf:void 0;function vt(t){var e=-1,n=t?t.length:0;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}function yt(t){var e=-1,n=t?t.length:0;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}function gt(t){var e=-1,n=t?t.length:0;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}function mt(t){var e=-1,n=t?t.length:0;for(this.__data__=new gt;++e<n;)this.add(t[e])}function bt(t){this.__data__=new yt(t)}function _t(t,e){var n=Rt(t)||function(t){return function(t){return Pt(t)&&At(t)}(t)&&V.call(t,"callee")&&(!Z.call(t,"callee")||Y.call(t)==u)}(t)?function(t,e){for(var n=-1,r=Array(t);++n<t;)r[n]=e(n);return r}(t.length,String):[],r=n.length,i=!!r;for(var o in t)!e&&!V.call(t,o)||i&&("length"==o||kt(o,r))||n.push(o);return n}function wt(t,e){for(var n=t.length;n--;)if(Ct(t[n][0],e))return n;return-1}function Ot(t,e,n,r,i){return t===e||(null==t||null==e||!Lt(t)&&!Pt(e)?t!=t&&e!=e:function(t,e,n,r,i,a){var p=Rt(t),h=Rt(e),x=c,j=c;p||(x=(x=Tt(t))==u?g:x);h||(j=(j=Tt(e))==u?g:j);var I=x==g&&!L(t),S=j==g&&!L(e),T=x==j;if(T&&!I)return a||(a=new bt),p||Ft(t)?jt(t,e,n,r,i,a):function(t,e,n,r,i,a,u){switch(n){case E:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case O:return!(t.byteLength!=e.byteLength||!r(new X(t),new X(e)));case l:case f:case y:return Ct(+t,+e);case d:return t.name==e.name&&t.message==e.message;case m:case _:return t==e+"";case v:var c=P;case b:var p=a&s;if(c||(c=F),t.size!=e.size&&!p)return!1;var h=u.get(t);if(h)return h==e;a|=o,u.set(t,e);var g=jt(c(t),c(e),r,i,a,u);return u.delete(t),g;case w:if(ht)return ht.call(t)==ht.call(e)}return!1}(t,e,x,n,r,i,a);if(!(i&s)){var k=I&&V.call(t,"__wrapped__"),N=S&&V.call(e,"__wrapped__");if(k||N){var C=k?t.value():t,R=N?e.value():e;return a||(a=new bt),n(C,R,r,i,a)}}if(!T)return!1;return a||(a=new bt),function(t,e,n,r,i,o){var a=i&s,u=qt(t),c=u.length,l=qt(e).length;if(c!=l&&!a)return!1;for(var f=c;f--;){var d=u[f];if(!(a?d in e:V.call(e,d)))return!1}var p=o.get(t);if(p&&o.get(e))return p==e;var h=!0;o.set(t,e),o.set(e,t);for(var v=a;++f<c;){d=u[f];var y=t[d],g=e[d];if(r)var m=a?r(g,y,d,e,t,o):r(y,g,d,t,e,o);if(!(void 0===m?y===g||n(y,g,r,i,o):m)){h=!1;break}v||(v="constructor"==d)}if(h&&!v){var b=t.constructor,_=e.constructor;b!=_&&"constructor"in t&&"constructor"in e&&!("function"==typeof b&&b instanceof b&&"function"==typeof _&&_ instanceof _)&&(h=!1)}return o.delete(t),o.delete(e),h}(t,e,n,r,i,a)}(t,e,Ot,n,r,i))}function Et(t){return!(!Lt(t)||(e=t,B&&B in e))&&(Dt(t)||L(t)?K:x).test(Nt(t));var e}function xt(t){if(n=(e=t)&&e.constructor,r="function"==typeof n&&n.prototype||W,e!==r)return et(t);var e,n,r,i=[];for(var o in Object(t))V.call(t,o)&&"constructor"!=o&&i.push(o);return i}function jt(t,e,n,r,i,a){var u=i&s,c=t.length,l=e.length;if(c!=l&&!(u&&l>c))return!1;var f=a.get(t);if(f&&a.get(e))return f==e;var d=-1,p=!0,h=i&o?new mt:void 0;for(a.set(t,e),a.set(e,t);++d<c;){var v=t[d],y=e[d];if(r)var g=u?r(y,v,d,e,t,a):r(v,y,d,t,e,a);if(void 0!==g){if(g)continue;p=!1;break}if(h){if(!M(e,function(t,e){if(!h.has(e)&&(v===t||n(v,t,r,i,a)))return h.add(e)})){p=!1;break}}else if(v!==y&&!n(v,y,r,i,a)){p=!1;break}}return a.delete(t),a.delete(e),p}function It(t,e){var n,r,i=t.__data__;return("string"==(r=typeof(n=e))||"number"==r||"symbol"==r||"boolean"==r?"__proto__"!==n:null===n)?i["string"==typeof e?"string":"hash"]:i.map}function St(t,e){var n=function(t,e){return null==t?void 0:t[e]}(t,e);return Et(n)?n:void 0}vt.prototype.clear=function(){this.__data__=at?at(null):{}},vt.prototype.delete=function(t){return this.has(t)&&delete this.__data__[t]},vt.prototype.get=function(t){var e=this.__data__;if(at){var n=e[t];return n===i?void 0:n}return V.call(e,t)?e[t]:void 0},vt.prototype.has=function(t){var e=this.__data__;return at?void 0!==e[t]:V.call(e,t)},vt.prototype.set=function(t,e){return this.__data__[t]=at&&void 0===e?i:e,this},yt.prototype.clear=function(){this.__data__=[]},yt.prototype.delete=function(t){var e=this.__data__,n=wt(e,t);return!(n<0||(n==e.length-1?e.pop():tt.call(e,n,1),0))},yt.prototype.get=function(t){var e=this.__data__,n=wt(e,t);return n<0?void 0:e[n][1]},yt.prototype.has=function(t){return wt(this.__data__,t)>-1},yt.prototype.set=function(t,e){var n=this.__data__,r=wt(n,t);return r<0?n.push([t,e]):n[r][1]=e,this},gt.prototype.clear=function(){this.__data__={hash:new vt,map:new(rt||yt),string:new vt}},gt.prototype.delete=function(t){return It(this,t).delete(t)},gt.prototype.get=function(t){return It(this,t).get(t)},gt.prototype.has=function(t){return It(this,t).has(t)},gt.prototype.set=function(t,e){return It(this,t).set(t,e),this},mt.prototype.add=mt.prototype.push=function(t){return this.__data__.set(t,i),this},mt.prototype.has=function(t){return this.__data__.has(t)},bt.prototype.clear=function(){this.__data__=new yt},bt.prototype.delete=function(t){return this.__data__.delete(t)},bt.prototype.get=function(t){return this.__data__.get(t)},bt.prototype.has=function(t){return this.__data__.has(t)},bt.prototype.set=function(t,e){var n=this.__data__;if(n instanceof yt){var i=n.__data__;if(!rt||i.length<r-1)return i.push([t,e]),this;n=this.__data__=new gt(i)}return n.set(t,e),this};var Tt=function(t){return Y.call(t)};function kt(t,e){return!!(e=null==e?a:e)&&("number"==typeof t||j.test(t))&&t>-1&&t%1==0&&t<e}function Nt(t){if(null!=t){try{return H.call(t)}catch(t){}try{return t+""}catch(t){}}return""}function Ct(t,e){return t===e||t!=t&&e!=e}(nt&&Tt(new nt(new ArrayBuffer(1)))!=E||rt&&Tt(new rt)!=v||it&&"[object Promise]"!=Tt(it.resolve())||ot&&Tt(new ot)!=b||st&&"[object WeakMap]"!=Tt(new st))&&(Tt=function(t){var e=Y.call(t),n=e==g?t.constructor:void 0,r=n?Nt(n):void 0;if(r)switch(r){case ut:return E;case ct:return v;case lt:return"[object Promise]";case ft:return b;case dt:return"[object WeakMap]"}return e});var Rt=Array.isArray;function At(t){return null!=t&&Mt(t.length)&&!Dt(t)}function Dt(t){var e=Lt(t)?Y.call(t):"";return e==p||e==h}function Mt(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=a}function Lt(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function Pt(t){return!!t&&"object"==typeof t}var Ft=D?function(t){return function(e){return t(e)}}(D):function(t){return Pt(t)&&Mt(t.length)&&!!I[Y.call(t)]};function qt(t){return At(t)?_t(t):xt(t)}e.exports=function(t,e){return Ot(t,e)}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],7:[function(t,e,n){(function(n){var r=t("lodash._reinterpolate"),i=t("lodash.templatesettings"),o=1/0,s=9007199254740991,a="[object Arguments]",u="[object Error]",c="[object Function]",l="[object GeneratorFunction]",f="[object Symbol]",d=/\b__p \+= '';/g,p=/\b(__p \+=) '' \+/g,h=/(__e\(.*?\)|\b__t\)) \+\n'';/g,v=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,y=/^(?:0|[1-9]\d*)$/,g=/($^)/,m=/['\n\r\u2028\u2029\\]/g,b={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},_="object"==typeof n&&n&&n.Object===Object&&n,w="object"==typeof self&&self&&self.Object===Object&&self,O=_||w||Function("return this")();function E(t,e,n){switch(n.length){case 0:return t.call(e);case 1:return t.call(e,n[0]);case 2:return t.call(e,n[0],n[1]);case 3:return t.call(e,n[0],n[1],n[2])}return t.apply(e,n)}function x(t,e){return function(t,e){for(var n=-1,r=t?t.length:0,i=Array(r);++n<r;)i[n]=e(t[n],n,t);return i}(e,function(e){return t[e]})}function j(t){return"\\"+b[t]}var I,S,T=Object.prototype,k=T.hasOwnProperty,N=T.toString,C=O.Symbol,R=T.propertyIsEnumerable,A=(I=Object.keys,S=Object,function(t){return I(S(t))}),D=Math.max,M=C?C.prototype:void 0,L=M?M.toString:void 0;function P(t,e){var n=H(t)||function(t){return function(t){return J(t)&&V(t)}(t)&&k.call(t,"callee")&&(!R.call(t,"callee")||N.call(t)==a)}(t)?function(t,e){for(var n=-1,r=Array(t);++n<t;)r[n]=e(n);return r}(t.length,String):[],r=n.length,i=!!r;for(var o in t)!e&&!k.call(t,o)||i&&("length"==o||Q(o,r))||n.push(o);return n}function F(t,e,n,r){return void 0===t||B(t,T[n])&&!k.call(r,n)?e:t}function q(t,e,n){var r=t[e];k.call(t,e)&&B(r,n)&&(void 0!==n||e in t)||(t[e]=n)}function U(t){if(!K(t))return function(t){var e=[];if(null!=t)for(var n in Object(t))e.push(n);return e}(t);var e=z(t),n=[];for(var r in t)("constructor"!=r||!e&&k.call(t,r))&&n.push(r);return n}function $(t,e){return e=D(void 0===e?t.length-1:e,0),function(){for(var n=arguments,r=-1,i=D(n.length-e,0),o=Array(i);++r<i;)o[r]=n[e+r];r=-1;for(var s=Array(e+1);++r<e;)s[r]=n[r];return s[e]=o,E(t,this,s)}}function G(t){if("string"==typeof t)return t;if(function(t){return"symbol"==typeof t||J(t)&&N.call(t)==f}(t))return L?L.call(t):"";var e=t+"";return"0"==e&&1/t==-o?"-0":e}function Q(t,e){return!!(e=null==e?s:e)&&("number"==typeof t||y.test(t))&&t>-1&&t%1==0&&t<e}function W(t,e,n){if(!K(n))return!1;var r=typeof e;return!!("number"==r?V(n)&&Q(e,n.length):"string"==r&&e in n)&&B(n[e],t)}function z(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||T)}function B(t,e){return t===e||t!=t&&e!=e}var H=Array.isArray;function V(t){return null!=t&&function(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=s}(t.length)&&!function(t){var e=K(t)?N.call(t):"";return e==c||e==l}(t)}function Y(t){return!!J(t)&&(N.call(t)==u||"string"==typeof t.message&&"string"==typeof t.name)}function K(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function J(t){return!!t&&"object"==typeof t}var X,Z=(X=function(t,e,n,r){!function(t,e,n,r){n||(n={});for(var i=-1,o=e.length;++i<o;){var s=e[i],a=r?r(n[s],t[s],s,n,t):void 0;q(n,s,void 0===a?t[s]:a)}}(e,function(t){return V(t)?P(t,!0):U(t)}(e),t,r)},$(function(t,e){var n=-1,r=e.length,i=r>1?e[r-1]:void 0,o=r>2?e[2]:void 0;for(i=X.length>3&&"function"==typeof i?(r--,i):void 0,o&&W(e[0],e[1],o)&&(i=r<3?void 0:i,r=1),t=Object(t);++n<r;){var s=e[n];s&&X(t,s,n,i)}return t}));function tt(t){return V(t)?P(t):function(t){if(!z(t))return A(t);var e=[];for(var n in Object(t))k.call(t,n)&&"constructor"!=n&&e.push(n);return e}(t)}var et=$(function(t,e){try{return E(t,void 0,e)}catch(t){return Y(t)?t:new Error(t)}});e.exports=function(t,e,n){var o,s=i.imports._.templateSettings||i;n&&W(t,e,n)&&(e=void 0),t=null==(o=t)?"":G(o),e=Z({},e,s,F);var a,u,c=Z({},e.imports,s.imports,F),l=tt(c),f=x(c,l),y=0,b=e.interpolate||g,_="__p += '",w=RegExp((e.escape||g).source+"|"+b.source+"|"+(b===r?v:g).source+"|"+(e.evaluate||g).source+"|$","g"),O="sourceURL"in e?"//# sourceURL="+e.sourceURL+"\n":"";t.replace(w,function(e,n,r,i,o,s){return r||(r=i),_+=t.slice(y,s).replace(m,j),n&&(a=!0,_+="' +\n__e("+n+") +\n'"),o&&(u=!0,_+="';\n"+o+";\n__p += '"),r&&(_+="' +\n((__t = ("+r+")) == null ? '' : __t) +\n'"),y=s+e.length,e}),_+="';\n";var E=e.variable;E||(_="with (obj) {\n"+_+"\n}\n"),_=(u?_.replace(d,""):_).replace(p,"$1").replace(h,"$1;"),_="function("+(E||"obj")+") {\n"+(E?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(a?", __e = _.escape":"")+(u?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+_+"return __p\n}";var I=et(function(){return Function(l,O+"return "+_).apply(void 0,f)});if(I.source=_,Y(I))throw I;return I}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"lodash._reinterpolate":8,"lodash.templatesettings":9}],8:[function(t,e,n){e.exports=/<%=([\s\S]+?)%>/g},{}],9:[function(t,e,n){(function(n){var r=t("lodash._reinterpolate"),i=1/0,o="[object Symbol]",s=/[&<>"'`]/g,a=RegExp(s.source),u="object"==typeof n&&n&&n.Object===Object&&n,c="object"==typeof self&&self&&self.Object===Object&&self,l=u||c||Function("return this")();var f,d=(f={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#96;"},function(t){return null==f?void 0:f[t]}),p=Object.prototype.toString,h=l.Symbol,v=h?h.prototype:void 0,y=v?v.toString:void 0,g={escape:/<%-([\s\S]+?)%>/g,evaluate:/<%([\s\S]+?)%>/g,interpolate:r,variable:"",imports:{_:{escape:function(t){return e=t,(t=null==e?"":function(t){if("string"==typeof t)return t;if(function(t){return"symbol"==typeof t||function(t){return!!t&&"object"==typeof t}(t)&&p.call(t)==o}(t))return y?y.call(t):"";var e=t+"";return"0"==e&&1/t==-i?"-0":e}(e))&&a.test(t)?t.replace(s,d):t;var e}}}};e.exports=g}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"lodash._reinterpolate":8}],10:[function(t,e,n){"use strict";var r={};function i(t,e){t=Math.round(t*e),(t<<=1)<0&&(t=~t);for(var n="";t>=32;)n+=String.fromCharCode(63+(32|31&t)),t>>=5;return n+=String.fromCharCode(t+63)}function o(t){for(var e=[],n=0;n<t.length;n++)e.push(t[n].slice().reverse());return e}r.decode=function(t,e){for(var n,r=0,i=0,o=0,s=[],a=0,u=0,c=null,l=Math.pow(10,e||5);r<t.length;){c=null,a=0,u=0;do{u|=(31&(c=t.charCodeAt(r++)-63))<<a,a+=5}while(c>=32);n=1&u?~(u>>1):u>>1,a=u=0;do{u|=(31&(c=t.charCodeAt(r++)-63))<<a,a+=5}while(c>=32);i+=n,o+=1&u?~(u>>1):u>>1,s.push([i/l,o/l])}return s},r.encode=function(t,e){if(!t.length)return"";for(var n=Math.pow(10,e||5),r=i(t[0][0],n)+i(t[0][1],n),o=1;o<t.length;o++){var s=t[o],a=t[o-1];r+=i(s[0]-a[0],n),r+=i(s[1]-a[1],n)}return r},r.fromGeoJSON=function(t,e){if(t&&"Feature"===t.type&&(t=t.geometry),!t||"LineString"!==t.type)throw new Error("Input must be a GeoJSON LineString");return r.encode(o(t.coordinates),e)},r.toGeoJSON=function(t,e){return{type:"LineString",coordinates:o(r.decode(t,e))}},"object"==typeof e&&e.exports&&(e.exports=r)},{}],11:[function(t,e,n){"use strict";function r(t){return function(e){var n=e.dispatch,r=e.getState;return function(e){return function(i){return"function"==typeof i?i(n,r,t):e(i)}}}}n.__esModule=!0;var i=r();i.withExtraArgument=r,n.default=i},{}],12:[function(t,e,n){"use strict";n.__esModule=!0;var r=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t};n.default=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];return function(t){return function(n,i,o){var a=t(n,i,o),u=a.dispatch,c=[],l={getState:a.getState,dispatch:function(t){return u(t)}};return c=e.map(function(t){return t(l)}),u=s.default.apply(void 0,c)(a.dispatch),r({},a,{dispatch:u})}}};var i,o=t("./compose"),s=(i=o)&&i.__esModule?i:{default:i}},{"./compose":15}],13:[function(t,e,n){"use strict";function r(t,e){return function(){return e(t.apply(void 0,arguments))}}n.__esModule=!0,n.default=function(t,e){if("function"==typeof t)return r(t,e);if("object"!=typeof t||null===t)throw new Error("bindActionCreators expected an object or a function, instead received "+(null===t?"null":typeof t)+'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');for(var n=Object.keys(t),i={},o=0;o<n.length;o++){var s=n[o],a=t[s];"function"==typeof a&&(i[s]=r(a,e))}return i}},{}],14:[function(t,e,n){(function(e){"use strict";n.__esModule=!0,n.default=function(t){for(var n=Object.keys(t),s={},u=0;u<n.length;u++){var c=n[u];"function"==typeof t[c]&&(s[c]=t[c])}var l,f=Object.keys(s);try{!function(t){Object.keys(t).forEach(function(e){var n=t[e],i=n(void 0,{type:r.ActionTypes.INIT});if(void 0===i)throw new Error('Reducer "'+e+'" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined.');var o="@@redux/PROBE_UNKNOWN_ACTION_"+Math.random().toString(36).substring(7).split("").join(".");if(void 0===n(void 0,{type:o}))throw new Error('Reducer "'+e+"\" returned undefined when probed with a random type. Don't try to handle "+r.ActionTypes.INIT+' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined.')})}(s)}catch(t){l=t}return function(){var t=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],n=arguments[1];if(l)throw l;if("production"!==e.env.NODE_ENV){var u=function(t,e,n){var o=Object.keys(e),s=n&&n.type===r.ActionTypes.INIT?"initialState argument passed to createStore":"previous state received by the reducer";if(0===o.length)return"Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";if(!(0,i.default)(t))return"The "+s+' has unexpected type of "'+{}.toString.call(t).match(/\s([a-z|A-Z]+)/)[1]+'". Expected argument to be an object with the following keys: "'+o.join('", "')+'"';var a=Object.keys(t).filter(function(t){return!e.hasOwnProperty(t)});if(a.length>0)return"Unexpected "+(a.length>1?"keys":"key")+' "'+a.join('", "')+'" found in '+s+'. Expected to find one of the known reducer keys instead: "'+o.join('", "')+'". Unexpected keys will be ignored.'}(t,s,n);u&&(0,o.default)(u)}for(var c=!1,d={},p=0;p<f.length;p++){var h=f[p],v=s[h],y=t[h],g=v(y,n);if(void 0===g){var m=a(h,n);throw new Error(m)}d[h]=g,c=c||g!==y}return c?d:t}};var r=t("./createStore"),i=s(t("lodash/isPlainObject")),o=s(t("./utils/warning"));function s(t){return t&&t.__esModule?t:{default:t}}function a(t,e){var n=e&&e.type;return"Given action "+(n&&'"'+n.toString()+'"'||"an action")+', reducer "'+t+'" returned undefined. To ignore an action, you must explicitly return the previous state.'}}).call(this,t("_process"))},{"./createStore":16,"./utils/warning":18,_process:2,"lodash/isPlainObject":23}],15:[function(t,e,n){"use strict";n.__esModule=!0,n.default=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];if(0===e.length)return function(t){return t};var r=(i=e[e.length-1],o=e.slice(0,-1),{v:function(){return o.reduceRight(function(t,e){return e(t)},i.apply(void 0,arguments))}});if("object"==typeof r)return r.v;var i,o}},{}],16:[function(t,e,n){"use strict";n.__esModule=!0,n.ActionTypes=void 0,n.default=function t(e,n,o){var a;"function"==typeof n&&void 0===o&&(o=n,n=void 0);if(void 0!==o){if("function"!=typeof o)throw new Error("Expected the enhancer to be a function.");return o(t)(e,n)}if("function"!=typeof e)throw new Error("Expected the reducer to be a function.");var u=e;var c=n;var l=[];var f=l;var d=!1;function p(){f===l&&(f=l.slice())}function h(){return c}function v(t){if("function"!=typeof t)throw new Error("Expected listener to be a function.");var e=!0;return p(),f.push(t),function(){if(e){e=!1,p();var n=f.indexOf(t);f.splice(n,1)}}}function y(t){if(!(0,r.default)(t))throw new Error("Actions must be plain objects. Use custom middleware for async actions.");if(void 0===t.type)throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');if(d)throw new Error("Reducers may not dispatch actions.");try{d=!0,c=u(c,t)}finally{d=!1}for(var e=l=f,n=0;n<e.length;n++)e[n]();return t}y({type:s.INIT});return a={dispatch:y,subscribe:v,getState:h,replaceReducer:function(t){if("function"!=typeof t)throw new Error("Expected the nextReducer to be a function.");u=t,y({type:s.INIT})}},a[i.default]=function(){var t,e=v;return(t={subscribe:function(t){if("object"!=typeof t)throw new TypeError("Expected the observer to be an object.");function n(){t.next&&t.next(h())}n();var r=e(n);return{unsubscribe:r}}})[i.default]=function(){return this},t},a};var r=o(t("lodash/isPlainObject")),i=o(t("symbol-observable"));function o(t){return t&&t.__esModule?t:{default:t}}var s=n.ActionTypes={INIT:"@@redux/INIT"}},{"lodash/isPlainObject":23,"symbol-observable":24}],17:[function(t,e,n){(function(e){"use strict";n.__esModule=!0,n.compose=n.applyMiddleware=n.bindActionCreators=n.combineReducers=n.createStore=void 0;var r=c(t("./createStore")),i=c(t("./combineReducers")),o=c(t("./bindActionCreators")),s=c(t("./applyMiddleware")),a=c(t("./compose")),u=c(t("./utils/warning"));function c(t){return t&&t.__esModule?t:{default:t}}function l(){}"production"!==e.env.NODE_ENV&&"string"==typeof l.name&&"isCrushed"!==l.name&&(0,u.default)("You are currently using minified code outside of NODE_ENV === 'production'. This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) to ensure you have the correct code for your production build."),n.createStore=r.default,n.combineReducers=i.default,n.bindActionCreators=o.default,n.applyMiddleware=s.default,n.compose=a.default}).call(this,t("_process"))},{"./applyMiddleware":12,"./bindActionCreators":13,"./combineReducers":14,"./compose":15,"./createStore":16,"./utils/warning":18,_process:2}],18:[function(t,e,n){"use strict";n.__esModule=!0,n.default=function(t){"undefined"!=typeof console&&"function"==typeof console.error&&console.error(t);try{throw new Error(t)}catch(t){}}},{}],19:[function(t,e,n){var r=t("./_overArg")(Object.getPrototypeOf,Object);e.exports=r},{"./_overArg":21}],20:[function(t,e,n){e.exports=function(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"")}catch(t){}return e}},{}],21:[function(t,e,n){e.exports=function(t,e){return function(n){return t(e(n))}}},{}],22:[function(t,e,n){e.exports=function(t){return!!t&&"object"==typeof t}},{}],23:[function(t,e,n){var r=t("./_getPrototype"),i=t("./_isHostObject"),o=t("./isObjectLike"),s="[object Object]",a=Function.prototype,u=Object.prototype,c=a.toString,l=u.hasOwnProperty,f=c.call(Object),d=u.toString;e.exports=function(t){if(!o(t)||d.call(t)!=s||i(t))return!1;var e=r(t);if(null===e)return!0;var n=l.call(e,"constructor")&&e.constructor;return"function"==typeof n&&n instanceof n&&c.call(n)==f}},{"./_getPrototype":19,"./_isHostObject":20,"./isObjectLike":22}],24:[function(t,e,n){(function(n){"use strict";e.exports=t("./ponyfill")(n||window||this)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./ponyfill":25}],25:[function(t,e,n){"use strict";e.exports=function(t){var e,n=t.Symbol;return"function"==typeof n?n.observable?e=n.observable:(e=n("observable"),n.observable=e):e="@@observable",e}},{}],26:[function(t,e,n){"use strict";var r=t("./src/suggestions");window.Suggestions=e.exports=r},{"./src/suggestions":29}],27:[function(t,e,n){!function(){var t={};void 0!==n?e.exports=t:this.fuzzy=t,t.simpleFilter=function(e,n){return n.filter(function(n){return t.test(e,n)})},t.test=function(e,n){return null!==t.match(e,n)},t.match=function(t,e,n){n=n||{};var r,i=0,o=[],s=e.length,a=0,u=0,c=n.pre||"",l=n.post||"",f=n.caseSensitive&&e||e.toLowerCase();t=n.caseSensitive&&t||t.toLowerCase();for(var d=0;d<s;d++)r=e[d],f[d]===t[i]?(r=c+r+l,i+=1,u+=1+u):u=0,a+=u,o[o.length]=r;return i===t.length?{rendered:o.join(""),score:a}:null},t.filter=function(e,n,r){return r=r||{},n.reduce(function(n,i,o,s){var a=i;r.extract&&(a=r.extract(i));var u=t.match(e,a,r);return null!=u&&(n[n.length]={string:u.rendered,score:u.score,index:o,original:i}),n},[]).sort(function(t,e){var n=e.score-t.score;return n||t.index-e.index})}}()},{}],28:[function(t,e,n){var r=function(t){return this.component=t,this.items=[],this.active=0,this.element=document.createElement("ul"),this.element.className="suggestions",t.el.parentNode.insertBefore(this.element,t.el.nextSibling),this};r.prototype.show=function(){this.element.style.display="block"},r.prototype.hide=function(){this.element.style.display="none"},r.prototype.add=function(t){this.items.push(t)},r.prototype.clear=function(){this.items=[],this.active=0},r.prototype.isEmpty=function(){return!this.items.length},r.prototype.draw=function(){if(this.element.innerHTML="",0!==this.items.length){for(var t=0;t<this.items.length;t++)this.drawItem(this.items[t],this.active===t);this.show()}else this.hide()},r.prototype.drawItem=function(t,e){var n=document.createElement("li"),r=document.createElement("a");e&&(n.className+=" active"),r.innerHTML=t.string,n.appendChild(r),this.element.appendChild(n),n.addEventListener("mousedown",function(){this.handleMouseDown.call(this,t)}.bind(this))},r.prototype.handleMouseDown=function(t){this.component.value(t.original),this.clear(),this.draw()},r.prototype.move=function(t){this.active=t,this.draw()},r.prototype.previous=function(){this.move(0===this.active?this.items.length-1:this.active-1)},r.prototype.next=function(){this.move(this.active===this.items.length-1?0:this.active+1)},e.exports=r},{}],29:[function(t,e,n){"use strict";var r=t("xtend"),i=t("fuzzy"),o=t("./list"),s=function(t,e,n){return n=n||{},this.options=r({minLength:2,limit:5,filter:!0},n),this.el=t,this.data=e||[],this.list=new o(this),this.query="",this.selected=null,this.list.draw(),this.el.addEventListener("keyup",function(t){this.handleKeyUp(t.keyCode)}.bind(this),!1),this.el.addEventListener("keydown",function(t){this.handleKeyDown(t)}.bind(this)),this.el.addEventListener("focus",function(){this.handleFocus()}.bind(this)),this.el.addEventListener("blur",function(){this.handleBlur()}.bind(this)),this};s.prototype.handleKeyUp=function(t){40!==t&&38!==t&&27!==t&&13!==t&&9!==t&&(this.query=this.normalize(this.el.value),this.list.clear(),this.query.length<this.options.minLength?this.list.draw():this.getCandidates(function(t){for(var e=0;e<t.length&&(this.list.add(t[e]),e!==this.options.limit-1);e++);this.list.draw()}.bind(this)))},s.prototype.handleKeyDown=function(t){switch(t.keyCode){case 13:case 9:this.list.isEmpty()||(this.value(this.list.items[this.list.active].original),this.list.hide());break;case 27:this.list.isEmpty()||this.list.hide();break;case 38:this.list.previous();break;case 40:this.list.next()}},s.prototype.handleBlur=function(){this.list.hide()},s.prototype.handleFocus=function(){this.list.isEmpty()||this.list.show()},s.prototype.update=function(t){this.data=t,this.list.draw()},s.prototype.clear=function(){this.data=[],this.list.clear()},s.prototype.normalize=function(t){return t=t.toLowerCase()},s.prototype.match=function(t,e){return t.indexOf(e)>-1},s.prototype.value=function(t){if(this.selected=t,this.el.value=this.getItemValue(t),document.createEvent){var e=document.createEvent("HTMLEvents");e.initEvent("change",!0,!1),this.el.dispatchEvent(e)}else this.el.fireEvent("onchange")},s.prototype.getCandidates=function(t){var e={pre:"<strong>",post:"</strong>",extract:function(t){return this.getItemValue(t)}.bind(this)};t(this.options.filter?i.filter(this.query,this.data,e):this.data.map(function(t){return{original:t,string:this.getItemValue(t).replace(new RegExp("("+this.query+")","ig"),function(t,e){return"<strong>"+e+"</strong>"})}}.bind(this)))},s.prototype.getItemValue=function(t){return t},e.exports=s},{"./list":28,fuzzy:27,xtend:32}],30:[function(t,e,n){var r=t("turf-meta").coordEach;e.exports=function(t){var e=[1/0,1/0,-1/0,-1/0];return r(t,function(t){e[0]>t[0]&&(e[0]=t[0]),e[1]>t[1]&&(e[1]=t[1]),e[2]<t[0]&&(e[2]=t[0]),e[3]<t[1]&&(e[3]=t[1])}),e}},{"turf-meta":31}],31:[function(t,e,n){function r(t,e,n){var r,i,o,s,a,u,c,f,d,p=0,h="FeatureCollection"===t.type,v="Feature"===t.type,y=h?t.features.length:1;for(r=0;r<y;r++)for(u=(d="GeometryCollection"===(f=h?t.features[r].geometry:v?t.geometry:t).type)?f.geometries.length:1,s=0;s<u;s++)if(c=(a=d?f.geometries[s]:f).coordinates,p=!n||"Polygon"!==a.type&&"MultiPolygon"!==a.type?0:1,"Point"===a.type)e(c);else if("LineString"===a.type||"MultiPoint"===a.type)for(i=0;i<c.length;i++)e(c[i]);else if("Polygon"===a.type||"MultiLineString"===a.type)for(i=0;i<c.length;i++)for(o=0;o<c[i].length-p;o++)e(c[i][o]);else{if("MultiPolygon"!==a.type)throw new Error("Unknown Geometry Type");for(i=0;i<c.length;i++)for(o=0;o<c[i].length;o++)for(l=0;l<c[i][o].length-p;l++)e(c[i][o][l])}}function i(t,e){var n;switch(t.type){case"FeatureCollection":for(features=t.features,n=0;n<t.features.length;n++)e(t.features[n].properties);break;case"Feature":e(t.properties)}}e.exports.coordEach=r,e.exports.coordReduce=function(t,e,n,i){return r(t,function(t){n=e(n,t)},i),n},e.exports.propEach=i,e.exports.propReduce=function(t,e,n){return i(t,function(t){n=e(n,t)}),n}},{}],32:[function(t,e,n){e.exports=function(){for(var t={},e=0;e<arguments.length;e++){var n=arguments[e];for(var i in n)r.call(n,i)&&(t[i]=n[i])}return t};var r=Object.prototype.hasOwnProperty},{}],33:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.queryOrigin=function(t){return{type:i.ORIGIN_QUERY,query:t}},n.queryDestination=function(t){return{type:i.DESTINATION_QUERY,query:t}},n.queryOriginCoordinates=v,n.queryDestinationCoordinates=y,n.clearOrigin=function(){return function(t){t({type:i.ORIGIN_CLEAR}),t(_("clear",{type:"origin"})),t(h(null))}},n.clearDestination=function(){return function(t){t({type:i.DESTINATION_CLEAR}),t(_("clear",{type:"destination"})),t(h(null))}},n.setOptions=function(t){return{type:i.SET_OPTIONS,options:t}},n.hoverMarker=function(t){return function(e){var n=t?s.default.createPoint(t,{id:"hover"}):{};e(function(t){return{type:i.HOVER_MARKER,hoverMarker:t}}(n))}},n.setRouteIndex=g,n.createOrigin=m,n.createDestination=b,n.setProfile=function(t){return function(e,n){var r=n(),o=r.origin,s=r.destination;e({type:i.DIRECTIONS_PROFILE,profile:t}),e(_("profile",{profile:t})),o.geometry&&s.geometry&&e(d())}},n.reverse=function(){return function(t,e){var n=e();n.destination.geometry&&t(u(n.destination.geometry.coordinates)),n.origin.geometry&&t(c(n.origin.geometry.coordinates)),n.origin.geometry&&n.destination.geometry&&t(d())}},n.setOriginFromCoordinates=function(t){return function(e){if(s.default.validCoords(t)||(t=[s.default.wrap(t[0]),s.default.wrap(t[1])]),isNaN(t[0])&&isNaN(t[1]))return e(h(new Error("Coordinates are not valid")));e(v(t)),e(m(t))}},n.setDestinationFromCoordinates=function(t){return function(e){if(s.default.validCoords(t)||(t=[s.default.wrap(t[0]),s.default.wrap(t[1])]),isNaN(t[0])&&isNaN(t[1]))return e(h(new Error("Coordinates are not valid")));e(b(t)),e(y(t))}},n.addWaypoint=function(t,e){return function(n,r){var i=r(),o=i.destination,s=i.waypoints;s.splice(t,0,p(e)),n(f(s)),o.geometry&&n(d())}},n.setWaypoint=function(t,e){return function(n,r){var i=r(),o=i.destination,s=i.waypoints;s[t]=p(e),n(f(s)),o.geometry&&n(d())}},n.removeWaypoint=function(t){return function(e,n){var r=n(),i=r.destination,o=r.waypoints;o=o.filter(function(e){return!s.default.coordinateMatch(e,t)}),e(f(o)),i.geometry&&e(d())}},n.eventSubscribe=function(t,e){return function(n,r){var o=r(),s=o.events;return s[t]=s[t]||[],s[t].push(e),{type:i.EVENTS,events:s}}},n.eventEmit=_;var r,i=function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}(t("../constants/action_types")),o=t("../utils"),s=(r=o)&&r.__esModule?r:{default:r};var a=new XMLHttpRequest;function u(t){return function(e){var n=s.default.createPoint(t,{id:"origin","marker-symbol":"A"});e({type:i.ORIGIN,origin:n}),e(_("origin",{feature:n}))}}function c(t){return function(e){var n=s.default.createPoint(t,{id:"destination","marker-symbol":"B"});e({type:i.DESTINATION,destination:n}),e(_("destination",{feature:n}))}}function l(t){return function(e){e({type:i.DIRECTIONS,directions:t}),e(_("route",{route:t}))}}function f(t){return{type:i.WAYPOINTS,waypoints:t}}function d(){return function(t,e){var n=e(),r=n.api,i=n.accessToken,o=n.routeIndex,s=n.profile,f=function(t){var e=t(),n=e.origin,r=e.destination,i=e.waypoints,o=[];o.push(n.geometry.coordinates.join(",")),o.push(";"),i.length&&i.forEach(function(t){o.push(t.geometry.coordinates.join(",")),o.push(";")});return o.push(r.geometry.coordinates.join(",")),encodeURIComponent(o.join(""))}(e),d=[];d.push("geometries=polyline"),d.push("alternatives=true"),d.push("steps=true"),d.push("overview=full"),d.push("access_token="+i),a.abort(),a.open("GET",r+"mapbox/"+s+"/"+f+".json?"+d.join("&"),!0),a.onload=function(){if(!(a.status>=200&&a.status<400))return t(l([])),t(h(JSON.parse(a.responseText).message));var e=JSON.parse(a.responseText);if(e.error)return t(l([])),t(h(e.error));t(h(null)),e.routes[o]||t(g(0)),t(l(e.routes)),t(u(e.waypoints[0].location)),t(c(e.waypoints[e.waypoints.length-1].location))},a.onerror=function(){return t(l([])),t(h(JSON.parse(a.responseText).message))},a.send()}}function p(t){var e={id:"waypoint"};return Object.assign(t,{properties:t.properties?Object.assign(t.properties,e):e})}function h(t){return function(e){e({type:"ERROR",error:t}),t&&e(_("error",{error:t}))}}function v(t){return{type:i.ORIGIN_FROM_COORDINATES,coordinates:t}}function y(t){return{type:i.DESTINATION_FROM_COORDINATES,coordinates:t}}function g(t){return{type:i.ROUTE_INDEX,routeIndex:t}}function m(t){return function(e,n){var r=n().destination;e(u(t)),r.geometry&&e(d())}}function b(t){return function(e,n){var r=n().origin;e(c(t)),r.geometry&&e(d())}}function _(t,e){var n=this;return function(r,o){var s=o().events;if(!s[t])return{type:i.EVENTS,events:s};for(var a=s[t].slice(),u=0;u<a.length;u++)a[u].call(n,e)}}},{"../constants/action_types":34,"../utils":42}],34:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.DESTINATION="DESTINATION",n.DESTINATION_CLEAR="DESTINATION_CLEAR",n.DESTINATION_QUERY="DESTINATION_QUERY",n.DESTINATION_FROM_COORDINATES="DESTINATION_FROM_COORDINATES",n.DIRECTIONS="DIRECTIONS",n.DIRECTIONS_PROFILE="DIRECTIONS_PROFILE",n.EVENTS="EVENTS",n.ERROR="ERROR",n.HOVER_MARKER="HOVER_MARKER",n.ORIGIN="ORIGIN",n.ORIGIN_CLEAR="ORIGIN_CLEAR",n.ORIGIN_QUERY="ORIGIN_QUERY",n.ORIGIN_FROM_COORDINATES="ORIGIN_FROM_COORDINATES",n.ROUTE_INDEX="ROUTE_INDEX",n.SET_OPTIONS="SET_OPTIONS",n.WAYPOINTS="WAYPOINTS"},{}],35:[function(t,e,n){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol?"symbol":typeof t},i=c(t("suggestions")),o=c(t("lodash.debounce")),s=c(t("xtend")),a=t("events"),u=c(t("../utils"));function c(t){return t&&t.__esModule?t:{default:t}}function l(t){this._ev=new a.EventEmitter,this.options=(0,s.default)({},this.options,t)}l.prototype={options:{placeholder:"Search",zoom:16,flyTo:!0},onAdd:function(t){this._map=t,this.request=new XMLHttpRequest;var e=document.createElement("div");e.className="mapboxgl-ctrl-geocoder";var n=document.createElement("span");n.className="geocoder-icon geocoder-icon-search";var r=this._inputEl=document.createElement("input");r.type="text",r.placeholder=this.options.placeholder,r.addEventListener("keydown",(0,o.default)(function(t){if(!t.target.value)return this._clearEl.classList.remove("active");t.metaKey||-1!==[9,27,37,39,13,38,40].indexOf(t.keyCode)||this._queryFromInput(t.target.value)}.bind(this)),200),r.addEventListener("change",function(e){e.target.value&&this._clearEl.classList.add("active");var n=this._typeahead.selected;if(n){if(this.options.flyTo)if(n.bbox&&n.context&&n.context.length<=3||n.bbox&&!n.context){var r=n.bbox;t.fitBounds([[r[0],r[1]],[r[2],r[3]]])}else t.flyTo({center:n.center,zoom:this.options.zoom});this._input=n,this.fire("result",{result:n})}}.bind(this));var s=document.createElement("div");s.classList.add("geocoder-pin-right");var a=this._clearEl=document.createElement("button");a.className="geocoder-icon geocoder-icon-close",a.addEventListener("click",this._clear.bind(this));var u=this._loadingEl=document.createElement("span");return u.className="geocoder-icon geocoder-icon-loading",s.appendChild(a),s.appendChild(u),e.appendChild(n),e.appendChild(r),e.appendChild(s),this.options.container&&(this.options.position=!1),this._typeahead=new i.default(r,[],{filter:!1}),this._typeahead.getItemValue=function(t){return t.place_name},e},_geocode:function(t,e){this._loadingEl.classList.add("active"),this.fire("loading");var n=[];this.options.proximity&&n.push("proximity="+this.options.proximity.join()),this.options.bbox&&n.push("bbox="+this.options.bbox.join()),this.options.country&&n.push("country="+this.options.country),this.options.types&&n.push("types="+this.options.types);var r=this.options.accessToken?this.options.accessToken:mapboxgl.accessToken;n.push("access_token="+r),this.request.abort(),this.request.open("GET","https://api.mapbox.com/geocoding/v5/mapbox.places/"+encodeURIComponent(t.trim())+".json?"+n.join("&"),!0),this.request.onload=function(){if(this._loadingEl.classList.remove("active"),this.request.status>=200&&this.request.status<400){var t=JSON.parse(this.request.responseText);return t.features.length?this._clearEl.classList.add("active"):(this._clearEl.classList.remove("active"),this._typeahead.selected=null),this.fire("results",{results:t.features}),this._typeahead.update(t.features),e(t.features)}this.fire("error",{error:JSON.parse(this.request.responseText).message})}.bind(this),this.request.onerror=function(){this._loadingEl.classList.remove("active"),this.fire("error",{error:JSON.parse(this.request.responseText).message})}.bind(this),this.request.send()},_queryFromInput:function(t){(t=t.trim())||this._clear(),t.length>2&&this._geocode(t,function(t){this._results=t}.bind(this))},_change:function(){var t=document.createEvent("HTMLEvents");t.initEvent("change",!0,!1),this._inputEl.dispatchEvent(t)},_query:function(t){t&&("object"===(void 0===t?"undefined":r(t))&&t.length&&(t=[u.default.wrap(t[0]),u.default.wrap(t[1])].join()),this._geocode(t,function(t){if(t.length){var e=t[0];this._results=t,this._typeahead.selected=e,this._inputEl.value=e.place_name,this._change()}}.bind(this)))},_setInput:function(t){t&&("object"===(void 0===t?"undefined":r(t))&&t.length&&(t=[u.default.wrap(t[0]),u.default.wrap(t[1])].join()),this._inputEl.value=t,this._input=null,this._typeahead.selected=null,this._typeahead.clear(),this._change())},_clear:function(){this._input=null,this._inputEl.value="",this._typeahead.selected=null,this._typeahead.clear(),this._change(),this._inputEl.focus(),this._clearEl.classList.remove("active"),this.fire("clear")},getResult:function(){return this._input},query:function(t){return this._query(t),this},setInput:function(t){return this._setInput(t),this},on:function(t,e){return this._ev.on(t,e),this},fire:function(t,e){return this._ev.emit(t,e),this},off:function(t,e){return this._ev.removeListener(t,e),this}},e.exports=l},{"../utils":42,events:1,"lodash.debounce":5,suggestions:26,xtend:32}],36:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),i=u(t("./geocoder")),o=u(t("lodash.template")),s=u(t("lodash.isequal")),a=u(t("turf-extent"));function u(t){return t&&t.__esModule?t:{default:t}}var c=(0,o.default)("<div class='mapbox-directions-component mapbox-directions-inputs'>\n  <div class='mapbox-directions-component-keyline'>\n    <div class='mapbox-directions-origin'>\n      <label class='mapbox-form-label'>\n        <span class='directions-icon directions-icon-depart' style='background-color:#93AFD7;' ></span>\n      </label>\n      <div id='mapbox-directions-origin-input'></div>\n    </div>\n\n    <button\n      class='directions-icon directions-icon-reverse directions-reverse js-reverse-inputs'\n      title='Reverse origin &amp; destination'>\n    </button>\n\n    <div class='mapbox-directions-destination'>\n      <label class='mapbox-form-label'>\n        <span class='directions-icon directions-icon-arrive' style='background-color:#608BC7;'></span>\n      </label>\n      <div id='mapbox-directions-destination-input'></div>\n    </div>\n  </div>\n\n  <div class='mapbox-directions-profile mapbox-directions-component-keyline mapbox-directions-clearfix'> <input\n      id='mapbox-directions-profile-driving'\n      type='radio'\n      name='profile'\n      <% if (profile === 'driving') { %>checked<% } %>\n    />\n    <label for='mapbox-directions-profile-driving'>Driving</label>\n    <input\n      id='mapbox-directions-profile-walking'\n      type='radio'\n      name='profile'\n      <% if (profile === 'walking') { %>checked<% } %>\n    />\n    <label for='mapbox-directions-profile-walking'>Walking</label>\n    <input\n      id='mapbox-directions-profile-cycling'\n      type='radio'\n      name='profile'\n      <% if (profile === 'cycling') { %>checked<% } %>\n    />\n    <label for='mapbox-directions-profile-cycling'>Cycling</label>\n  </div>\n</div>\n"),l=function(){function t(e,n,r,i){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t);var o=n.getState(),s=o.originQuery,a=o.destinationQuery,u=o.profile;e.innerHTML=c({originQuery:s,destinationQuery:a,profile:u}),this.container=e,this.actions=r,this.store=n,this._map=i,this.onAdd(),this.render()}return r(t,[{key:"animateToCoordinates",value:function(t,e){var n=this.store.getState(),r=n.origin,i=n.destination;if(r.geometry&&i.geometry&&!(0,s.default)(r.geometry,i.geometry)){var o=(0,a.default)({type:"FeatureCollection",features:[r,i]});this._map.fitBounds([[o[0],o[1]],[o[2],o[3]]],{padding:80})}else this._map.flyTo({center:e})}},{key:"onAdd",value:function(){var t=this,e=this.actions,n=e.clearOrigin,r=e.clearDestination,o=e.createOrigin,s=e.createDestination,a=e.setProfile,u=e.reverse,c=this.store.getState(),l=c.geocoder,f=c.accessToken;this.originInput=new i.default(Object.assign({},{flyTo:!1,placeholder:"Startort",accessToken:f},l));var d=this.originInput.onAdd();this.container.querySelector("#mapbox-directions-origin-input").appendChild(d),this.destinationInput=new i.default(Object.assign({},{flyTo:!1,placeholder:"Zielort",accessToken:f},l));var p=this.destinationInput.onAdd();this.container.querySelector("#mapbox-directions-destination-input").appendChild(p),this.originInput.on("result",function(e){var n=e.result.center;o(n),t.animateToCoordinates("origin",n)}),this.originInput.on("clear",n),this.destinationInput.on("result",function(e){var n=e.result.center;s(n),t.animateToCoordinates("destination",n)}),this.destinationInput.on("clear",r);var h=this.container.querySelectorAll('input[type="radio"]');Array.prototype.forEach.call(h,function(t){t.addEventListener("change",function(){a(t.id.replace("mapbox-directions-profile-",""))})}),this.container.querySelector(".js-reverse-inputs").addEventListener("click",function(){var e=t.store.getState(),n=e.origin,r=e.destination;n&&t.actions.queryDestination(n.geometry.coordinates),r&&t.actions.queryOrigin(r.geometry.coordinates),u()})}},{key:"render",value:function(){var t=this;this.store.subscribe(function(){var e=t.store.getState(),n=e.originQuery,r=e.destinationQuery,i=e.originQueryCoordinates,o=e.destinationQueryCoordinates;n&&(t.originInput.query(n),t.actions.queryOrigin(null)),r&&(t.destinationInput.query(r),t.actions.queryDestination(null)),i&&(t.originInput.setInput(i),t.animateToCoordinates("origin",i),t.actions.queryOriginCoordinates(null)),o&&(t.destinationInput.setInput(o),t.animateToCoordinates("destination",o),t.actions.queryDestinationCoordinates(null))})}}]),t}();n.default=l},{"./geocoder":35,"lodash.isequal":6,"lodash.template":7,"turf-extent":30}],37:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),i=a(t("../utils")),o=a(t("lodash.template")),s=a(t("lodash.isequal"));function a(t){return t&&t.__esModule?t:{default:t}}var u=(0,o.default)("<div class='directions-control directions-control-directions'>\n  <div class='mapbox-directions-component mapbox-directions-route-summary<% if (routes > 1) { %> mapbox-directions-multiple<% } %>'>\n    <% if (routes > 1) { %>\n    <div class='mapbox-directions-routes mapbox-directions-clearfix'>\n      <% for (var i = 0; i < routes; i++) { %>\n        <input type='radio' name='routes' id='<%= i %>' <% if (i === routeIndex) { %>checked<% } %>>\n        <label for='<%= i %>' class='mapbox-directions-route'><%= i + 1 %></label>\n      <% } %>\n    </div>\n    <% } %>\n    <h1><%- duration %></h1>\n    <span><%- distance %></span>\n  </div>\n\n  <div class='mapbox-directions-instructions'>\n    <div class='mapbox-directions-instructions-wrapper'>\n      <ol class='mapbox-directions-steps'>\n        <% steps.forEach(function(step) { %>\n          <%\n            var distance = step.distance ? format(step.distance) : false;\n            var icon = step.maneuver.modifier ? step.maneuver.modifier.replace(/\\s+/g, '-').toLowerCase() : step.maneuver.type.replace(/\\s+/g, '-').toLowerCase();\n\n            if (step.maneuver.type === 'arrive' || step.maneuver.type === 'depart') {\n              icon = step.maneuver.type;\n            }\n\n            if (step.maneuver.type === 'roundabout' || step.maneuver.type === 'rotary') {\n              icon= 'roundabout';\n            }\n\n            var lng = step.maneuver.location[0];\n            var lat = step.maneuver.location[1];\n          %>\n          <li\n            data-lat='<%= lat %>'\n            data-lng='<%= lng %>'\n            class='mapbox-directions-step'>\n            <span class='directions-icon directions-icon-<%= icon %>'></span>\n            <div class='mapbox-directions-step-maneuver'>\n              <%= step.maneuver.instruction %>\n            </div>\n            <% if (distance) { %>\n              <div class='mapbox-directions-step-distance'>\n                <%= distance %>\n              </div>\n            <% } %>\n          </li>\n        <% }); %>\n      </ol>\n    </div>\n  </div>\n</div>\n"),c=(0,o.default)("<div class='directions-control directions-control-directions'>\n  <div class='mapbox-directions-error'>\n    <%= error %>\n  </div>\n</div>\n"),l=function(){function t(e,n,r,i){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.container=e,this.actions=r,this.store=n,this._map=i,this.directions={},this.render()}return r(t,[{key:"render",value:function(){var t=this;this.store.subscribe(function(){var e=t.actions,n=e.hoverMarker,r=e.setRouteIndex,o=t.store.getState(),a=o.routeIndex,l=o.unit,f=o.directions,d=o.error,p=!(0,s.default)(f[a],t.directions);if(d)t.container.innerHTML=c({error:d});else if(f.length&&p){var h=t.directions=f[a];t.container.innerHTML=u({routeIndex:a,routes:f.length,steps:h.legs[0].steps,format:i.default.format[l],duration:i.default.format[l](h.distance),distance:i.default.format.duration(h.duration)});var v=t.container.querySelectorAll(".mapbox-directions-step");Array.prototype.forEach.call(v,function(e){var r=e.getAttribute("data-lng"),i=e.getAttribute("data-lat");e.addEventListener("mouseover",function(){n([r,i])}),e.addEventListener("mouseout",function(){n(null)}),e.addEventListener("click",function(){t._map.flyTo({center:[r,i],zoom:16})})});var y=t.container.querySelectorAll('input[type="radio"]');Array.prototype.forEach.call(y,function(t){t.addEventListener("change",function(t){r(parseInt(t.target.id,10))})})}else t.container.innerHTML&&p&&(t.container.innerHTML="")})}}]),t}();n.default=l},{"../utils":42,"lodash.isequal":6,"lodash.template":7}],38:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),i=t("redux"),o=p(t("redux-thunk")),s=t("polyline"),a=p(t("./utils")),u=p(t("./reducers")),c=function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}(t("./actions")),l=p(t("./directions_style")),f=p(t("./controls/inputs")),d=p(t("./controls/instructions"));function p(t){return t&&t.__esModule?t:{default:t}}var h=(0,i.applyMiddleware)(o.default)(i.createStore)(u.default),v=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.actions=(0,i.bindActionCreators)(c,h.dispatch),this.actions.setOptions(e||{}),this.options=e||{},this.onDragDown=this._onDragDown.bind(this),this.onDragMove=this._onDragMove.bind(this),this.onDragUp=this._onDragUp.bind(this),this.move=this._move.bind(this),this.onClick=this._onClick.bind(this)}return r(t,[{key:"onAdd",value:function(t){var e=this;this._map=t;var n=h.getState().controls,r=this.container=document.createElement("div");r.className="mapboxgl-ctrl-directions mapboxgl-ctrl";var i=document.createElement("div");i.className="directions-control directions-control-inputs",new f.default(i,h,this.actions,this._map);var o=document.createElement("div");return o.className="directions-control directions-control-instructions",new d.default(o,h,{hoverMarker:this.actions.hoverMarker,setRouteIndex:this.actions.setRouteIndex},this._map),n.inputs&&r.appendChild(i),n.instructions&&r.appendChild(o),this.subscribedActions(),this._map.loaded()?this.mapState():this._map.on("load",function(){return e.mapState()}),r}},{key:"onRemove",value:function(t){return this.container.parentNode.removeChild(this.container),this.removeRoutes(),t.off("mousedown",this.onDragDown),t.off("mousemove",this.move),t.off("touchstart",this.onDragDown),t.off("touchstart",this.move),t.off("click",this.onClick),this.storeUnsubscribe&&(this.storeUnsubscribe(),delete this.storeUnsubscribe),this._map=null,this}},{key:"mapState",value:function(){var t=this,e=h.getState(),n=e.profile,r=e.styles,i=e.interactive;this.actions.eventEmit("profile",{profile:n});this._map.addSource("directions",{type:"geojson",data:{type:"FeatureCollection",features:[]}}),l.default.forEach(function(e){return t._map.addLayer(e)}),r&&r.length&&r.forEach(function(e){return t._map.addLayer(e)}),i&&(this._map.on("mousedown",this.onDragDown),this._map.on("mousemove",this.move),this._map.on("click",this.onClick),this._map.on("touchstart",this.move),this._map.on("touchstart",this.onDragDown))}},{key:"subscribedActions",value:function(){var t=this;this.storeUnsubscribe=h.subscribe(function(){var e=h.getState(),n=e.origin,r=e.destination,i=e.hoverMarker,o=e.directions,a=e.routeIndex,u={type:"FeatureCollection",features:[n,r,i].filter(function(t){return t.geometry})};o.length&&o.forEach(function(t,e){var n={geometry:{type:"LineString",coordinates:(0,s.decode)(t.geometry,5).map(function(t){return t.reverse()})},properties:{"route-index":e,route:e===a?"selected":"alternate"}};u.features.push(n),e===a&&t.legs[0].steps.forEach(function(t){"waypoint"===t.maneuver.type&&u.features.push({type:"Feature",geometry:t.maneuver.location,properties:{id:"waypoint"}})})}),t._map.style&&t._map.getSource("directions")&&t._map.getSource("directions").setData(u)})}},{key:"_onClick",value:function(t){var e=this,n=h.getState().origin,r=[t.lngLat.lng,t.lngLat.lat];if(n.geometry){var i=this._map.queryRenderedFeatures(t.point,{layers:["directions-origin-point","directions-destination-point","directions-waypoint-point","directions-route-line-alt"]});if(i.length){if(i.forEach(function(t){"directions-waypoint-point"===t.layer.id&&e.actions.removeWaypoint(t)}),"alternate"===i[0].properties.route){var o=i[0].properties["route-index"];this.actions.setRouteIndex(o)}}else this.actions.setDestinationFromCoordinates(r),this._map.flyTo({center:r})}else this.actions.setOriginFromCoordinates(r)}},{key:"_move",value:function(t){var e=this,n=h.getState().hoverMarker,r=this._map.queryRenderedFeatures(t.point,{layers:["directions-route-line-alt","directions-route-line","directions-origin-point","directions-destination-point","directions-hover-point"]});this._map.getCanvas().style.cursor=r.length?"pointer":"",r.length?(this.isCursorOverPoint=r[0],this._map.dragPan.disable(),r.forEach(function(r){"directions-route-line"===r.layer.id?e.actions.hoverMarker([t.lngLat.lng,t.lngLat.lat]):n.geometry&&e.actions.hoverMarker(null)})):this.isCursorOverPoint&&(this.isCursorOverPoint=!1,this._map.dragPan.enable())}},{key:"_onDragDown",value:function(){this.isCursorOverPoint&&(this.isDragging=this.isCursorOverPoint,this._map.getCanvas().style.cursor="grab",this._map.on("mousemove",this.onDragMove),this._map.on("mouseup",this.onDragUp),this._map.on("touchmove",this.onDragMove),this._map.on("touchend",this.onDragUp))}},{key:"_onDragMove",value:function(t){if(this.isDragging){var e=[t.lngLat.lng,t.lngLat.lat];switch(this.isDragging.layer.id){case"directions-origin-point":this.actions.createOrigin(e);break;case"directions-destination-point":this.actions.createDestination(e);break;case"directions-hover-point":this.actions.hoverMarker(e)}}}},{key:"_onDragUp",value:function(){if(this.isDragging){var t=h.getState(),e=t.hoverMarker,n=t.origin,r=t.destination;switch(this.isDragging.layer.id){case"directions-origin-point":this.actions.setOriginFromCoordinates(n.geometry.coordinates);break;case"directions-destination-point":this.actions.setDestinationFromCoordinates(r.geometry.coordinates);break;case"directions-hover-point":e.geometry&&!a.default.coordinateMatch(this.isDragging,e)&&this.actions.addWaypoint(0,e)}this.isDragging=!1,this._map.getCanvas().style.cursor="",this._map.off("touchmove",this.onDragMove),this._map.off("touchend",this.onDragUp),this._map.off("mousemove",this.onDragMove),this._map.off("mouseup",this.onDragUp)}}},{key:"interactive",value:function(t){return t?(this._map.on("touchstart",this.move),this._map.on("touchstart",this.onDragDown),this._map.on("mousedown",this.onDragDown),this._map.on("mousemove",this.move),this._map.on("click",this.onClick)):(this._map.off("touchstart",this.move),this._map.off("touchstart",this.onDragDown),this._map.off("mousedown",this.onDragDown),this._map.off("mousemove",this.move),this._map.off("click",this.onClick)),this}},{key:"getOrigin",value:function(){return h.getState().origin}},{key:"setOrigin",value:function(t){return"string"==typeof t?this.actions.queryOrigin(t):this.actions.setOriginFromCoordinates(t),this}},{key:"getDestination",value:function(){return h.getState().destination}},{key:"setDestination",value:function(t){return"string"==typeof t?this.actions.queryDestination(t):this.actions.setDestinationFromCoordinates(t),this}},{key:"reverse",value:function(){return this.actions.reverse(),this}},{key:"addWaypoint",value:function(t,e){return e.type||(e=a.default.createPoint(e,{id:"waypoint"})),this.actions.addWaypoint(t,e),this}},{key:"setWaypoint",value:function(t,e){return e.type||(e=a.default.createPoint(e,{id:"waypoint"})),this.actions.setWaypoint(t,e),this}},{key:"removeWaypoint",value:function(t){var e=h.getState().waypoints;return this.actions.removeWaypoint(e[t]),this}},{key:"getDistanceAndDuration",value:function(){var t=h.getState();if(null===t)return null;var e=t.directions,n=t.routeIndex,r=t.unit;return null===e[n]?null:{duration:a.default.format.duration(e[n].duration),distance:a.default.format[r](e[n].distance)}}},{key:"getWaypoints",value:function(){return h.getState().waypoints}},{key:"removeRoutes",value:function(){return this.actions.clearOrigin(),this.actions.clearDestination(),this}},{key:"on",value:function(t,e){return this.actions.eventSubscribe(t,e),this}}]),t}();n.default=v},{"./actions":33,"./controls/inputs":36,"./controls/instructions":37,"./directions_style":39,"./reducers":41,"./utils":42,polyline:10,redux:17,"redux-thunk":11}],39:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.default=[{id:"directions-route-line-alt",type:"line",source:"directions",layout:{"line-cap":"round","line-join":"round"},paint:{"line-color":"#bbb","line-width":4},filter:["all",["in","$type","LineString"],["in","route","alternate"]]},{id:"directions-route-line",type:"line",source:"directions",layout:{"line-cap":"round","line-join":"round"},paint:{"line-color":"#608BC7","line-width":4},filter:["all",["in","$type","LineString"],["in","route","selected"]]},{id:"directions-hover-point-casing",type:"circle",source:"directions",paint:{"circle-radius":8,"circle-color":"#fff"},filter:["all",["in","$type","Point"],["in","id","hover"]]},{id:"directions-hover-point",type:"circle",source:"directions",paint:{"circle-radius":6,"circle-color":"#3bb2d0"},filter:["all",["in","$type","Point"],["in","id","hover"]]},{id:"directions-waypoint-point-casing",type:"circle",source:"directions",paint:{"circle-radius":8,"circle-color":"#fff"},filter:["all",["in","$type","Point"],["in","id","waypoint"]]},{id:"directions-waypoint-point",type:"circle",source:"directions",paint:{"circle-radius":6,"circle-color":"#608BC7"},filter:["all",["in","$type","Point"],["in","id","waypoint"]]},{id:"directions-origin-point",type:"circle",source:"directions",paint:{"circle-radius":18,"circle-color":"#93AFD7"},filter:["all",["in","$type","Point"],["in","marker-symbol","A"]]},{id:"directions-origin-label",type:"symbol",source:"directions",layout:{"text-field":"A","text-font":["Open Sans Bold","Arial Unicode MS Bold"],"text-size":12},paint:{"text-color":"#fff"},filter:["all",["in","$type","Point"],["in","marker-symbol","A"]]},{id:"directions-destination-point",type:"circle",source:"directions",paint:{"circle-radius":18,"circle-color":"#608BC7"},filter:["all",["in","$type","Point"],["in","marker-symbol","B"]]},{id:"directions-destination-label",type:"symbol",source:"directions",layout:{"text-field":"B","text-font":["Open Sans Bold","Arial Unicode MS Bold"],"text-size":12},paint:{"text-color":"#fff"},filter:["all",["in","$type","Point"],["in","marker-symbol","B"]]}]},{}],40:[function(t,e,n){"use strict";var r,i=t("./directions"),o=(r=i)&&r.__esModule?r:{default:r};e.exports=o.default},{"./directions":38}],41:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r,i=function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}(t("../constants/action_types.js")),o=t("deep-assign"),s=(r=o)&&r.__esModule?r:{default:r};var a={api:"https://api.mapbox.com/directions/v5/",profile:"driving-traffic",unit:"imperial",proximity:!1,styles:[],controls:{inputs:!0,instructions:!0},geocoder:{},interactive:!0,events:{},origin:{},destination:{},hoverMarker:{},waypoints:[],originQuery:null,destinationQuery:null,originQueryCoordinates:null,destinationQueryCoordinates:null,directions:[],routeIndex:0};n.default=function(){var t=arguments.length<=0||void 0===arguments[0]?a:arguments[0],e=arguments[1];switch(e.type){case i.SET_OPTIONS:return(0,s.default)({},t,e.options);case i.DIRECTIONS_PROFILE:return Object.assign({},t,{profile:e.profile});case i.ORIGIN:return Object.assign({},t,{origin:e.origin,hoverMarker:{}});case i.DESTINATION:return Object.assign({},t,{destination:e.destination,hoverMarker:{}});case i.HOVER_MARKER:return Object.assign({},t,{hoverMarker:e.hoverMarker});case i.WAYPOINTS:return Object.assign({},t,{waypoints:e.waypoints});case i.ORIGIN_QUERY:return Object.assign({},t,{originQuery:e.query});case i.DESTINATION_QUERY:return Object.assign({},t,{destinationQuery:e.query});case i.ORIGIN_FROM_COORDINATES:return Object.assign({},t,{originQueryCoordinates:e.coordinates});case i.DESTINATION_FROM_COORDINATES:return Object.assign({},t,{destinationQueryCoordinates:e.coordinates});case i.ORIGIN_CLEAR:return Object.assign({},t,{origin:{},originQuery:"",waypoints:[],directions:[]});case i.DESTINATION_CLEAR:return Object.assign({},t,{destination:{},destinationQuery:"",waypoints:[],directions:[]});case i.DIRECTIONS:return Object.assign({},t,{directions:e.directions});case i.ROUTE_INDEX:return Object.assign({},t,{routeIndex:e.routeIndex});case i.ERROR:return Object.assign({},t,{error:e.error});default:return t}}},{"../constants/action_types.js":34,"deep-assign":3}],42:[function(t,e,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r={duration:function(t){var e=Math.floor(t/60),n=Math.floor(e/60);return t%=60,e%=60,0===n&&0===e?t+"s":0===n?e+"min":n+"h "+e+"min"},imperial:function(t){var e=t/1609.344;return e>=100?e.toFixed(0)+"mi":e>=10?e.toFixed(1)+"mi":e>=.1?e.toFixed(2)+"mi":(5280*e).toFixed(0)+"ft"},metric:function(t){return t>=1e5?(t/1e3).toFixed(0)+"km":t>=1e4?(t/1e3).toFixed(1)+"km":t>=100?(t/1e3).toFixed(2)+"km":t.toFixed(0)+"m"}};n.default={format:r,coordinateMatch:function(t,e){return t=t.geometry.coordinates,e=e.geometry.coordinates,t.join()===e.join()||t[0].toFixed(3)===e[0].toFixed(3)&&t[1].toFixed(3)===e[1].toFixed(3)},createPoint:function(t,e){return{type:"Feature",geometry:{type:"Point",coordinates:t},properties:e||{}}},validCoords:function(t){return t[0]>=-180&&t[0]<=180&&t[1]>=-90&&t[1]<=90},wrap:function(t){var e=((t- -180)%360+360)%360-180;return-180===e?180:e}}},{}]},{},[40])(40)});
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.MapboxDirections = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError("n must be a positive number");
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error("(node) warning: possible EventEmitter memory " +
                    "leak detected. %d listeners added. " +
					"Use emitter.setMaxListeners() to increase limit.",
                    this._events[type].length);
      if (typeof console.trace === "function") {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
    try {
        cachedSetTimeout = setTimeout;
    } catch (e) {
        cachedSetTimeout = function () {
            throw new Error('setTimeout is not defined');
        }
    }
    try {
        cachedClearTimeout = clearTimeout;
    } catch (e) {
        cachedClearTimeout = function () {
            throw new Error('clearTimeout is not defined');
        }
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
'use strict';
var isObj = require('is-obj');
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Sources cannot be null or undefined');
	}

	return Object(val);
}

function assignKey(to, from, key) {
	var val = from[key];

	if (val === undefined || val === null) {
		return;
	}

	if (hasOwnProperty.call(to, key)) {
		if (to[key] === undefined || to[key] === null) {
			throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
		}
	}

	if (!hasOwnProperty.call(to, key) || !isObj(val)) {
		to[key] = val;
	} else {
		to[key] = assign(Object(to[key]), from[key]);
	}
}

function assign(to, from) {
	if (to === from) {
		return to;
	}

	from = Object(from);

	for (var key in from) {
		if (hasOwnProperty.call(from, key)) {
			assignKey(to, from, key);
		}
	}

	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(from);

		for (var i = 0; i < symbols.length; i++) {
			if (propIsEnumerable.call(from, symbols[i])) {
				assignKey(to, from, symbols[i]);
			}
		}
	}

	return to;
}

module.exports = function deepAssign(target) {
	target = toObject(target);

	for (var s = 1; s < arguments.length; s++) {
		assign(target, arguments[s]);
	}

	return target;
};

},{"is-obj":4}],4:[function(require,module,exports){
'use strict';
module.exports = function (x) {
	var type = typeof x;
	return x !== null && (type === 'object' || type === 'function');
};

},{}],5:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],6:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = isEqual;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],7:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var reInterpolate = require('lodash._reinterpolate'),
    templateSettings = require('lodash.templatesettings');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to ensure capturing order of template delimiters. */
var reNoMatch = /($^)/;

/** Used to match unescaped characters in compiled string literals. */
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol,
    propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Used by `_.defaults` to customize its `_.assignIn` use.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function assignInDefaults(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  return (objectToString.call(value) == errorTag) ||
    (typeof value.message == 'string' && typeof value.name == 'string');
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES delimiter as an alternative to the default "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */
function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }
  string = toString(string);
  options = assignInWith({}, options, settings, assignInDefaults);

  var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);

  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '";

  // Compile the regexp to match each delimiter.
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + '|' +
    interpolate.source + '|' +
    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
    (options.evaluate || reNoMatch).source + '|$'
  , 'g');

  // Use a sourceURL for easier debugging.
  var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';

  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);

    // Escape characters that can't be included in string literals.
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

    // Replace delimiters with snippets.
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;

    // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.
    return match;
  });

  source += "';\n";

  // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable = options.variable;
  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  }
  // Cleanup code by stripping empty strings.
  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
    .replace(reEmptyStringMiddle, '$1')
    .replace(reEmptyStringTrailing, '$1;');

  // Frame code as the function body.
  source = 'function(' + (variable || 'obj') + ') {\n' +
    (variable
      ? ''
      : 'obj || (obj = {});\n'
    ) +
    "var __t, __p = ''" +
    (isEscaping
       ? ', __e = _.escape'
       : ''
    ) +
    (isEvaluating
      ? ', __j = Array.prototype.join;\n' +
        "function print() { __p += __j.call(arguments, '') }\n"
      : ';\n'
    ) +
    source +
    'return __p\n}';

  var result = attempt(function() {
    return Function(importsKeys, sourceURL + 'return ' + source)
      .apply(undefined, importsValues);
  });

  // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = baseRest(function(func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

module.exports = template;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"lodash._reinterpolate":8,"lodash.templatesettings":9}],8:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

module.exports = reInterpolate;

},{}],9:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var reInterpolate = require('lodash._reinterpolate');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"'`]/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g,
    reEvaluate = /<%([\s\S]+?)%>/g;

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '`': '&#96;'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB). Change the following template settings to use
 * alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {

  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {

    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': { 'escape': escape }
  }
};

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
 * their corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * Backticks are escaped because in IE < 9, they can break out of
 * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
 * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
 * [#133](https://html5sec.org/#133) of the
 * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = templateSettings;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"lodash._reinterpolate":8}],10:[function(require,module,exports){
'use strict';

/**
 * Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
 *
 * Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)
 * by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)
 *
 * @module polyline
 */

var polyline = {};

function encode(coordinate, factor) {
    coordinate = Math.round(coordinate * factor);
    coordinate <<= 1;
    if (coordinate < 0) {
        coordinate = ~coordinate;
    }
    var output = '';
    while (coordinate >= 0x20) {
        output += String.fromCharCode((0x20 | (coordinate & 0x1f)) + 63);
        coordinate >>= 5;
    }
    output += String.fromCharCode(coordinate + 63);
    return output;
}

/**
 * Decodes to a [latitude, longitude] coordinates array.
 *
 * This is adapted from the implementation in Project-OSRM.
 *
 * @param {String} str
 * @param {Number} precision
 * @returns {Array}
 *
 * @see https://github.com/Project-OSRM/osrm-frontend/blob/master/WebContent/routing/OSRM.RoutingGeometry.js
 */
polyline.decode = function(str, precision) {
    var index = 0,
        lat = 0,
        lng = 0,
        coordinates = [],
        shift = 0,
        result = 0,
        byte = null,
        latitude_change,
        longitude_change,
        factor = Math.pow(10, precision || 5);

    // Coordinates have variable length when encoded, so just keep
    // track of whether we've hit the end of the string. In each
    // loop iteration, a single coordinate is decoded.
    while (index < str.length) {

        // Reset shift, result, and byte
        byte = null;
        shift = 0;
        result = 0;

        do {
            byte = str.charCodeAt(index++) - 63;
            result |= (byte & 0x1f) << shift;
            shift += 5;
        } while (byte >= 0x20);

        latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

        shift = result = 0;

        do {
            byte = str.charCodeAt(index++) - 63;
            result |= (byte & 0x1f) << shift;
            shift += 5;
        } while (byte >= 0x20);

        longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

        lat += latitude_change;
        lng += longitude_change;

        coordinates.push([lat / factor, lng / factor]);
    }

    return coordinates;
};

/**
 * Encodes the given [latitude, longitude] coordinates array.
 *
 * @param {Array.<Array.<Number>>} coordinates
 * @param {Number} precision
 * @returns {String}
 */
polyline.encode = function(coordinates, precision) {
    if (!coordinates.length) { return ''; }

    var factor = Math.pow(10, precision || 5),
        output = encode(coordinates[0][0], factor) + encode(coordinates[0][1], factor);

    for (var i = 1; i < coordinates.length; i++) {
        var a = coordinates[i], b = coordinates[i - 1];
        output += encode(a[0] - b[0], factor);
        output += encode(a[1] - b[1], factor);
    }

    return output;
};

function flipped(coords) {
    var flipped = [];
    for (var i = 0; i < coords.length; i++) {
        flipped.push(coords[i].slice().reverse());
    }
    return flipped;
}

/**
 * Encodes a GeoJSON LineString feature/geometry.
 *
 * @param {Object} geojson
 * @param {Number} precision
 * @returns {String}
 */
polyline.fromGeoJSON = function(geojson, precision) {
    if (geojson && geojson.type === 'Feature') {
        geojson = geojson.geometry;
    }
    if (!geojson || geojson.type !== 'LineString') {
        throw new Error('Input must be a GeoJSON LineString');
    }
    return polyline.encode(flipped(geojson.coordinates), precision);
};

/**
 * Decodes to a GeoJSON LineString geometry.
 *
 * @param {String} str
 * @param {Number} precision
 * @returns {Object}
 */
polyline.toGeoJSON = function(str, precision) {
    var coords = polyline.decode(str, precision);
    return {
        type: 'LineString',
        coordinates: flipped(coords)
    };
};

if (typeof module === 'object' && module.exports) {
    module.exports = polyline;
}

},{}],11:[function(require,module,exports){
'use strict';

exports.__esModule = true;
function createThunkMiddleware(extraArgument) {
  return function (_ref) {
    var dispatch = _ref.dispatch;
    var getState = _ref.getState;
    return function (next) {
      return function (action) {
        if (typeof action === 'function') {
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    };
  };
}

var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

exports['default'] = thunk;
},{}],12:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports["default"] = applyMiddleware;

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, initialState, enhancer) {
      var store = createStore(reducer, initialState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}
},{"./compose":15}],13:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports["default"] = bindActionCreators;
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
},{}],14:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;
exports["default"] = combineReducers;

var _createStore = require('./createStore');

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _warning = require('./utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!(0, _isPlainObject2["default"])(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key);
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerSanity(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];
    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  var sanityError;
  try {
    assertReducerSanity(finalReducers);
  } catch (e) {
    sanityError = e;
  }

  return function combination() {
    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var action = arguments[1];

    if (sanityError) {
      throw sanityError;
    }

    if (process.env.NODE_ENV !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
      if (warningMessage) {
        (0, _warning2["default"])(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var i = 0; i < finalReducerKeys.length; i++) {
      var key = finalReducerKeys[i];
      var reducer = finalReducers[key];
      var previousStateForKey = state[key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(key, action);
        throw new Error(errorMessage);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}
}).call(this,require('_process'))
},{"./createStore":16,"./utils/warning":18,"_process":2,"lodash/isPlainObject":23}],15:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = compose;
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  } else {
    var _ret = function () {
      var last = funcs[funcs.length - 1];
      var rest = funcs.slice(0, -1);
      return {
        v: function v() {
          return rest.reduceRight(function (composed, f) {
            return f(composed);
          }, last.apply(undefined, arguments));
        }
      };
    }();

    if (typeof _ret === "object") return _ret.v;
  }
}
},{}],16:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.ActionTypes = undefined;
exports["default"] = createStore;

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _symbolObservable = require('symbol-observable');

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = exports.ActionTypes = {
  INIT: '@@redux/INIT'
};

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [initialState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} enhancer The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */
function createStore(reducer, initialState, enhancer) {
  var _ref2;

  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
    enhancer = initialState;
    initialState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, initialState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = initialState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!(0, _isPlainObject2["default"])(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      listeners[i]();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/zenparsing/es-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */

      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[_symbolObservable2["default"]] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
}
},{"lodash/isPlainObject":23,"symbol-observable":24}],17:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;
exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

var _createStore = require('./createStore');

var _createStore2 = _interopRequireDefault(_createStore);

var _combineReducers = require('./combineReducers');

var _combineReducers2 = _interopRequireDefault(_combineReducers);

var _bindActionCreators = require('./bindActionCreators');

var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

var _applyMiddleware = require('./applyMiddleware');

var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

var _warning = require('./utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}

exports.createStore = _createStore2["default"];
exports.combineReducers = _combineReducers2["default"];
exports.bindActionCreators = _bindActionCreators2["default"];
exports.applyMiddleware = _applyMiddleware2["default"];
exports.compose = _compose2["default"];
}).call(this,require('_process'))
},{"./applyMiddleware":12,"./bindActionCreators":13,"./combineReducers":14,"./compose":15,"./createStore":16,"./utils/warning":18,"_process":2}],18:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports["default"] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}
},{}],19:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":21}],20:[function(require,module,exports){
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

module.exports = isHostObject;

},{}],21:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],22:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],23:[function(require,module,exports){
var getPrototype = require('./_getPrototype'),
    isHostObject = require('./_isHostObject'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) ||
      objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

module.exports = isPlainObject;

},{"./_getPrototype":19,"./_isHostObject":20,"./isObjectLike":22}],24:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

module.exports = require('./ponyfill')(global || window || this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./ponyfill":25}],25:[function(require,module,exports){
'use strict';

module.exports = function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

},{}],26:[function(require,module,exports){
'use strict';

/**
 * A typeahead component for inputs
 * @class Suggestions
 *
 * @param {HTMLInputElement} el A valid HTML input element
 * @param {Array} data An array of data used for results
 * @param {Object} options
 * @param {Number} [options.limit=5] Max number of results to display in the auto suggest list.
 * @param {Number} [options.minLength=2] Number of characters typed into an input to trigger suggestions.
 * @return {Suggestions} `this`
 * @example
 * // in the browser
 * var input = document.querySelector('input');
 * var data = [
 *   'Roy Eldridge',
 *   'Roy Hargrove',
 *   'Rex Stewart'
 * ];
 *
 * new Suggestions(input, data);
 *
 * // with options
 * var input = document.querySelector('input');
 * var data = [{
 *   name: 'Roy Eldridge',
 *   year: 1911
 * }, {
 *   name: 'Roy Hargrove',
 *   year: 1969
 * }, {
 *   name: 'Rex Stewart',
 *   year: 1907
 * }];
 *
 * var typeahead = new Suggestions(input, data, {
 *   filter: false, // Disable filtering
 *   minLength: 3, // Number of characters typed into an input to trigger suggestions.
 *   limit: 3 //  Max number of results to display.
 * });
 *
 * // As we're passing an object of an arrays as data, override
 * // `getItemValue` by specifying the specific property to search on.
 * typeahead.getItemValue = function(item) { return item.name };
 *
 * input.addEventListener('change', function() {
 *   console.log(typeahead.selected); // Current selected item.
 * });
 *
 * // With browserify
 * var Suggestions = require('suggestions');
 *
 * new Suggestions(input, data);
 */
var Suggestions = require('./src/suggestions');
window.Suggestions = module.exports = Suggestions;

},{"./src/suggestions":29}],27:[function(require,module,exports){
/*
 * Fuzzy
 * https://github.com/myork/fuzzy
 *
 * Copyright (c) 2012 Matt York
 * Licensed under the MIT license.
 */

(function() {

var root = this;

var fuzzy = {};

// Use in node or in browser
if (typeof exports !== 'undefined') {
  module.exports = fuzzy;
} else {
  root.fuzzy = fuzzy;
}

// Return all elements of `array` that have a fuzzy
// match against `pattern`.
fuzzy.simpleFilter = function(pattern, array) {
  return array.filter(function(string) {
    return fuzzy.test(pattern, string);
  });
};

// Does `pattern` fuzzy match `string`?
fuzzy.test = function(pattern, string) {
  return fuzzy.match(pattern, string) !== null;
};

// If `pattern` matches `string`, wrap each matching character
// in `opts.pre` and `opts.post`. If no match, return null
fuzzy.match = function(pattern, string, opts) {
  opts = opts || {};
  var patternIdx = 0
    , result = []
    , len = string.length
    , totalScore = 0
    , currScore = 0
    // prefix
    , pre = opts.pre || ''
    // suffix
    , post = opts.post || ''
    // String to compare against. This might be a lowercase version of the
    // raw string
    , compareString =  opts.caseSensitive && string || string.toLowerCase()
    , ch, compareChar;

  pattern = opts.caseSensitive && pattern || pattern.toLowerCase();

  // For each character in the string, either add it to the result
  // or wrap in template if it's the next string in the pattern
  for(var idx = 0; idx < len; idx++) {
    ch = string[idx];
    if(compareString[idx] === pattern[patternIdx]) {
      ch = pre + ch + post;
      patternIdx += 1;

      // consecutive characters should increase the score more than linearly
      currScore += 1 + currScore;
    } else {
      currScore = 0;
    }
    totalScore += currScore;
    result[result.length] = ch;
  }

  // return rendered string if we have a match for every char
  if(patternIdx === pattern.length) {
    return {rendered: result.join(''), score: totalScore};
  }

  return null;
};

// The normal entry point. Filters `arr` for matches against `pattern`.
// It returns an array with matching values of the type:
//
//     [{
//         string:   '<b>lah' // The rendered string
//       , index:    2        // The index of the element in `arr`
//       , original: 'blah'   // The original element in `arr`
//     }]
//
// `opts` is an optional argument bag. Details:
//
//    opts = {
//        // string to put before a matching character
//        pre:     '<b>'
//
//        // string to put after matching character
//      , post:    '</b>'
//
//        // Optional function. Input is an entry in the given arr`,
//        // output should be the string to test `pattern` against.
//        // In this example, if `arr = [{crying: 'koala'}]` we would return
//        // 'koala'.
//      , extract: function(arg) { return arg.crying; }
//    }
fuzzy.filter = function(pattern, arr, opts) {
  opts = opts || {};
  return arr
    .reduce(function(prev, element, idx, arr) {
      var str = element;
      if(opts.extract) {
        str = opts.extract(element);
      }
      var rendered = fuzzy.match(pattern, str, opts);
      if(rendered != null) {
        prev[prev.length] = {
            string: rendered.rendered
          , score: rendered.score
          , index: idx
          , original: element
        };
      }
      return prev;
    }, [])

    // Sort by score. Browsers are inconsistent wrt stable/unstable
    // sorting, so force stable by using the index in the case of tie.
    // See http://ofb.net/~sethml/is-sort-stable.html
    .sort(function(a,b) {
      var compare = b.score - a.score;
      if(compare) return compare;
      return a.index - b.index;
    });
};


}());


},{}],28:[function(require,module,exports){
'Use strict';

var List = function(component) {
  this.component = component;
  this.items = [];
  this.active = 0;
  this.element = document.createElement('ul');
  this.element.className = 'suggestions';

  component.el.parentNode.insertBefore(this.element, component.el.nextSibling);
  return this;
};

List.prototype.show = function() {
  this.element.style.display = 'block';
};

List.prototype.hide = function() {
  this.element.style.display = 'none';
};

List.prototype.add = function(item) {
  this.items.push(item);
};

List.prototype.clear = function() {
  this.items = [];
  this.active = 0;
};

List.prototype.isEmpty = function() {
  return !this.items.length;
};

List.prototype.draw = function() {
  this.element.innerHTML = '';

  if (this.items.length === 0) {
    this.hide();
    return;
  }

  for (var i = 0; i < this.items.length; i++) {
    this.drawItem(this.items[i], this.active === i);
  }

  this.show();
};

List.prototype.drawItem = function(item, active) {
  var li = document.createElement('li'),
    a = document.createElement('a');

  if (active) li.className += ' active';

  a.innerHTML = item.string;

  li.appendChild(a);
  this.element.appendChild(li);

  li.addEventListener('mousedown', function() {
    this.handleMouseDown.call(this, item);
  }.bind(this));
};

List.prototype.handleMouseDown = function(item) {
  this.component.value(item.original);
  this.clear();
  this.draw();
};

List.prototype.move = function(index) {
  this.active = index;
  this.draw();
};

List.prototype.previous = function() {
  this.move(this.active === 0 ? this.items.length - 1 : this.active - 1);
};

List.prototype.next = function() {
  this.move(this.active === this.items.length - 1 ? 0 : this.active + 1);
};

module.exports = List;

},{}],29:[function(require,module,exports){
'use strict';

var extend = require('xtend');
var fuzzy = require('fuzzy');
var List = require('./list');

var Suggestions = function(el, data, options) {
  options = options || {};

  this.options = extend({
    minLength: 2,
    limit: 5,
    filter: true
  }, options);

  this.el = el;
  this.data = data || [];
  this.list = new List(this);

  this.query = '';
  this.selected = null;

  this.list.draw();

  this.el.addEventListener('keyup', function(e) {
    this.handleKeyUp(e.keyCode);
  }.bind(this), false);

  this.el.addEventListener('keydown', function(e) {
    this.handleKeyDown(e);
  }.bind(this));

  this.el.addEventListener('focus', function() {
    this.handleFocus();
  }.bind(this));

  this.el.addEventListener('blur', function() {
    this.handleBlur();
  }.bind(this));

  return this;
};

Suggestions.prototype.handleKeyUp = function(keyCode) {
  // 40 - DOWN
  // 38 - UP
  // 27 - ESC
  // 13 - ENTER
  // 9 - TAB

  if (keyCode === 40 ||
      keyCode === 38 ||
      keyCode === 27 ||
      keyCode === 13 ||
      keyCode === 9) return;

  this.query = this.normalize(this.el.value);

  this.list.clear();

  if (this.query.length < this.options.minLength) {
    this.list.draw();
    return;
  }

  this.getCandidates(function(data) {
    for (var i = 0; i < data.length; i++) {
      this.list.add(data[i]);
      if (i === (this.options.limit - 1)) break;
    }
    this.list.draw();
  }.bind(this));
};

Suggestions.prototype.handleKeyDown = function(e) {
  switch (e.keyCode) {
    case 13: // ENTER
    case 9:  // TAB
      if (!this.list.isEmpty()) {
        this.value(this.list.items[this.list.active].original);
        this.list.hide();
      }
    break;
    case 27: // ESC
      if (!this.list.isEmpty()) this.list.hide();
    break;
    case 38: // UP
      this.list.previous();
    break;
    case 40: // DOWN
      this.list.next();
    break;
  }
};

Suggestions.prototype.handleBlur = function() {
  this.list.hide();
};

Suggestions.prototype.handleFocus = function() {
  if (!this.list.isEmpty()) this.list.show();
};

/**
 * Update data previously passed
 *
 * @param {Array} revisedData
 */
Suggestions.prototype.update = function(revisedData) {
  this.data = revisedData;
  this.list.draw();
};

/**
 * Clears data
 */
Suggestions.prototype.clear = function() {
  this.data = [];
  this.list.clear();
};

/**
 * Normalize the results list and input value for matching
 *
 * @param {String} value
 * @return {String}
 */
Suggestions.prototype.normalize = function(value) {
  value = value.toLowerCase();
  return value;
};

/**
 * Evaluates whether an array item qualifies as a match with the current query
 *
 * @param {String} candidate a possible item from the array passed
 * @param {String} query the current query
 * @return {Boolean}
 */
Suggestions.prototype.match = function(candidate, query) {
  return candidate.indexOf(query) > -1;
};

Suggestions.prototype.value = function(value) {
  this.selected = value;
  this.el.value = this.getItemValue(value);

  if (document.createEvent) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent('change', true, false);
    this.el.dispatchEvent(e);
  } else {
    this.el.fireEvent('onchange');
  }
};

Suggestions.prototype.getCandidates = function(callback) {
  var options = {
    pre: '<strong>',
    post: '</strong>',
    extract: function(d) { return this.getItemValue(d); }.bind(this)
  };

  var results = this.options.filter ?
    fuzzy.filter(this.query, this.data, options) :
    this.data.map(function(d) {
      return {
        original: d,
        string: this.getItemValue(d).replace(new RegExp('(' + this.query + ')', 'ig'), function($1, match) {
          return '<strong>' + match + '</strong>';
        })
      };
    }.bind(this));

  callback(results);
};

/**
 * For a given item in the data array, return what should be used as the candidate string
 *
 * @param {Object|String} item an item from the data array
 * @return {String} item
 */
Suggestions.prototype.getItemValue = function(item) {
  return item;
};

module.exports = Suggestions;

},{"./list":28,"fuzzy":27,"xtend":32}],30:[function(require,module,exports){
var each = require('turf-meta').coordEach;

/**
 * Takes any {@link GeoJSON} object, calculates the extent of all input features, and returns a bounding box.
 *
 * @module turf/extent
 * @category measurement
 * @param {GeoJSON} input any valid GeoJSON Object
 * @return {Array<number>} the bounding box of `input` given
 * as an array in WSEN order (west, south, east, north)
 * @example
 * var input = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.175329, 22.2524]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.170007, 22.267969]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.200649, 22.274641]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.186744, 22.265745]
 *       }
 *     }
 *   ]
 * };
 *
 * var bbox = turf.extent(input);
 *
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * var resultFeatures = input.features.concat(bboxPolygon);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function(layer) {
    var extent = [Infinity, Infinity, -Infinity, -Infinity];
    each(layer, function(coord) {
      if (extent[0] > coord[0]) extent[0] = coord[0];
      if (extent[1] > coord[1]) extent[1] = coord[1];
      if (extent[2] < coord[0]) extent[2] = coord[0];
      if (extent[3] < coord[1]) extent[3] = coord[1];
    });
    return extent;
};

},{"turf-meta":31}],31:[function(require,module,exports){
/**
 * Lazily iterate over coordinates in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @param {boolean=} excludeWrapCoord whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var point = { type: 'Point', coordinates: [0, 0] };
 * coordEach(point, function(coords) {
 *   // coords is equal to [0, 0]
 * });
 */
function coordEach(layer, callback, excludeWrapCoord) {
  var i, j, k, g, geometry, stopG, coords,
    geometryMaybeCollection,
    wrapShrink = 0,
    isGeometryCollection,
    isFeatureCollection = layer.type === 'FeatureCollection',
    isFeature = layer.type === 'Feature',
    stop = isFeatureCollection ? layer.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
  for (i = 0; i < stop; i++) {

    geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
        (isFeature ? layer.geometry : layer));
    isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

    for (g = 0; g < stopG; g++) {

      geometry = isGeometryCollection ?
          geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
      coords = geometry.coordinates;

      wrapShrink = (excludeWrapCoord &&
        (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?
        1 : 0;

      if (geometry.type === 'Point') {
        callback(coords);
      } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
        for (j = 0; j < coords.length; j++) callback(coords[j]);
      } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
        for (j = 0; j < coords.length; j++)
          for (k = 0; k < coords[j].length - wrapShrink; k++)
            callback(coords[j][k]);
      } else if (geometry.type === 'MultiPolygon') {
        for (j = 0; j < coords.length; j++)
          for (k = 0; k < coords[j].length; k++)
            for (l = 0; l < coords[j][k].length - wrapShrink; l++)
              callback(coords[j][k][l]);
      } else {
        throw new Error('Unknown Geometry Type');
      }
    }
  }
}
module.exports.coordEach = coordEach;

/**
 * Lazily reduce coordinates in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all coordinates is unnecessary.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (memo, value) and returns
 * a new memo
 * @param {boolean=} excludeWrapCoord whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @param {*} memo the starting value of memo: can be any type.
 */
function coordReduce(layer, callback, memo, excludeWrapCoord) {
  coordEach(layer, function(coord) {
    memo = callback(memo, coord);
  }, excludeWrapCoord);
  return memo;
}
module.exports.coordReduce = coordReduce;

/**
 * Lazily iterate over property objects in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @example
 * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };
 * propEach(point, function(props) {
 *   // props is equal to { foo: 1}
 * });
 */
function propEach(layer, callback) {
  var i;
  switch (layer.type) {
      case 'FeatureCollection':
        features = layer.features;
        for (i = 0; i < layer.features.length; i++) {
            callback(layer.features[i].properties);
        }
        break;
      case 'Feature':
        callback(layer.properties);
        break;
  }
}
module.exports.propEach = propEach;

/**
 * Lazily reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (memo, coord) and returns
 * a new memo
 * @param {*} memo the starting value of memo: can be any type.
 */
function propReduce(layer, callback, memo) {
  propEach(layer, function(prop) {
    memo = callback(memo, prop);
  });
  return memo;
}
module.exports.propReduce = propReduce;

},{}],32:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.queryOrigin = queryOrigin;
exports.queryDestination = queryDestination;
exports.queryOriginCoordinates = queryOriginCoordinates;
exports.queryDestinationCoordinates = queryDestinationCoordinates;
exports.clearOrigin = clearOrigin;
exports.clearDestination = clearDestination;
exports.setOptions = setOptions;
exports.hoverMarker = hoverMarker;
exports.setRouteIndex = setRouteIndex;
exports.createOrigin = createOrigin;
exports.createDestination = createDestination;
exports.setProfile = setProfile;
exports.reverse = reverse;
exports.setOriginFromCoordinates = setOriginFromCoordinates;
exports.setDestinationFromCoordinates = setDestinationFromCoordinates;
exports.addWaypoint = addWaypoint;
exports.setWaypoint = setWaypoint;
exports.removeWaypoint = removeWaypoint;
exports.eventSubscribe = eventSubscribe;
exports.eventEmit = eventEmit;

var _action_types = require('../constants/action_types');

var types = _interopRequireWildcard(_action_types);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var request = new XMLHttpRequest();

function originPoint(coordinates) {
  return function (dispatch) {
    var origin = _utils2.default.createPoint(coordinates, {
      id: 'origin',
      'marker-symbol': 'A'
    });

    dispatch({ type: types.ORIGIN, origin: origin });
    dispatch(eventEmit('origin', { feature: origin }));
  };
}

function destinationPoint(coordinates) {
  return function (dispatch) {
    var destination = _utils2.default.createPoint(coordinates, {
      id: 'destination',
      'marker-symbol': 'B'
    });

    dispatch({ type: types.DESTINATION, destination: destination });
    dispatch(eventEmit('destination', { feature: destination }));
  };
}

function setDirections(directions) {
  return function (dispatch) {
    dispatch({
      type: types.DIRECTIONS,
      directions: directions
    });
    dispatch(eventEmit('route', { route: directions }));
  };
}

function updateWaypoints(waypoints) {
  return {
    type: types.WAYPOINTS,
    waypoints: waypoints
  };
}

function setHoverMarker(feature) {
  return {
    type: types.HOVER_MARKER,
    hoverMarker: feature
  };
}

function fetchDirections() {
  return function (dispatch, getState) {
    var _getState = getState();

    var api = _getState.api;
    var accessToken = _getState.accessToken;
    var routeIndex = _getState.routeIndex;
    var profile = _getState.profile;

    var query = buildDirectionsQuery(getState);

    // Request params
    var options = [];
    options.push('geometries=polyline');
    options.push('alternatives=true');
    options.push('steps=true');
    options.push('overview=full');
    options.push('access_token=' + accessToken);
    request.abort();
    request.open('GET', api + 'mapbox/' + profile + '/' + query + '.json?' + options.join('&'), true);

    request.onload = function () {
      if (request.status >= 200 && request.status < 400) {
        var data = JSON.parse(request.responseText);
        if (data.error) {
          dispatch(setDirections([]));
          return dispatch(setError(data.error));
        }

        dispatch(setError(null));
        if (!data.routes[routeIndex]) dispatch(setRouteIndex(0));
        dispatch(setDirections(data.routes));

        // Revise origin / destination points
        dispatch(originPoint(data.waypoints[0].location));
        dispatch(destinationPoint(data.waypoints[data.waypoints.length - 1].location));
      } else {
        dispatch(setDirections([]));
        return dispatch(setError(JSON.parse(request.responseText).message));
      }
    };

    request.onerror = function () {
      dispatch(setDirections([]));
      return dispatch(setError(JSON.parse(request.responseText).message));
    };

    request.send();
  };
}

/*
 * Build query used to fetch directions
 *
 * @param {Function} state
 */
function buildDirectionsQuery(state) {
  var _state = state();

  var origin = _state.origin;
  var destination = _state.destination;
  var waypoints = _state.waypoints;


  var query = [];
  query.push(origin.geometry.coordinates.join(','));
  query.push(';');

  // Add any waypoints.
  if (waypoints.length) {
    waypoints.forEach(function (waypoint) {
      query.push(waypoint.geometry.coordinates.join(','));
      query.push(';');
    });
  }

  query.push(destination.geometry.coordinates.join(','));
  return encodeURIComponent(query.join(''));
}

function normalizeWaypoint(waypoint) {
  var properties = { id: 'waypoint' };
  return Object.assign(waypoint, {
    properties: waypoint.properties ? Object.assign(waypoint.properties, properties) : properties
  });
}

function setError(error) {
  return function (dispatch) {
    dispatch({
      type: 'ERROR',
      error: error
    });
    if (error) dispatch(eventEmit('error', { error: error }));
  };
}

function queryOrigin(query) {
  return {
    type: types.ORIGIN_QUERY,
    query: query
  };
}

function queryDestination(query) {
  return {
    type: types.DESTINATION_QUERY,
    query: query
  };
}

function queryOriginCoordinates(coords) {
  return {
    type: types.ORIGIN_FROM_COORDINATES,
    coordinates: coords
  };
}

function queryDestinationCoordinates(coords) {
  return {
    type: types.DESTINATION_FROM_COORDINATES,
    coordinates: coords
  };
}

function clearOrigin() {
  return function (dispatch) {
    dispatch({
      type: types.ORIGIN_CLEAR
    });
    dispatch(eventEmit('clear', { type: 'origin' }));
    dispatch(setError(null));
  };
}

function clearDestination() {
  return function (dispatch) {
    dispatch({
      type: types.DESTINATION_CLEAR
    });
    dispatch(eventEmit('clear', { type: 'destination' }));
    dispatch(setError(null));
  };
}

function setOptions(options) {
  return {
    type: types.SET_OPTIONS,
    options: options
  };
}

function hoverMarker(coordinates) {
  return function (dispatch) {
    var feature = coordinates ? _utils2.default.createPoint(coordinates, { id: 'hover' }) : {};
    dispatch(setHoverMarker(feature));
  };
}

function setRouteIndex(routeIndex) {
  return {
    type: types.ROUTE_INDEX,
    routeIndex: routeIndex
  };
}

function createOrigin(coordinates) {
  return function (dispatch, getState) {
    var _getState2 = getState();

    var destination = _getState2.destination;

    dispatch(originPoint(coordinates));
    if (destination.geometry) dispatch(fetchDirections());
  };
}

function createDestination(coordinates) {
  return function (dispatch, getState) {
    var _getState3 = getState();

    var origin = _getState3.origin;

    dispatch(destinationPoint(coordinates));
    if (origin.geometry) dispatch(fetchDirections());
  };
}

function setProfile(profile) {
  return function (dispatch, getState) {
    var _getState4 = getState();

    var origin = _getState4.origin;
    var destination = _getState4.destination;

    dispatch({ type: types.DIRECTIONS_PROFILE, profile: profile });
    dispatch(eventEmit('profile', { profile: profile }));
    if (origin.geometry && destination.geometry) dispatch(fetchDirections());
  };
}

function reverse() {
  return function (dispatch, getState) {
    var state = getState();
    if (state.destination.geometry) dispatch(originPoint(state.destination.geometry.coordinates));
    if (state.origin.geometry) dispatch(destinationPoint(state.origin.geometry.coordinates));
    if (state.origin.geometry && state.destination.geometry) dispatch(fetchDirections());
  };
}

/*
 * Set origin from coordinates
 *
 * @param {Array<number>} coordinates [lng, lat] array.
 */
function setOriginFromCoordinates(coords) {
  return function (dispatch) {
    if (!_utils2.default.validCoords(coords)) coords = [_utils2.default.wrap(coords[0]), _utils2.default.wrap(coords[1])];
    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));
    dispatch(queryOriginCoordinates(coords));
    dispatch(createOrigin(coords));
  };
}

/*
 * Set destination from coordinates
 *
 * @param {Array<number>} coords [lng, lat] array.
 */
function setDestinationFromCoordinates(coords) {
  return function (dispatch) {
    if (!_utils2.default.validCoords(coords)) coords = [_utils2.default.wrap(coords[0]), _utils2.default.wrap(coords[1])];
    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));
    dispatch(createDestination(coords));
    dispatch(queryDestinationCoordinates(coords));
  };
}

function addWaypoint(index, waypoint) {
  return function (dispatch, getState) {
    var _getState5 = getState();

    var destination = _getState5.destination;
    var waypoints = _getState5.waypoints;

    waypoints.splice(index, 0, normalizeWaypoint(waypoint));
    dispatch(updateWaypoints(waypoints));
    if (destination.geometry) dispatch(fetchDirections());
  };
}

function setWaypoint(index, waypoint) {
  return function (dispatch, getState) {
    var _getState6 = getState();

    var destination = _getState6.destination;
    var waypoints = _getState6.waypoints;

    waypoints[index] = normalizeWaypoint(waypoint);
    dispatch(updateWaypoints(waypoints));
    if (destination.geometry) dispatch(fetchDirections());
  };
}

function removeWaypoint(waypoint) {
  return function (dispatch, getState) {
    var _getState7 = getState();

    var destination = _getState7.destination;
    var waypoints = _getState7.waypoints;

    waypoints = waypoints.filter(function (way) {
      return !_utils2.default.coordinateMatch(way, waypoint);
    });

    dispatch(updateWaypoints(waypoints));
    if (destination.geometry) dispatch(fetchDirections());
  };
}

function eventSubscribe(type, fn) {
  return function (dispatch, getState) {
    var _getState8 = getState();

    var events = _getState8.events;

    events[type] = events[type] || [];
    events[type].push(fn);
    return {
      type: types.EVENTS,
      events: events
    };
  };
}

function eventEmit(type, data) {
  var _this = this;

  return function (dispatch, getState) {
    var _getState9 = getState();

    var events = _getState9.events;


    if (!events[type]) {
      return {
        type: types.EVENTS,
        events: events
      };
    }

    var listeners = events[type].slice();

    for (var i = 0; i < listeners.length; i++) {
      listeners[i].call(_this, data);
    }
  };
}

},{"../constants/action_types":34,"../utils":42}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var DESTINATION = exports.DESTINATION = 'DESTINATION';
var DESTINATION_CLEAR = exports.DESTINATION_CLEAR = 'DESTINATION_CLEAR';
var DESTINATION_QUERY = exports.DESTINATION_QUERY = 'DESTINATION_QUERY';
var DESTINATION_FROM_COORDINATES = exports.DESTINATION_FROM_COORDINATES = 'DESTINATION_FROM_COORDINATES';
var DIRECTIONS = exports.DIRECTIONS = 'DIRECTIONS';
var DIRECTIONS_PROFILE = exports.DIRECTIONS_PROFILE = 'DIRECTIONS_PROFILE';
var EVENTS = exports.EVENTS = 'EVENTS';
var ERROR = exports.ERROR = 'ERROR';
var HOVER_MARKER = exports.HOVER_MARKER = 'HOVER_MARKER';
var ORIGIN = exports.ORIGIN = 'ORIGIN';
var ORIGIN_CLEAR = exports.ORIGIN_CLEAR = 'ORIGIN_CLEAR';
var ORIGIN_QUERY = exports.ORIGIN_QUERY = 'ORIGIN_QUERY';
var ORIGIN_FROM_COORDINATES = exports.ORIGIN_FROM_COORDINATES = 'ORIGIN_FROM_COORDINATES';
var ROUTE_INDEX = exports.ROUTE_INDEX = 'ROUTE_INDEX';
var SET_OPTIONS = exports.SET_OPTIONS = 'SET_OPTIONS';
var WAYPOINTS = exports.WAYPOINTS = 'WAYPOINTS';

},{}],35:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _suggestions = require('suggestions');

var _suggestions2 = _interopRequireDefault(_suggestions);

var _lodash = require('lodash.debounce');

var _lodash2 = _interopRequireDefault(_lodash);

var _xtend = require('xtend');

var _xtend2 = _interopRequireDefault(_xtend);

var _events = require('events');

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Mapbox Geocoder version
var API = 'https://api.mapbox.com/geocoding/v5/mapbox.places/';

// Geocoder - this slightly mimicks the mapboxl-gl-geocoder but isn't an exact replica.
// Once gl-js plugins can be added to custom divs, we should be able to require mapbox-gl-geocoder
// instead of including it here
function Geocoder(options) {
  this._ev = new _events.EventEmitter();
  this.options = (0, _xtend2.default)({}, this.options, options);
}

Geocoder.prototype = {

  options: {
    placeholder: 'Search',
    zoom: 16,
    flyTo: true
  },

  onAdd: function onAdd(map) {
    this._map = map;

    this.request = new XMLHttpRequest();

    // Template
    var el = document.createElement('div');
    el.className = 'mapboxgl-ctrl-geocoder';

    var icon = document.createElement('span');
    icon.className = 'geocoder-icon geocoder-icon-search';

    var input = this._inputEl = document.createElement('input');
    input.type = 'text';
    input.placeholder = this.options.placeholder;

    input.addEventListener('keydown', (0, _lodash2.default)(function (e) {
      if (!e.target.value) return this._clearEl.classList.remove('active');

      // TAB, ESC, LEFT, RIGHT, ENTER, UP, DOWN
      if (e.metaKey || [9, 27, 37, 39, 13, 38, 40].indexOf(e.keyCode) !== -1) return;
      this._queryFromInput(e.target.value);
    }.bind(this)), 200);

    input.addEventListener('change', function (e) {
      if (e.target.value) this._clearEl.classList.add('active');

      var selected = this._typeahead.selected;
      if (selected) {
        if (this.options.flyTo) {
          if (selected.bbox && selected.context && selected.context.length <= 3 || selected.bbox && !selected.context) {
            var bbox = selected.bbox;
            map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]]);
          } else {
            map.flyTo({
              center: selected.center,
              zoom: this.options.zoom
            });
          }
        }
        this._input = selected;
        this.fire('result', { result: selected });
      }
    }.bind(this));

    var actions = document.createElement('div');
    actions.classList.add('geocoder-pin-right');

    var clear = this._clearEl = document.createElement('button');
    clear.className = 'geocoder-icon geocoder-icon-close';
    clear.addEventListener('click', this._clear.bind(this));

    var loading = this._loadingEl = document.createElement('span');
    loading.className = 'geocoder-icon geocoder-icon-loading';

    actions.appendChild(clear);
    actions.appendChild(loading);

    el.appendChild(icon);
    el.appendChild(input);
    el.appendChild(actions);

    // Override the control being added to control containers
    if (this.options.container) this.options.position = false;

    this._typeahead = new _suggestions2.default(input, [], { filter: false });
    this._typeahead.getItemValue = function (item) {
      return item.place_name;
    };

    return el;
  },

  _geocode: function _geocode(q, callback) {
    this._loadingEl.classList.add('active');
    this.fire('loading');

    var options = [];
    if (this.options.proximity) options.push('proximity=' + this.options.proximity.join());
    if (this.options.bbox) options.push('bbox=' + this.options.bbox.join());
    if (this.options.country) options.push('country=' + this.options.country);
    if (this.options.types) options.push('types=' + this.options.types);

    var accessToken = this.options.accessToken ? this.options.accessToken : mapboxgl.accessToken;
    options.push('access_token=' + accessToken);

    this.request.abort();
    this.request.open('GET', API + encodeURIComponent(q.trim()) + '.json?' + options.join('&'), true);
    this.request.onload = function () {
      this._loadingEl.classList.remove('active');
      if (this.request.status >= 200 && this.request.status < 400) {
        var data = JSON.parse(this.request.responseText);
        if (data.features.length) {
          this._clearEl.classList.add('active');
        } else {
          this._clearEl.classList.remove('active');
          this._typeahead.selected = null;
        }

        this.fire('results', { results: data.features });
        this._typeahead.update(data.features);
        return callback(data.features);
      } else {
        this.fire('error', { error: JSON.parse(this.request.responseText).message });
      }
    }.bind(this);

    this.request.onerror = function () {
      this._loadingEl.classList.remove('active');
      this.fire('error', { error: JSON.parse(this.request.responseText).message });
    }.bind(this);

    this.request.send();
  },

  _queryFromInput: function _queryFromInput(q) {
    q = q.trim();
    if (!q) this._clear();
    if (q.length > 2) {
      this._geocode(q, function (results) {
        this._results = results;
      }.bind(this));
    }
  },

  _change: function _change() {
    var onChange = document.createEvent('HTMLEvents');
    onChange.initEvent('change', true, false);
    this._inputEl.dispatchEvent(onChange);
  },

  _query: function _query(input) {
    if (!input) return;
    if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && input.length) {
      input = [_utils2.default.wrap(input[0]), _utils2.default.wrap(input[1])].join();
    }

    this._geocode(input, function (results) {
      if (!results.length) return;
      var result = results[0];
      this._results = results;
      this._typeahead.selected = result;
      this._inputEl.value = result.place_name;
      this._change();
    }.bind(this));
  },

  _setInput: function _setInput(input) {
    if (!input) return;
    if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && input.length) {
      input = [_utils2.default.wrap(input[0]), _utils2.default.wrap(input[1])].join();
    }

    // Set input value to passed value and clear everything else.
    this._inputEl.value = input;
    this._input = null;
    this._typeahead.selected = null;
    this._typeahead.clear();
    this._change();
  },

  _clear: function _clear() {
    this._input = null;
    this._inputEl.value = '';
    this._typeahead.selected = null;
    this._typeahead.clear();
    this._change();
    this._inputEl.focus();
    this._clearEl.classList.remove('active');
    this.fire('clear');
  },

  getResult: function getResult() {
    return this._input;
  },

  /**
   * Set & query the input
   * @param {Array|String} query An array of coordinates [lng, lat] or location name as a string.
   * @returns {Geocoder} this
   */
  query: function query(_query2) {
    this._query(_query2);
    return this;
  },

  /**
   * Set input
   * @param {Array|String} value An array of coordinates [lng, lat] or location name as a string. Calling this function just sets the input and does not trigger an API request.
   * @returns {Geocoder} this
   */
  setInput: function setInput(value) {
    this._setInput(value);
    return this;
  },

  /**
   * Subscribe to events that happen within the plugin.
   * @param {String} type name of event. Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string
   * @param {Function} fn function that's called when the event is emitted.
   * @returns {Geocoder} this;
   */
  on: function on(type, fn) {
    this._ev.on(type, fn);
    return this;
  },

  /**
   * Fire an event
   * @param {String} type event name.
   * @param {Object} data event data to pass to the function subscribed.
   * @returns {Geocoder} this
   */
  fire: function fire(type, data) {
    this._ev.emit(type, data);
    return this;
  },

  /**
   * Remove an event
   * @returns {Geocoder} this
   * @param {String} type Event name.
   * @param {Function} fn Function that should unsubscribe to the event emitted.
   */
  off: function off(type, fn) {
    this._ev.removeListener(type, fn);
    return this;
  }
};

module.exports = Geocoder;

},{"../utils":42,"events":1,"lodash.debounce":5,"suggestions":26,"xtend":32}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _geocoder = require('./geocoder');

var _geocoder2 = _interopRequireDefault(_geocoder);

var _lodash = require('lodash.template');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.isequal');

var _lodash4 = _interopRequireDefault(_lodash3);

var _turfExtent = require('turf-extent');

var _turfExtent2 = _interopRequireDefault(_turfExtent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

 // substack/brfs#39
var tmpl = (0, _lodash2.default)("<div class='mapbox-directions-component mapbox-directions-inputs'>\n  <div class='mapbox-directions-component-keyline'>\n    <div class='mapbox-directions-origin'>\n      <label class='mapbox-form-label'>\n        <span class='directions-icon directions-icon-depart' style='background-color:#93AFD7;' ></span>\n      </label>\n      <div id='mapbox-directions-origin-input'></div>\n    </div>\n\n    <button\n      class='directions-icon directions-icon-reverse directions-reverse js-reverse-inputs'\n      title='Reverse origin &amp; destination'>\n    </button>\n\n    <div class='mapbox-directions-destination'>\n      <label class='mapbox-form-label'>\n        <span class='directions-icon directions-icon-arrive' style='background-color:#608BC7;'></span>\n      </label>\n      <div id='mapbox-directions-destination-input'></div>\n    </div>\n  </div>\n\n  <div class='mapbox-directions-profile mapbox-directions-component-keyline mapbox-directions-clearfix'> <input\n      id='mapbox-directions-profile-driving'\n      type='radio'\n      name='profile'\n      <% if (profile === 'driving') { %>checked<% } %>\n    />\n    <label for='mapbox-directions-profile-driving'>Driving</label>\n    <input\n      id='mapbox-directions-profile-walking'\n      type='radio'\n      name='profile'\n      <% if (profile === 'walking') { %>checked<% } %>\n    />\n    <label for='mapbox-directions-profile-walking'>Walking</label>\n    <input\n      id='mapbox-directions-profile-cycling'\n      type='radio'\n      name='profile'\n      <% if (profile === 'cycling') { %>checked<% } %>\n    />\n    <label for='mapbox-directions-profile-cycling'>Cycling</label>\n  </div>\n</div>\n");

/**
 * Inputs controller
 *
 * @param {HTMLElement} el Summary parent container
 * @param {Object} store A redux store
 * @param {Object} actions Actions an element can dispatch
 * @param {Object} map The mapboxgl instance
 * @private
 */

var Inputs = function () {
  function Inputs(el, store, actions, map) {
    _classCallCheck(this, Inputs);

    var _store$getState = store.getState();

    var originQuery = _store$getState.originQuery;
    var destinationQuery = _store$getState.destinationQuery;
    var profile = _store$getState.profile;


    el.innerHTML = tmpl({
      originQuery: originQuery,
      destinationQuery: destinationQuery,
      profile: profile
    });

    this.container = el;
    this.actions = actions;
    this.store = store;
    this._map = map;

    this.onAdd();
    this.render();
  }

  _createClass(Inputs, [{
    key: 'animateToCoordinates',
    value: function animateToCoordinates(mode, coords) {
      var _store$getState2 = this.store.getState();

      var origin = _store$getState2.origin;
      var destination = _store$getState2.destination;


      if (origin.geometry && destination.geometry && !(0, _lodash4.default)(origin.geometry, destination.geometry)) {

        // Animate map to fit bounds.
        var bb = (0, _turfExtent2.default)({
          type: 'FeatureCollection',
          features: [origin, destination]
        });

        this._map.fitBounds([[bb[0], bb[1]], [bb[2], bb[3]]], { padding: 80 });
      } else {
        this._map.flyTo({ center: coords });
      }
    }
  }, {
    key: 'onAdd',
    value: function onAdd() {
      var _this = this;

      var _actions = this.actions;
      var clearOrigin = _actions.clearOrigin;
      var clearDestination = _actions.clearDestination;
      var createOrigin = _actions.createOrigin;
      var createDestination = _actions.createDestination;
      var setProfile = _actions.setProfile;
      var reverse = _actions.reverse;

      var _store$getState3 = this.store.getState();

      var geocoder = _store$getState3.geocoder;
      var accessToken = _store$getState3.accessToken;


      this.originInput = new _geocoder2.default(Object.assign({}, {
        flyTo: false,
        placeholder: 'Startort',
        accessToken: accessToken
      }, geocoder));

      var originEl = this.originInput.onAdd();
      var originContainerEl = this.container.querySelector('#mapbox-directions-origin-input');
      originContainerEl.appendChild(originEl);

      this.destinationInput = new _geocoder2.default(Object.assign({}, {
        flyTo: false,
        placeholder: 'Zielort',
        accessToken: accessToken
      }, geocoder));

      var destinationEl = this.destinationInput.onAdd();
      this.container.querySelector('#mapbox-directions-destination-input').appendChild(destinationEl);

      this.originInput.on('result', function (e) {
        var coords = e.result.center;
        createOrigin(coords);
        _this.animateToCoordinates('origin', coords);
      });

      this.originInput.on('clear', clearOrigin);

      this.destinationInput.on('result', function (e) {
        var coords = e.result.center;
        createDestination(coords);
        _this.animateToCoordinates('destination', coords);
      });

      this.destinationInput.on('clear', clearDestination);

      // Driving / Walking / Cycling profiles
      var profiles = this.container.querySelectorAll('input[type="radio"]');
      Array.prototype.forEach.call(profiles, function (el) {
        el.addEventListener('change', function () {
          setProfile(el.id.replace('mapbox-directions-profile-', ''));
        });
      });

      // Reversing Origin / Destination
      this.container.querySelector('.js-reverse-inputs').addEventListener('click', function () {
        var _store$getState4 = _this.store.getState();

        var origin = _store$getState4.origin;
        var destination = _store$getState4.destination;

        if (origin) _this.actions.queryDestination(origin.geometry.coordinates);
        if (destination) _this.actions.queryOrigin(destination.geometry.coordinates);
        reverse();
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      this.store.subscribe(function () {
        var _store$getState5 = _this2.store.getState();

        var originQuery = _store$getState5.originQuery;
        var destinationQuery = _store$getState5.destinationQuery;
        var originQueryCoordinates = _store$getState5.originQueryCoordinates;
        var destinationQueryCoordinates = _store$getState5.destinationQueryCoordinates;


        if (originQuery) {
          _this2.originInput.query(originQuery);
          _this2.actions.queryOrigin(null);
        }

        if (destinationQuery) {
          _this2.destinationInput.query(destinationQuery);
          _this2.actions.queryDestination(null);
        }

        if (originQueryCoordinates) {
          _this2.originInput.setInput(originQueryCoordinates);
          _this2.animateToCoordinates('origin', originQueryCoordinates);
          _this2.actions.queryOriginCoordinates(null);
        }

        if (destinationQueryCoordinates) {
          _this2.destinationInput.setInput(destinationQueryCoordinates);
          _this2.animateToCoordinates('destination', destinationQueryCoordinates);
          _this2.actions.queryDestinationCoordinates(null);
        }
      });
    }
  }]);

  return Inputs;
}();

exports.default = Inputs;

},{"./geocoder":35,"lodash.isequal":6,"lodash.template":7,"turf-extent":30}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

var _lodash = require('lodash.template');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.isequal');

var _lodash4 = _interopRequireDefault(_lodash3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

 // substack/brfs#39
var instructionsTemplate = (0, _lodash2.default)("<div class='directions-control directions-control-directions'>\n  <div class='mapbox-directions-component mapbox-directions-route-summary<% if (routes > 1) { %> mapbox-directions-multiple<% } %>'>\n    <% if (routes > 1) { %>\n    <div class='mapbox-directions-routes mapbox-directions-clearfix'>\n      <% for (var i = 0; i < routes; i++) { %>\n        <input type='radio' name='routes' id='<%= i %>' <% if (i === routeIndex) { %>checked<% } %>>\n        <label for='<%= i %>' class='mapbox-directions-route'><%= i + 1 %></label>\n      <% } %>\n    </div>\n    <% } %>\n    <h1><%- duration %></h1>\n    <span><%- distance %></span>\n  </div>\n\n  <div class='mapbox-directions-instructions'>\n    <div class='mapbox-directions-instructions-wrapper'>\n      <ol class='mapbox-directions-steps'>\n        <% steps.forEach(function(step) { %>\n          <%\n            var distance = step.distance ? format(step.distance) : false;\n            var icon = step.maneuver.modifier ? step.maneuver.modifier.replace(/\\s+/g, '-').toLowerCase() : step.maneuver.type.replace(/\\s+/g, '-').toLowerCase();\n\n            if (step.maneuver.type === 'arrive' || step.maneuver.type === 'depart') {\n              icon = step.maneuver.type;\n            }\n\n            if (step.maneuver.type === 'roundabout' || step.maneuver.type === 'rotary') {\n              icon= 'roundabout';\n            }\n\n            var lng = step.maneuver.location[0];\n            var lat = step.maneuver.location[1];\n          %>\n          <li\n            data-lat='<%= lat %>'\n            data-lng='<%= lng %>'\n            class='mapbox-directions-step'>\n            <span class='directions-icon directions-icon-<%= icon %>'></span>\n            <div class='mapbox-directions-step-maneuver'>\n              <%= step.maneuver.instruction %>\n            </div>\n            <% if (distance) { %>\n              <div class='mapbox-directions-step-distance'>\n                <%= distance %>\n              </div>\n            <% } %>\n          </li>\n        <% }); %>\n      </ol>\n    </div>\n  </div>\n</div>\n");
var errorTemplate = (0, _lodash2.default)("<div class='directions-control directions-control-directions'>\n  <div class='mapbox-directions-error'>\n    <%= error %>\n  </div>\n</div>\n");


/**
 * Summary/Instructions controller
 *
 * @param {HTMLElement} el Summary parent container
 * @param {Object} store A redux store
 * @param {Object} actions Actions an element can dispatch
 * @param {Object} map The mapboxgl instance
 * @private
 */

var Instructions = function () {
  function Instructions(el, store, actions, map) {
    _classCallCheck(this, Instructions);

    this.container = el;
    this.actions = actions;
    this.store = store;
    this._map = map;
    this.directions = {};
    this.render();
  }

  _createClass(Instructions, [{
    key: 'render',
    value: function render() {
      var _this = this;

      this.store.subscribe(function () {
        var _actions = _this.actions;
        var hoverMarker = _actions.hoverMarker;
        var setRouteIndex = _actions.setRouteIndex;

        var _store$getState = _this.store.getState();

        var routeIndex = _store$getState.routeIndex;
        var unit = _store$getState.unit;
        var directions = _store$getState.directions;
        var error = _store$getState.error;

        var shouldRender = !(0, _lodash4.default)(directions[routeIndex], _this.directions);

        if (error) {
          _this.container.innerHTML = errorTemplate({ error: error });
          return;
        }

        if (directions.length && shouldRender) {
          var direction = _this.directions = directions[routeIndex];
          _this.container.innerHTML = instructionsTemplate({
            routeIndex: routeIndex,
            routes: directions.length,
            steps: direction.legs[0].steps, // Todo: Respect all legs,
            format: _utils2.default.format[unit],
            duration: _utils2.default.format[unit](direction.distance),
            distance: _utils2.default.format.duration(direction.duration)
          });

          var steps = _this.container.querySelectorAll('.mapbox-directions-step');

          Array.prototype.forEach.call(steps, function (el) {
            var lng = el.getAttribute('data-lng');
            var lat = el.getAttribute('data-lat');

            el.addEventListener('mouseover', function () {
              hoverMarker([lng, lat]);
            });

            el.addEventListener('mouseout', function () {
              hoverMarker(null);
            });

            el.addEventListener('click', function () {
              _this._map.flyTo({
                center: [lng, lat],
                zoom: 16
              });
            });
          });

          var routes = _this.container.querySelectorAll('input[type="radio"]');
          Array.prototype.forEach.call(routes, function (el) {
            el.addEventListener('change', function (e) {
              setRouteIndex(parseInt(e.target.id, 10));
            });
          });
        } else if (_this.container.innerHTML && shouldRender) {
          _this.container.innerHTML = '';
        }
      });
    }
  }]);

  return Instructions;
}();

exports.default = Instructions;

},{"../utils":42,"lodash.isequal":6,"lodash.template":7}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _redux = require('redux');

var _reduxThunk = require('redux-thunk');

var _reduxThunk2 = _interopRequireDefault(_reduxThunk);

var _polyline = require('polyline');

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var _reducers = require('./reducers');

var _reducers2 = _interopRequireDefault(_reducers);

var _actions = require('./actions');

var actions = _interopRequireWildcard(_actions);

var _directions_style = require('./directions_style');

var _directions_style2 = _interopRequireDefault(_directions_style);

var _inputs = require('./controls/inputs');

var _inputs2 = _interopRequireDefault(_inputs);

var _instructions = require('./controls/instructions');

var _instructions2 = _interopRequireDefault(_instructions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var storeWithMiddleware = (0, _redux.applyMiddleware)(_reduxThunk2.default)(_redux.createStore);
var store = storeWithMiddleware(_reducers2.default);

// State object management via redux


// Controls

/**
 * The Directions control
 * @class MapboxDirections
 *
 * @param {Object} options
 * @param {Array} [options.styles] Override default layer properties of the [directions source](https://github.com/mapbox/mapbox-gl-directions/blob/master/src/directions_style.js). Documentation for each property are specified in the [Mapbox GL Style Reference](https://www.mapbox.com/mapbox-gl-style-spec/).
 * @param {String} [options.accessToken=null] Required unless `mapboxgl.accessToken` is set globally
 * @param {Boolean} [options.interactive=true] Enable/Disable mouse or touch interactivity from the plugin
 * @param {String} [options.profile="driving-traffic"] Routing profile to use. Options: `driving-traffic`, `driving`, `walking`, `cycling`
 * @param {String} [options.unit="imperial"] Measurement system to be used in navigation instructions. Options: `imperial`, `metric`
 * @param {Object} [options.geocoder] Pass options available to mapbox-gl-geocoder as [documented here](https://github.com/mapbox/mapbox-gl-geocoder/blob/master/API.md#mapboxglgeocoder).
 * @param {Object} [options.controls]
 * @param {Boolean} [options.controls.inputs=true] Hide or display the inputs control.
 * @param {Boolean} [options.controls.instructions=true] Hide or display the instructions control.
 * @example
 * var MapboxDirections = require('../src/index');
 * var directions = new MapboxDirections({
 *   accessToken: 'YOUR-MAPBOX-ACCESS-TOKEN',
 *   unit: 'metric',
 *   profile: 'cycling'
 * });
 * // add to your mapboxgl map
 * map.addControl(directions);
 *
 * @return {MapboxDirections} `this`
 */
var MapboxDirections = function () {
  function MapboxDirections(options) {
    _classCallCheck(this, MapboxDirections);

    this.actions = (0, _redux.bindActionCreators)(actions, store.dispatch);
    this.actions.setOptions(options || {});
    this.options = options || {};

    this.onDragDown = this._onDragDown.bind(this);
    this.onDragMove = this._onDragMove.bind(this);
    this.onDragUp = this._onDragUp.bind(this);
    this.move = this._move.bind(this);
    this.onClick = this._onClick.bind(this);
  }

  _createClass(MapboxDirections, [{
    key: 'onAdd',
    value: function onAdd(map) {
      var _this = this;

      this._map = map;

      var _store$getState = store.getState();

      var controls = _store$getState.controls;


      var el = this.container = document.createElement('div');
      el.className = 'mapboxgl-ctrl-directions mapboxgl-ctrl';

      // Add controls to the page
      var inputEl = document.createElement('div');
      inputEl.className = 'directions-control directions-control-inputs';
      new _inputs2.default(inputEl, store, this.actions, this._map);

      var directionsEl = document.createElement('div');
      directionsEl.className = 'directions-control directions-control-instructions';

      new _instructions2.default(directionsEl, store, {
        hoverMarker: this.actions.hoverMarker,
        setRouteIndex: this.actions.setRouteIndex
      }, this._map);

      if (controls.inputs) el.appendChild(inputEl);
      if (controls.instructions) el.appendChild(directionsEl);

      this.subscribedActions();
      if (this._map.loaded()) this.mapState();else this._map.on('load', function () {
        return _this.mapState();
      });

      return el;
    }

    /**
     * Removes the control from the map it has been added to. This is called by `map.removeControl`,
     * which is the recommended method to remove controls.
     *
     * @returns {Control} `this`
     */

  }, {
    key: 'onRemove',
    value: function onRemove(map) {
      this.container.parentNode.removeChild(this.container);
      this.removeRoutes();
      map.off('mousedown', this.onDragDown);
      map.off('mousemove', this.move);
      map.off('touchstart', this.onDragDown);
      map.off('touchstart', this.move);
      map.off('click', this.onClick);
      if (this.storeUnsubscribe) {
        this.storeUnsubscribe();
        delete this.storeUnsubscribe;
      }
      this._map = null;
      return this;
    }
  }, {
    key: 'mapState',
    value: function mapState() {
      var _this2 = this;

      var _store$getState2 = store.getState();

      var profile = _store$getState2.profile;
      var styles = _store$getState2.styles;
      var interactive = _store$getState2.interactive;

      // Emit any default or option set config

      this.actions.eventEmit('profile', { profile: profile });

      var geojson = {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: []
        }
      };

      // Add and set data theme layer/style
      this._map.addSource('directions', geojson);

      // Add direction specific styles to the map
      _directions_style2.default.forEach(function (style) {
        return _this2._map.addLayer(style);
      });

      if (styles && styles.length) styles.forEach(function (style) {
        return _this2._map.addLayer(style);
      });

      if (interactive) {
        this._map.on('mousedown', this.onDragDown);
        this._map.on('mousemove', this.move);
        this._map.on('click', this.onClick);

        this._map.on('touchstart', this.move);
        this._map.on('touchstart', this.onDragDown);
      }
    }
  }, {
    key: 'subscribedActions',
    value: function subscribedActions() {
      var _this3 = this;

      this.storeUnsubscribe = store.subscribe(function () {
        var _store$getState3 = store.getState();

        var origin = _store$getState3.origin;
        var destination = _store$getState3.destination;
        var hoverMarker = _store$getState3.hoverMarker;
        var directions = _store$getState3.directions;
        var routeIndex = _store$getState3.routeIndex;


        var geojson = {
          type: 'FeatureCollection',
          features: [origin, destination, hoverMarker].filter(function (d) {
            return d.geometry;
          })
        };

        if (directions.length) {
          directions.forEach(function (feature, index) {

            var lineString = {
              geometry: {
                type: 'LineString',
                coordinates: (0, _polyline.decode)(feature.geometry, 5).map(function (c) {
                  return c.reverse();
                })
              },
              properties: {
                'route-index': index,
                route: index === routeIndex ? 'selected' : 'alternate'
              }
            };

            geojson.features.push(lineString);
            if (index === routeIndex) {
              // Collect any possible waypoints from steps
              feature.legs[0].steps.forEach(function (d) {
                if (d.maneuver.type === 'waypoint') {
                  geojson.features.push({
                    type: 'Feature',
                    geometry: d.maneuver.location,
                    properties: {
                      id: 'waypoint'
                    }
                  });
                }
              });
            }
          });
        }

        if (_this3._map.style && _this3._map.getSource('directions')) {
          _this3._map.getSource('directions').setData(geojson);
        }
      });
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      var _this4 = this;

      var _store$getState4 = store.getState();

      var origin = _store$getState4.origin;

      var coords = [e.lngLat.lng, e.lngLat.lat];

      if (!origin.geometry) {
        this.actions.setOriginFromCoordinates(coords);
      } else {

        var features = this._map.queryRenderedFeatures(e.point, {
          layers: ['directions-origin-point', 'directions-destination-point', 'directions-waypoint-point', 'directions-route-line-alt']
        });

        if (features.length) {

          // Remove any waypoints
          features.forEach(function (f) {
            if (f.layer.id === 'directions-waypoint-point') {
              _this4.actions.removeWaypoint(f);
            }
          });

          if (features[0].properties.route === 'alternate') {
            var index = features[0].properties['route-index'];
            this.actions.setRouteIndex(index);
          }
        } else {
          this.actions.setDestinationFromCoordinates(coords);
          this._map.flyTo({ center: coords });
        }
      }
    }
  }, {
    key: '_move',
    value: function _move(e) {
      var _this5 = this;

      var _store$getState5 = store.getState();

      var hoverMarker = _store$getState5.hoverMarker;


      var features = this._map.queryRenderedFeatures(e.point, {
        layers: ['directions-route-line-alt', 'directions-route-line', 'directions-origin-point', 'directions-destination-point', 'directions-hover-point']
      });

      this._map.getCanvas().style.cursor = features.length ? 'pointer' : '';

      if (features.length) {
        this.isCursorOverPoint = features[0];
        this._map.dragPan.disable();

        // Add a possible waypoint marker when hovering over the active route line
        features.forEach(function (feature) {
          if (feature.layer.id === 'directions-route-line') {
            _this5.actions.hoverMarker([e.lngLat.lng, e.lngLat.lat]);
          } else if (hoverMarker.geometry) {
            _this5.actions.hoverMarker(null);
          }
        });
      } else if (this.isCursorOverPoint) {
        this.isCursorOverPoint = false;
        this._map.dragPan.enable();
      }
    }
  }, {
    key: '_onDragDown',
    value: function _onDragDown() {
      if (!this.isCursorOverPoint) return;
      this.isDragging = this.isCursorOverPoint;
      this._map.getCanvas().style.cursor = 'grab';

      this._map.on('mousemove', this.onDragMove);
      this._map.on('mouseup', this.onDragUp);

      this._map.on('touchmove', this.onDragMove);
      this._map.on('touchend', this.onDragUp);
    }
  }, {
    key: '_onDragMove',
    value: function _onDragMove(e) {
      if (!this.isDragging) return;

      var coords = [e.lngLat.lng, e.lngLat.lat];
      switch (this.isDragging.layer.id) {
        case 'directions-origin-point':
          this.actions.createOrigin(coords);
          break;
        case 'directions-destination-point':
          this.actions.createDestination(coords);
          break;
        case 'directions-hover-point':
          this.actions.hoverMarker(coords);
          break;
      }
    }
  }, {
    key: '_onDragUp',
    value: function _onDragUp() {
      if (!this.isDragging) return;

      var _store$getState6 = store.getState();

      var hoverMarker = _store$getState6.hoverMarker;
      var origin = _store$getState6.origin;
      var destination = _store$getState6.destination;


      switch (this.isDragging.layer.id) {
        case 'directions-origin-point':
          this.actions.setOriginFromCoordinates(origin.geometry.coordinates);
          break;
        case 'directions-destination-point':
          this.actions.setDestinationFromCoordinates(destination.geometry.coordinates);
          break;
        case 'directions-hover-point':
          // Add waypoint if a sufficent amount of dragging has occurred.
          if (hoverMarker.geometry && !_utils2.default.coordinateMatch(this.isDragging, hoverMarker)) {
            this.actions.addWaypoint(0, hoverMarker);
          }
          break;
      }

      this.isDragging = false;
      this._map.getCanvas().style.cursor = '';

      this._map.off('touchmove', this.onDragMove);
      this._map.off('touchend', this.onDragUp);

      this._map.off('mousemove', this.onDragMove);
      this._map.off('mouseup', this.onDragUp);
    }

    // API Methods
    // ============================

    /**
     * Turn on or off interactivity
     * @param {Boolean} state sets interactivity based on a state of `true` or `false`.
     * @returns {MapboxDirections} this
     */

  }, {
    key: 'interactive',
    value: function interactive(state) {
      if (state) {
        this._map.on('touchstart', this.move);
        this._map.on('touchstart', this.onDragDown);

        this._map.on('mousedown', this.onDragDown);
        this._map.on('mousemove', this.move);
        this._map.on('click', this.onClick);
      } else {
        this._map.off('touchstart', this.move);
        this._map.off('touchstart', this.onDragDown);

        this._map.off('mousedown', this.onDragDown);
        this._map.off('mousemove', this.move);
        this._map.off('click', this.onClick);
      }

      return this;
    }

    /**
     * Returns the origin of the current route.
     * @returns {Object} origin
     */

  }, {
    key: 'getOrigin',
    value: function getOrigin() {
      return store.getState().origin;
    }

    /**
     * Sets origin. _Note:_ calling this method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)
     * to have run.
     * @param {Array<number>|String} query An array of coordinates [lng, lat] or location name as a string.
     * @returns {MapboxDirections} this
     */

  }, {
    key: 'setOrigin',
    value: function setOrigin(query) {
      if (typeof query === 'string') {
        this.actions.queryOrigin(query);
      } else {
        this.actions.setOriginFromCoordinates(query);
      }

      return this;
    }

    /**
     * Returns the destination of the current route.
     * @returns {Object} destination
     */

  }, {
    key: 'getDestination',
    value: function getDestination() {
      return store.getState().destination;
    }

    /**
     * Sets destination. _Note:_ calling this method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)
     * to have run.
     * @param {Array<number>|String} query An array of coordinates [lng, lat] or location name as a string.
     * @returns {MapboxDirections} this
     */

  }, {
    key: 'setDestination',
    value: function setDestination(query) {
      if (typeof query === 'string') {
        this.actions.queryDestination(query);
      } else {
        this.actions.setDestinationFromCoordinates(query);
      }

      return this;
    }

    /**
     * Swap the origin and destination.
     * @returns {MapboxDirections} this
     */

  }, {
    key: 'reverse',
    value: function reverse() {
      this.actions.reverse();
      return this;
    }

    /**
     * Add a waypoint to the route. _Note:_ calling this method requires the
     * [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load) to have run.
     * @param {Number} index position waypoint should be placed in the waypoint array
     * @param {Array<number>|Point} waypoint can be a GeoJSON Point Feature or [lng, lat] coordinates.
     * @returns {MapboxDirections} this;
     */

  }, {
    key: 'addWaypoint',
    value: function addWaypoint(index, waypoint) {
      if (!waypoint.type) waypoint = _utils2.default.createPoint(waypoint, { id: 'waypoint' });
      this.actions.addWaypoint(index, waypoint);
      return this;
    }

    /**
     * Change the waypoint at a given index in the route. _Note:_ calling this
     * method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)
     * to have run.
     * @param {Number} index indexed position of the waypoint to update
     * @param {Array<number>|Point} waypoint can be a GeoJSON Point Feature or [lng, lat] coordinates.
     * @returns {MapboxDirections} this;
     */

  }, {
    key: 'setWaypoint',
    value: function setWaypoint(index, waypoint) {
      if (!waypoint.type) waypoint = _utils2.default.createPoint(waypoint, { id: 'waypoint' });
      this.actions.setWaypoint(index, waypoint);
      return this;
    }

    /**
     * Remove a waypoint from the route.
     * @param {Number} index position in the waypoints array.
     * @returns {MapboxDirections} this;
     */

  }, {
    key: 'removeWaypoint',
    value: function removeWaypoint(index) {
      var _store$getState7 = store.getState();

      var waypoints = _store$getState7.waypoints;

      this.actions.removeWaypoint(waypoints[index]);
      return this;
    }

    /**
     * Fetch all current waypoints in a route.
     * @returns {Array} waypoints
     */

  },{
    key: 'getDistanceAndDuration',
    value: function getDistanceAndDuration() {
      var _store$getState8 = store.getState();
      if(_store$getState8 === null){
          return null;
      }

      var directions = _store$getState8.directions;
      var routeIndex = _store$getState8.routeIndex;
      var unit = _store$getState8.unit;

      if(directions[routeIndex] === null){
        return null;
      }


      var duration = _utils2.default.format.duration(directions[routeIndex].duration);
      var distance = _utils2.default.format[unit](directions[routeIndex].distance);

      return {duration, distance};
    }

    /**
     * Removes all routes and waypoints from the map.
     *
     * @returns {MapboxDirections} this;
     */

  }, {
    key: 'getWaypoints',
    value: function getWaypoints() {
      return store.getState().waypoints;
    }

    /**
     * Removes all routes and waypoints from the map.
     *
     * @returns {MapboxDirections} this;
     */

  }, {
    key: 'removeRoutes',
    value: function removeRoutes() {
      this.actions.clearOrigin();
      this.actions.clearDestination();
      return this;
    }

    /**
     * Subscribe to events that happen within the plugin.
     * @param {String} type name of event. Available events and the data passed into their respective event objects are:
     *
     * - __clear__ `{ type: } Type is one of 'origin' or 'destination'`
     * - __loading__ `{ type: } Type is one of 'origin' or 'destination'`
     * - __profile__ `{ profile } Profile is one of 'driving', 'walking', or 'cycling'`
     * - __origin__ `{ feature } Fired when origin is set`
     * - __destination__ `{ feature } Fired when destination is set`
     * - __route__ `{ route } Fired when a route is updated`
     * - __error__ `{ error } Error as string
     * @param {Function} fn function that's called when the event is emitted.
     * @returns {MapboxDirections} this;
     */

  }, {
    key: 'on',
    value: function on(type, fn) {
      this.actions.eventSubscribe(type, fn);
      return this;
    }
  }]);

  return MapboxDirections;
}();

exports.default = MapboxDirections;

},{"./actions":33,"./controls/inputs":36,"./controls/instructions":37,"./directions_style":39,"./reducers":41,"./utils":42,"polyline":10,"redux":17,"redux-thunk":11}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var style = [{
  'id': 'directions-route-line-alt',
  'type': 'line',
  'source': 'directions',
  'layout': {
    'line-cap': 'round',
    'line-join': 'round'
  },
  'paint': {
    'line-color': '#bbb',
    'line-width': 4
  },
  'filter': ['all', ['in', '$type', 'LineString'], ['in', 'route', 'alternate']]
}, {
  'id': 'directions-route-line',
  'type': 'line',
  'source': 'directions',
  'layout': {
    'line-cap': 'round',
    'line-join': 'round'
  },
  'paint': {
    'line-color': '#608BC7',
    'line-width': 4
  },
  'filter': ['all', ['in', '$type', 'LineString'], ['in', 'route', 'selected']]
}, {
  'id': 'directions-hover-point-casing',
  'type': 'circle',
  'source': 'directions',
  'paint': {
    'circle-radius': 8,
    'circle-color': '#fff'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'id', 'hover']]
}, {
  'id': 'directions-hover-point',
  'type': 'circle',
  'source': 'directions',
  'paint': {
    'circle-radius': 6,
    'circle-color': '#3bb2d0'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'id', 'hover']]
}, {
  'id': 'directions-waypoint-point-casing',
  'type': 'circle',
  'source': 'directions',
  'paint': {
    'circle-radius': 8,
    'circle-color': '#fff'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'id', 'waypoint']]
}, {
  'id': 'directions-waypoint-point',
  'type': 'circle',
  'source': 'directions',
  'paint': {
    'circle-radius': 6,
    'circle-color': '#608BC7'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'id', 'waypoint']]
}, {
  'id': 'directions-origin-point',
  'type': 'circle',
  'source': 'directions',
  'paint': {
    'circle-radius': 18,
    'circle-color': '#93AFD7'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'marker-symbol', 'A']]
}, {
  'id': 'directions-origin-label',
  'type': 'symbol',
  'source': 'directions',
  'layout': {
    'text-field': 'A',
    'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
    'text-size': 12
  },
  'paint': {
    'text-color': '#fff'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'marker-symbol', 'A']]
}, {
  'id': 'directions-destination-point',
  'type': 'circle',
  'source': 'directions',
  'paint': {
    'circle-radius': 18,
    'circle-color': '#608BC7'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'marker-symbol', 'B']]
}, {
  'id': 'directions-destination-label',
  'type': 'symbol',
  'source': 'directions',
  'layout': {
    'text-field': 'B',
    'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
    'text-size': 12
  },
  'paint': {
    'text-color': '#fff'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'marker-symbol', 'B']]
}];

exports.default = style;

},{}],40:[function(require,module,exports){
'use strict';

var _directions = require('./directions');

var _directions2 = _interopRequireDefault(_directions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = _directions2.default;

},{"./directions":38}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _action_types = require('../constants/action_types.js');

var types = _interopRequireWildcard(_action_types);

var _deepAssign = require('deep-assign');

var _deepAssign2 = _interopRequireDefault(_deepAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var initialState = {
  // Options set on initialization
  api: 'https://api.mapbox.com/directions/v5/',
  profile: 'driving-traffic',
  unit: 'imperial',
  proximity: false,
  styles: [],

  // UI controls
  controls: {
    inputs: true,
    instructions: true
  },

  // Optional setting to pass options available to mapbox-gl-geocoder
  geocoder: {},

  interactive: true,

  // Container for client registered events
  events: {},

  // Marker feature drawn on the map at any point.
  origin: {},
  destination: {},
  hoverMarker: {},
  waypoints: [],

  // User input strings or result returned from geocoder
  originQuery: null,
  destinationQuery: null,
  originQueryCoordinates: null,
  destinationQueryCoordinates: null,

  // Directions data
  directions: [],
  routeIndex: 0
};

function data() {
  var state = arguments.length <= 0 || arguments[0] === undefined ? initialState : arguments[0];
  var action = arguments[1];

  switch (action.type) {
    case types.SET_OPTIONS:
      return (0, _deepAssign2.default)({}, state, action.options);

    case types.DIRECTIONS_PROFILE:
      return Object.assign({}, state, {
        profile: action.profile
      });

    case types.ORIGIN:
      return Object.assign({}, state, {
        origin: action.origin,
        hoverMarker: {}
      });

    case types.DESTINATION:
      return Object.assign({}, state, {
        destination: action.destination,
        hoverMarker: {}
      });

    case types.HOVER_MARKER:
      return Object.assign({}, state, {
        hoverMarker: action.hoverMarker
      });

    case types.WAYPOINTS:
      return Object.assign({}, state, {
        waypoints: action.waypoints
      });

    case types.ORIGIN_QUERY:
      return Object.assign({}, state, {
        originQuery: action.query
      });

    case types.DESTINATION_QUERY:
      return Object.assign({}, state, {
        destinationQuery: action.query
      });

    case types.ORIGIN_FROM_COORDINATES:
      return Object.assign({}, state, {
        originQueryCoordinates: action.coordinates
      });

    case types.DESTINATION_FROM_COORDINATES:
      return Object.assign({}, state, {
        destinationQueryCoordinates: action.coordinates
      });

    case types.ORIGIN_CLEAR:
      return Object.assign({}, state, {
        origin: {},
        originQuery: '',
        waypoints: [],
        directions: []
      });

    case types.DESTINATION_CLEAR:
      return Object.assign({}, state, {
        destination: {},
        destinationQuery: '',
        waypoints: [],
        directions: []
      });

    case types.DIRECTIONS:
      return Object.assign({}, state, {
        directions: action.directions
      });

    case types.ROUTE_INDEX:
      return Object.assign({}, state, {
        routeIndex: action.routeIndex
      });

    case types.ERROR:
      return Object.assign({}, state, {
        error: action.error
      });

    default:
      return state;
  }
}

exports.default = data;

},{"../constants/action_types.js":34,"deep-assign":3}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
function validCoords(coords) {
  return coords[0] >= -180 && coords[0] <= 180 && coords[1] >= -90 && coords[1] <= 90;
}

function coordinateMatch(a, b) {
  a = a.geometry.coordinates;
  b = b.geometry.coordinates;
  return a.join() === b.join() || a[0].toFixed(3) === b[0].toFixed(3) && a[1].toFixed(3) === b[1].toFixed(3);
}

function wrap(n) {
  var d = 180 - -180;
  var w = ((n - -180) % d + d) % d + -180;
  return w === -180 ? 180 : w;
}

function createPoint(coordinates, properties) {
  return {
    type: 'Feature',
    geometry: {
      type: 'Point',
      coordinates: coordinates
    },
    properties: properties ? properties : {}
  };
}

var format = {
  duration: function duration(s) {
    var m = Math.floor(s / 60),
        h = Math.floor(m / 60);
    s %= 60;
    m %= 60;
    if (h === 0 && m === 0) return s + 's';
    if (h === 0) return m + 'min';
    return h + 'h ' + m + 'min';
  },
  imperial: function imperial(m) {
    var mi = m / 1609.344;
    if (mi >= 100) return mi.toFixed(0) + 'mi';
    if (mi >= 10) return mi.toFixed(1) + 'mi';
    if (mi >= 0.1) return mi.toFixed(2) + 'mi';
    return (mi * 5280).toFixed(0) + 'ft';
  },
  metric: function metric(m) {
    if (m >= 100000) return (m / 1000).toFixed(0) + 'km';
    if (m >= 10000) return (m / 1000).toFixed(1) + 'km';
    if (m >= 100) return (m / 1000).toFixed(2) + 'km';
    return m.toFixed(0) + 'm';
  }
};

exports.default = { format: format, coordinateMatch: coordinateMatch, createPoint: createPoint, validCoords: validCoords, wrap: wrap };

},{}]},{},[40])(40)
});

!function(t,e,r){"use strict";var s={calc:!1};e.fn.rrssb=function(t){var s=e.extend({description:r,emailAddress:r,emailBody:r,emailSubject:r,image:r,title:r,url:r},t);for(var a in s.emailSubject=s.emailSubject||s.title,s.emailBody=s.emailBody||(s.description?s.description:"")+(s.url?"\n\n"+s.url:""),s)s.hasOwnProperty(a)&&s[a]!==r&&(s[a]=i(s[a]));s.url!==r&&(e(this).find(".rrssb-facebook a").attr("href","https://www.facebook.com/sharer/sharer.php?u="+s.url),e(this).find(".rrssb-tumblr a").attr("href","http://tumblr.com/share/link?url="+s.url+(s.title!==r?"&name="+s.title:"")+(s.description!==r?"&description="+s.description:"")),e(this).find(".rrssb-linkedin a").attr("href","http://www.linkedin.com/shareArticle?mini=true&url="+s.url+(s.title!==r?"&title="+s.title:"")+(s.description!==r?"&summary="+s.description:"")),e(this).find(".rrssb-twitter a").attr("href","https://twitter.com/intent/tweet?text="+(s.description!==r?s.description:"")+"%20"+s.url),e(this).find(".rrssb-hackernews a").attr("href","https://news.ycombinator.com/submitlink?u="+s.url+(s.title!==r?"&text="+s.title:"")),e(this).find(".rrssb-vk a").attr("href","https://vk.com/share.php?url="+s.url),e(this).find(".rrssb-reddit a").attr("href","http://www.reddit.com/submit?url="+s.url+(s.description!==r?"&text="+s.description:"")+(s.title!==r?"&title="+s.title:"")),e(this).find(".rrssb-googleplus a").attr("href","https://plus.google.com/share?url="+s.url),e(this).find(".rrssb-pinterest a").attr("href","http://pinterest.com/pin/create/button/?url="+s.url+(s.image!==r?"&amp;media="+s.image:"")+(s.description!==r?"&description="+s.description:"")),e(this).find(".rrssb-pocket a").attr("href","https://getpocket.com/save?url="+s.url),e(this).find(".rrssb-github a").attr("href",s.url),e(this).find(".rrssb-print a").attr("href","javascript:window.print()"),e(this).find(".rrssb-whatsapp a").attr("href","whatsapp://send?text="+(s.description!==r?s.description+"%20":s.title!==r?s.title+"%20":"")+s.url)),(s.emailAddress!==r||s.emailSubject)&&e(this).find(".rrssb-email a").attr("href","mailto:"+(s.emailAddress?s.emailAddress:"")+"?"+(s.emailSubject!==r?"subject="+s.emailSubject:"")+(s.emailBody!==r?"&body="+s.emailBody:""))};var i=function(t){if(t!==r&&null!==t){if(null===t.match(/%[0-9a-f]{2}/i))return encodeURIComponent(t);t=decodeURIComponent(t),i(t)}},a=function(){e(".rrssb-buttons").each(function(t){var r=e(this),s=e("li:visible",r),i=100/s.length;s.css("width",i+"%").attr("data-initwidth",i)})},n=function(t){e(".rrssb-buttons").each(function(t){var r=e(this),s=e("li",r);e(s.get().reverse()).each(function(t,r){var i=e(this);if(!1===i.hasClass("small")&&parseFloat(i.attr("data-size"))+55>parseFloat(i.width())){var a=s.not(".small").last();e(a).addClass("small"),l()}--r||e(".rrssb-buttons").each(function(t){var r=e(this),s=e("li",r),i=s.filter(".small"),a=0,n=0,o=i.eq(0),c=parseFloat(o.attr("data-size"))+55,h=i.length;h===s.length?42*h+c<r.width()&&(r.removeClass("small-format"),i.eq(0).removeClass("small"),l()):(s.not(".small").each(function(t){var r=e(this),s=parseFloat(r.attr("data-size"))+55,i=parseFloat(r.width());a+=i,n+=s}),c<a-n&&(o.removeClass("small"),l()))})})}),!0===t&&c(l)},l=function(){e(".rrssb-buttons").each(function(t){var r,i,n,l,o,c=e(this),h=e("li",c),d=h.filter(".small"),u=d.length;u>0&&u!==h.length?(c.removeClass("small-format"),d.css("width","42px"),n=42*u,i=100/(r=h.not(".small").length),o=n/r,!1===s.calc?(l=(c.innerWidth()-1)/r-o,l=Math.floor(1e3*l)/1e3,l+="px"):l=s.calc+"("+i+"% - "+o+"px)",h.not(".small").css("width",l)):u===h.length?(c.addClass("small-format"),a()):(c.removeClass("small-format"),a())}),e(".rrssb-buttons").each(function(t){var r=e(this),s=r.width(),i=e("li",r).not(".small").eq(0).width(),a=e("li.small",r).length;if(i>170&&a<1){r.addClass("large-format");var n=i/12+"px";r.css("font-size",n)}else r.removeClass("large-format"),r.css("font-size","");s<25*a?r.removeClass("small-format").addClass("tiny-format"):r.removeClass("tiny-format")})},o=function(){e(".rrssb-buttons").each(function(t){e(this).addClass("rrssb-"+(t+1))}),function(){var t=e("<div>"),r=["calc","-webkit-calc","-moz-calc"];e("body").append(t);for(var i=0;i<r.length;i++)if(t.css("width",r[i]+"(1px)"),1===t.width()){s.calc=r[i];break}t.remove()}(),a(),e(".rrssb-buttons li .rrssb-text").each(function(t){var r=e(this),s=r.width();r.closest("li").attr("data-size",s)}),n(!0)},c=function(t){e(".rrssb-buttons li.small").removeClass("small"),n(),t()},h=function(e,s,i,a){var n=t.screenLeft!==r?t.screenLeft:screen.left,l=t.screenTop!==r?t.screenTop:screen.top,o=(t.innerWidth?t.innerWidth:document.documentElement.clientWidth?document.documentElement.clientWidth:screen.width)/2-i/2+n,c=(t.innerHeight?t.innerHeight:document.documentElement.clientHeight?document.documentElement.clientHeight:screen.height)/3-a/3+l,h=t.open(e,s,"scrollbars=yes, width="+i+", height="+a+", top="+c+", left="+o);h&&h.focus&&h.focus()},d=function(){var t={};return function(e,r,s){s||(s="Don't call this twice without a uniqueId"),t[s]&&clearTimeout(t[s]),t[s]=setTimeout(e,r)}}();e(document).ready(function(){try{e(document).on("click",".rrssb-buttons a.popup",{},function(t){var r=e(this);h(r.attr("href"),r.find(".rrssb-text").html(),580,470),t.preventDefault()})}catch(t){}e(t).resize(function(){c(l),d(function(){c(l)},200,"finished resizing")}),o()}),t.rrssbInit=o}(window,jQuery);
+function(t,e,r){"use strict";var i={calc:!1};e.fn.rrssb=function(t){var i=e.extend({description:r,emailAddress:r,emailBody:r,emailSubject:r,image:r,title:r,url:r},t);i.emailSubject=i.emailSubject||i.title,i.emailBody=i.emailBody||(i.description?i.description:"")+(i.url?"\n\n"+i.url:"");for(var s in i)i.hasOwnProperty(s)&&i[s]!==r&&(i[s]=a(i[s]));i.url!==r&&(e(this).find(".rrssb-facebook a").attr("href","https://www.facebook.com/sharer/sharer.php?u="+i.url),e(this).find(".rrssb-tumblr a").attr("href","http://tumblr.com/share/link?url="+i.url+(i.title!==r?"&name="+i.title:"")+(i.description!==r?"&description="+i.description:"")),e(this).find(".rrssb-linkedin a").attr("href","http://www.linkedin.com/shareArticle?mini=true&url="+i.url+(i.title!==r?"&title="+i.title:"")+(i.description!==r?"&summary="+i.description:"")),e(this).find(".rrssb-twitter a").attr("href","https://twitter.com/intent/tweet?text="+(i.description!==r?i.description:"")+"%20"+i.url),e(this).find(".rrssb-hackernews a").attr("href","https://news.ycombinator.com/submitlink?u="+i.url+(i.title!==r?"&text="+i.title:"")),e(this).find(".rrssb-vk a").attr("href","https://vk.com/share.php?url="+i.url),e(this).find(".rrssb-reddit a").attr("href","http://www.reddit.com/submit?url="+i.url+(i.description!==r?"&text="+i.description:"")+(i.title!==r?"&title="+i.title:"")),e(this).find(".rrssb-googleplus a").attr("href","https://plus.google.com/share?url="+i.url),e(this).find(".rrssb-pinterest a").attr("href","http://pinterest.com/pin/create/button/?url="+i.url+(i.image!==r?"&amp;media="+i.image:"")+(i.description!==r?"&description="+i.description:"")),e(this).find(".rrssb-pocket a").attr("href","https://getpocket.com/save?url="+i.url),e(this).find(".rrssb-github a").attr("href",i.url),e(this).find(".rrssb-print a").attr("href","javascript:window.print()"),e(this).find(".rrssb-whatsapp a").attr("href","whatsapp://send?text="+(i.description!==r?i.description+"%20":i.title!==r?i.title+"%20":"")+i.url)),(i.emailAddress!==r||i.emailSubject)&&e(this).find(".rrssb-email a").attr("href","mailto:"+(i.emailAddress?i.emailAddress:"")+"?"+(i.emailSubject!==r?"subject="+i.emailSubject:"")+(i.emailBody!==r?"&body="+i.emailBody:""))};var s=function(){var t=e("<div>"),r=["calc","-webkit-calc","-moz-calc"];e("body").append(t);for(var s=0;s<r.length;s++)if(t.css("width",r[s]+"(1px)"),1===t.width()){i.calc=r[s];break}t.remove()},a=function(t){if(t!==r&&null!==t){if(null===t.match(/%[0-9a-f]{2}/i))return encodeURIComponent(t);t=decodeURIComponent(t),a(t)}},n=function(){e(".rrssb-buttons").each(function(t){var r=e(this),i=e("li:visible",r),s=i.length,a=100/s;i.css("width",a+"%").attr("data-initwidth",a)})},l=function(){e(".rrssb-buttons").each(function(t){var r=e(this),i=r.width(),s=e("li",r).not(".small").eq(0).width(),a=e("li.small",r).length;if(s>170&&a<1){r.addClass("large-format");var n=s/12+"px";r.css("font-size",n)}else r.removeClass("large-format"),r.css("font-size","");i<25*a?r.removeClass("small-format").addClass("tiny-format"):r.removeClass("tiny-format")})},o=function(){e(".rrssb-buttons").each(function(t){var r=e(this),i=e("li",r),s=i.filter(".small"),a=0,n=0,l=s.eq(0),o=parseFloat(l.attr("data-size"))+55,c=s.length;if(c===i.length){var d=42*c,u=r.width();d+o<u&&(r.removeClass("small-format"),s.eq(0).removeClass("small"),h())}else{i.not(".small").each(function(t){var r=e(this),i=parseFloat(r.attr("data-size"))+55,s=parseFloat(r.width());a+=s,n+=i});var m=a-n;o<m&&(l.removeClass("small"),h())}})},c=function(t){e(".rrssb-buttons").each(function(t){var r=e(this),i=e("li",r);e(i.get().reverse()).each(function(t,r){var s=e(this);if(s.hasClass("small")===!1){var a=parseFloat(s.attr("data-size"))+55,n=parseFloat(s.width());if(a>n){var l=i.not(".small").last();e(l).addClass("small"),h()}}--r||o()})}),t===!0&&u(h)},h=function(){e(".rrssb-buttons").each(function(t){var r,s,a,l,o,c=e(this),h=e("li",c),d=h.filter(".small"),u=d.length;u>0&&u!==h.length?(c.removeClass("small-format"),d.css("width","42px"),a=42*u,r=h.not(".small").length,s=100/r,o=a/r,i.calc===!1?(l=(c.innerWidth()-1)/r-o,l=Math.floor(1e3*l)/1e3,l+="px"):l=i.calc+"("+s+"% - "+o+"px)",h.not(".small").css("width",l)):u===h.length?(c.addClass("small-format"),n()):(c.removeClass("small-format"),n())}),l()},d=function(){e(".rrssb-buttons").each(function(t){e(this).addClass("rrssb-"+(t+1))}),s(),n(),e(".rrssb-buttons li .rrssb-text").each(function(t){var r=e(this),i=r.width();r.closest("li").attr("data-size",i)}),c(!0)},u=function(t){e(".rrssb-buttons li.small").removeClass("small"),c(),t()},m=function(e,i,s,a){var n=t.screenLeft!==r?t.screenLeft:screen.left,l=t.screenTop!==r?t.screenTop:screen.top,o=t.innerWidth?t.innerWidth:document.documentElement.clientWidth?document.documentElement.clientWidth:screen.width,c=t.innerHeight?t.innerHeight:document.documentElement.clientHeight?document.documentElement.clientHeight:screen.height,h=o/2-s/2+n,d=c/3-a/3+l,u=t.open(e,i,"scrollbars=yes, width="+s+", height="+a+", top="+d+", left="+h);u&&u.focus&&u.focus()},f=function(){var t={};return function(e,r,i){i||(i="Don't call this twice without a uniqueId"),t[i]&&clearTimeout(t[i]),t[i]=setTimeout(e,r)}}();e(document).ready(function(){try{e(document).on("click",".rrssb-buttons a.popup",{},function(t){var r=e(this);m(r.attr("href"),r.find(".rrssb-text").html(),580,470),t.preventDefault()})}catch(t){}e(t).resize(function(){u(h),f(function(){u(h)},200,"finished resizing")}),d()}),t.rrssbInit=d}(window,jQuery);


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1hcGJveC1nbC1kaXJlY3Rpb25zLmpzIiwicnJzc2IubWluLmpzIiwiYXBwLmpzIl0sIm5hbWVzIjpbImYiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsInRoaXMiLCJNYXBib3hEaXJlY3Rpb25zIiwiZSIsInQiLCJuIiwiciIsInMiLCJvIiwidSIsImEiLCJyZXF1aXJlIiwiaSIsIkVycm9yIiwiY29kZSIsImwiLCJjYWxsIiwibGVuZ3RoIiwiMSIsIkV2ZW50RW1pdHRlciIsIl9ldmVudHMiLCJfbWF4TGlzdGVuZXJzIiwidW5kZWZpbmVkIiwiaXNGdW5jdGlvbiIsImFyZyIsImlzT2JqZWN0IiwiaXNVbmRlZmluZWQiLCJwcm90b3R5cGUiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwic2V0TWF4TGlzdGVuZXJzIiwiaXNOYU4iLCJUeXBlRXJyb3IiLCJlbWl0IiwidHlwZSIsImVyIiwiaGFuZGxlciIsImxlbiIsImFyZ3MiLCJsaXN0ZW5lcnMiLCJlcnJvciIsImFyZ3VtZW50cyIsImVyciIsImNvbnRleHQiLCJBcnJheSIsInNsaWNlIiwiYXBwbHkiLCJhZGRMaXN0ZW5lciIsImxpc3RlbmVyIiwibSIsIm5ld0xpc3RlbmVyIiwicHVzaCIsIndhcm5lZCIsImNvbnNvbGUiLCJ0cmFjZSIsIm9uIiwib25jZSIsImZpcmVkIiwiZyIsInJlbW92ZUxpc3RlbmVyIiwibGlzdCIsInBvc2l0aW9uIiwic3BsaWNlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwia2V5IiwibGlzdGVuZXJDb3VudCIsImV2bGlzdGVuZXIiLCJlbWl0dGVyIiwiMiIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJwcm9jZXNzIiwicnVuVGltZW91dCIsImZ1biIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjdXJyZW50UXVldWUiLCJxdWV1ZSIsImRyYWluaW5nIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwicnVuIiwibWFya2VyIiwicnVuQ2xlYXJUaW1lb3V0IiwiSXRlbSIsImFycmF5Iiwibm9vcCIsIm5leHRUaWNrIiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm9mZiIsImJpbmRpbmciLCJuYW1lIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsIjMiLCJpc09iaiIsImhhc093blByb3BlcnR5IiwiT2JqZWN0IiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiYXNzaWduS2V5IiwidG8iLCJmcm9tIiwidmFsIiwiYXNzaWduIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsInRhcmdldCIsInRvT2JqZWN0IiwiaXMtb2JqIiwiNCIsIngiLCI1IiwiRlVOQ19FUlJPUl9URVhUIiwiTkFOIiwic3ltYm9sVGFnIiwicmVUcmltIiwicmVJc0JhZEhleCIsInJlSXNCaW5hcnkiLCJyZUlzT2N0YWwiLCJmcmVlUGFyc2VJbnQiLCJwYXJzZUludCIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QiLCJGdW5jdGlvbiIsIm9iamVjdFRvU3RyaW5nIiwidG9TdHJpbmciLCJuYXRpdmVNYXgiLCJNYXRoIiwibWF4IiwibmF0aXZlTWluIiwibWluIiwibm93IiwiRGF0ZSIsInZhbHVlIiwidG9OdW1iZXIiLCJpc09iamVjdExpa2UiLCJpc1N5bWJvbCIsIm90aGVyIiwidmFsdWVPZiIsInJlcGxhY2UiLCJpc0JpbmFyeSIsInRlc3QiLCJmdW5jIiwid2FpdCIsIm9wdGlvbnMiLCJsYXN0QXJncyIsImxhc3RUaGlzIiwibWF4V2FpdCIsInJlc3VsdCIsInRpbWVySWQiLCJsYXN0Q2FsbFRpbWUiLCJsYXN0SW52b2tlVGltZSIsImxlYWRpbmciLCJtYXhpbmciLCJ0cmFpbGluZyIsImludm9rZUZ1bmMiLCJ0aW1lIiwidGhpc0FyZyIsInNob3VsZEludm9rZSIsInRpbWVTaW5jZUxhc3RDYWxsIiwidGltZXJFeHBpcmVkIiwidHJhaWxpbmdFZGdlIiwicmVtYWluaW5nV2FpdCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJsZWFkaW5nRWRnZSIsImNhbmNlbCIsImZsdXNoIiwiNiIsIkxBUkdFX0FSUkFZX1NJWkUiLCJIQVNIX1VOREVGSU5FRCIsIlVOT1JERVJFRF9DT01QQVJFX0ZMQUciLCJQQVJUSUFMX0NPTVBBUkVfRkxBRyIsIk1BWF9TQUZFX0lOVEVHRVIiLCJhcmdzVGFnIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJyZUlzSG9zdEN0b3IiLCJyZUlzVWludCIsInR5cGVkQXJyYXlUYWdzIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJmcmVlUHJvY2VzcyIsIm5vZGVVdGlsIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImFycmF5U29tZSIsInByZWRpY2F0ZSIsImluZGV4IiwiaXNIb3N0T2JqZWN0IiwibWFwVG9BcnJheSIsIm1hcCIsInNpemUiLCJmb3JFYWNoIiwic2V0VG9BcnJheSIsInNldCIsInVpZCIsInRyYW5zZm9ybSIsImFycmF5UHJvdG8iLCJmdW5jUHJvdG8iLCJvYmplY3RQcm90byIsImNvcmVKc0RhdGEiLCJtYXNrU3JjS2V5IiwiZXhlYyIsImtleXMiLCJJRV9QUk9UTyIsImZ1bmNUb1N0cmluZyIsInJlSXNOYXRpdmUiLCJSZWdFeHAiLCJTeW1ib2wiLCJVaW50OEFycmF5IiwibmF0aXZlS2V5cyIsIkRhdGFWaWV3IiwiZ2V0TmF0aXZlIiwiTWFwIiwiUHJvbWlzZSIsIlNldCIsIldlYWtNYXAiLCJuYXRpdmVDcmVhdGUiLCJkYXRhVmlld0N0b3JTdHJpbmciLCJ0b1NvdXJjZSIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsInN5bWJvbFByb3RvIiwic3ltYm9sVmFsdWVPZiIsIkhhc2giLCJlbnRyaWVzIiwiY2xlYXIiLCJlbnRyeSIsIkxpc3RDYWNoZSIsIk1hcENhY2hlIiwiU2V0Q2FjaGUiLCJ2YWx1ZXMiLCJfX2RhdGFfXyIsImFkZCIsIlN0YWNrIiwiYXJyYXlMaWtlS2V5cyIsImluaGVyaXRlZCIsImlzQXJyYXkiLCJpc0FycmF5TGlrZSIsImlzQXJyYXlMaWtlT2JqZWN0IiwiaXNBcmd1bWVudHMiLCJpdGVyYXRlZSIsImJhc2VUaW1lcyIsIlN0cmluZyIsInNraXBJbmRleGVzIiwiaXNJbmRleCIsImFzc29jSW5kZXhPZiIsImVxIiwiYmFzZUlzRXF1YWwiLCJjdXN0b21pemVyIiwiYml0bWFzayIsInN0YWNrIiwib2JqZWN0IiwiZXF1YWxGdW5jIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsImdldFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJlcXVhbEFycmF5cyIsInRhZyIsImJ5dGVMZW5ndGgiLCJieXRlT2Zmc2V0IiwiYnVmZmVyIiwibWVzc2FnZSIsImNvbnZlcnQiLCJpc1BhcnRpYWwiLCJzdGFja2VkIiwiZ2V0IiwiZXF1YWxCeVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoTGVuZ3RoIiwic2tpcEN0b3IiLCJvYmpWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJvYmpDdG9yIiwiY29uc3RydWN0b3IiLCJvdGhDdG9yIiwiZXF1YWxPYmplY3RzIiwiYmFzZUlzRXF1YWxEZWVwIiwiYmFzZUlzTmF0aXZlIiwiYmFzZUtleXMiLCJDdG9yIiwicHJvdG8iLCJhcnJMZW5ndGgiLCJzZWVuIiwiYXJyVmFsdWUiLCJvdGhJbmRleCIsImhhcyIsImdldE1hcERhdGEiLCJkYXRhIiwiZ2V0VmFsdWUiLCJwb3AiLCJoYXNoIiwic3RyaW5nIiwiY2FjaGUiLCJwYWlycyIsIkFycmF5QnVmZmVyIiwicmVzb2x2ZSIsImN0b3JTdHJpbmciLCJpc0xlbmd0aCIsImJhc2VVbmFyeSIsIjciLCJyZUludGVycG9sYXRlIiwidGVtcGxhdGVTZXR0aW5ncyIsIklORklOSVRZIiwicmVFbXB0eVN0cmluZ0xlYWRpbmciLCJyZUVtcHR5U3RyaW5nTWlkZGxlIiwicmVFbXB0eVN0cmluZ1RyYWlsaW5nIiwicmVFc1RlbXBsYXRlIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJzdHJpbmdFc2NhcGVzIiwiXFwiLCInIiwiXG4iLCJcciIsIuKAqCIsIuKAqSIsImJhc2VWYWx1ZXMiLCJwcm9wcyIsImFycmF5TWFwIiwiZXNjYXBlU3RyaW5nQ2hhciIsImNociIsInN5bWJvbFRvU3RyaW5nIiwiYXNzaWduSW5EZWZhdWx0cyIsInNyY1ZhbHVlIiwiYXNzaWduVmFsdWUiLCJiYXNlS2V5c0luIiwibmF0aXZlS2V5c0luIiwiaXNQcm90byIsImlzUHJvdG90eXBlIiwiYmFzZVJlc3QiLCJzdGFydCIsIm90aGVyQXJncyIsImJhc2VUb1N0cmluZyIsImlzSXRlcmF0ZWVDYWxsIiwiaXNFcnJvciIsImFzc2lnbmVyIiwiYXNzaWduSW5XaXRoIiwic291cmNlIiwic3JjSW5kZXgiLCJuZXdWYWx1ZSIsImNvcHlPYmplY3QiLCJrZXlzSW4iLCJzb3VyY2VzIiwiZ3VhcmQiLCJhdHRlbXB0Iiwic2V0dGluZ3MiLCJpbXBvcnRzIiwiXyIsImlzRXNjYXBpbmciLCJpc0V2YWx1YXRpbmciLCJpbXBvcnRzS2V5cyIsImltcG9ydHNWYWx1ZXMiLCJpbnRlcnBvbGF0ZSIsInJlRGVsaW1pdGVycyIsImVzY2FwZSIsImV2YWx1YXRlIiwic291cmNlVVJMIiwibWF0Y2giLCJlc2NhcGVWYWx1ZSIsImludGVycG9sYXRlVmFsdWUiLCJlc1RlbXBsYXRlVmFsdWUiLCJldmFsdWF0ZVZhbHVlIiwib2Zmc2V0IiwidmFyaWFibGUiLCJsb2Rhc2guX3JlaW50ZXJwb2xhdGUiLCJsb2Rhc2gudGVtcGxhdGVzZXR0aW5ncyIsIjgiLCI5IiwicmVVbmVzY2FwZWRIdG1sIiwicmVIYXNVbmVzY2FwZWRIdG1sIiwiZXNjYXBlSHRtbENoYXIiLCImIiwiPCIsIj4iLCJcIiIsImAiLCIxMCIsInBvbHlsaW5lIiwiZW5jb2RlIiwiY29vcmRpbmF0ZSIsImZhY3RvciIsInJvdW5kIiwib3V0cHV0IiwiZnJvbUNoYXJDb2RlIiwiZmxpcHBlZCIsImNvb3JkcyIsInJldmVyc2UiLCJkZWNvZGUiLCJzdHIiLCJwcmVjaXNpb24iLCJsYXRpdHVkZV9jaGFuZ2UiLCJsYXQiLCJsbmciLCJjb29yZGluYXRlcyIsInNoaWZ0IiwiYnl0ZSIsInBvdyIsImNoYXJDb2RlQXQiLCJiIiwiZnJvbUdlb0pTT04iLCJnZW9qc29uIiwiZ2VvbWV0cnkiLCJ0b0dlb0pTT04iLCIxMSIsImNyZWF0ZVRodW5rTWlkZGxld2FyZSIsImV4dHJhQXJndW1lbnQiLCJfcmVmIiwiZGlzcGF0Y2giLCJnZXRTdGF0ZSIsIm5leHQiLCJhY3Rpb24iLCJfX2VzTW9kdWxlIiwidGh1bmsiLCJ3aXRoRXh0cmFBcmd1bWVudCIsIjEyIiwiX2V4dGVuZHMiLCJfbGVuIiwibWlkZGxld2FyZXMiLCJfa2V5IiwiY3JlYXRlU3RvcmUiLCJyZWR1Y2VyIiwiaW5pdGlhbFN0YXRlIiwiZW5oYW5jZXIiLCJzdG9yZSIsIl9kaXNwYXRjaCIsImNoYWluIiwibWlkZGxld2FyZUFQSSIsIm1pZGRsZXdhcmUiLCJfY29tcG9zZTIiLCJvYmoiLCJfY29tcG9zZSIsImRlZmF1bHQiLCIuL2NvbXBvc2UiLCIxMyIsImJpbmRBY3Rpb25DcmVhdG9yIiwiYWN0aW9uQ3JlYXRvciIsImFjdGlvbkNyZWF0b3JzIiwiYm91bmRBY3Rpb25DcmVhdG9ycyIsIjE0IiwicmVkdWNlcnMiLCJyZWR1Y2VyS2V5cyIsImZpbmFsUmVkdWNlcnMiLCJzYW5pdHlFcnJvciIsImZpbmFsUmVkdWNlcktleXMiLCJfY3JlYXRlU3RvcmUiLCJBY3Rpb25UeXBlcyIsIklOSVQiLCJyYW5kb20iLCJzdWJzdHJpbmciLCJzcGxpdCIsImpvaW4iLCJhc3NlcnRSZWR1Y2VyU2FuaXR5Iiwic3RhdGUiLCJOT0RFX0VOViIsIndhcm5pbmdNZXNzYWdlIiwiaW5wdXRTdGF0ZSIsImFyZ3VtZW50TmFtZSIsIl9pc1BsYWluT2JqZWN0MiIsInVuZXhwZWN0ZWRLZXlzIiwiZmlsdGVyIiwiZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZSIsIl93YXJuaW5nMiIsImhhc0NoYW5nZWQiLCJuZXh0U3RhdGUiLCJwcmV2aW91c1N0YXRlRm9yS2V5IiwibmV4dFN0YXRlRm9yS2V5IiwiZXJyb3JNZXNzYWdlIiwiZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2UiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiYWN0aW9uVHlwZSIsIi4vY3JlYXRlU3RvcmUiLCIuL3V0aWxzL3dhcm5pbmciLCJfcHJvY2VzcyIsImxvZGFzaC9pc1BsYWluT2JqZWN0IiwiMTUiLCJmdW5jcyIsIl9yZXQiLCJsYXN0IiwicmVzdCIsInYiLCJyZWR1Y2VSaWdodCIsImNvbXBvc2VkIiwiMTYiLCJfcmVmMiIsImN1cnJlbnRSZWR1Y2VyIiwiY3VycmVudFN0YXRlIiwiY3VycmVudExpc3RlbmVycyIsIm5leHRMaXN0ZW5lcnMiLCJpc0Rpc3BhdGNoaW5nIiwiZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycyIsInN1YnNjcmliZSIsImlzU3Vic2NyaWJlZCIsImluZGV4T2YiLCJyZXBsYWNlUmVkdWNlciIsIm5leHRSZWR1Y2VyIiwiX3N5bWJvbE9ic2VydmFibGUyIiwib3V0ZXJTdWJzY3JpYmUiLCJvYnNlcnZlciIsIm9ic2VydmVTdGF0ZSIsInVuc3Vic2NyaWJlIiwic3ltYm9sLW9ic2VydmFibGUiLCIxNyIsImNvbXBvc2UiLCJhcHBseU1pZGRsZXdhcmUiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJjb21iaW5lUmVkdWNlcnMiLCJfY3JlYXRlU3RvcmUyIiwiX2NvbWJpbmVSZWR1Y2VyczIiLCJfYmluZEFjdGlvbkNyZWF0b3JzMiIsIl9hcHBseU1pZGRsZXdhcmUyIiwiaXNDcnVzaGVkIiwiLi9hcHBseU1pZGRsZXdhcmUiLCIuL2JpbmRBY3Rpb25DcmVhdG9ycyIsIi4vY29tYmluZVJlZHVjZXJzIiwiMTgiLCIxOSIsImdldFByb3RvdHlwZSIsIm92ZXJBcmciLCJnZXRQcm90b3R5cGVPZiIsIi4vX292ZXJBcmciLCIyMCIsIjIxIiwiMjIiLCIyMyIsIm9iamVjdEN0b3JTdHJpbmciLCIuL19nZXRQcm90b3R5cGUiLCIuL19pc0hvc3RPYmplY3QiLCIuL2lzT2JqZWN0TGlrZSIsIjI0IiwiLi9wb255ZmlsbCIsIjI1Iiwib2JzZXJ2YWJsZSIsIjI2IiwiU3VnZ2VzdGlvbnMiLCIuL3NyYy9zdWdnZXN0aW9ucyIsIjI3IiwiZnV6enkiLCJzaW1wbGVGaWx0ZXIiLCJwYXR0ZXJuIiwib3B0cyIsImNoIiwicGF0dGVybklkeCIsInRvdGFsU2NvcmUiLCJjdXJyU2NvcmUiLCJwcmUiLCJwb3N0IiwiY29tcGFyZVN0cmluZyIsImNhc2VTZW5zaXRpdmUiLCJ0b0xvd2VyQ2FzZSIsImlkeCIsInJlbmRlcmVkIiwic2NvcmUiLCJhcnIiLCJyZWR1Y2UiLCJwcmV2IiwiZWxlbWVudCIsImV4dHJhY3QiLCJvcmlnaW5hbCIsInNvcnQiLCJjb21wYXJlIiwiMjgiLCJMaXN0IiwiY29tcG9uZW50IiwiaXRlbXMiLCJhY3RpdmUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJlbCIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJuZXh0U2libGluZyIsInNob3ciLCJzdHlsZSIsImRpc3BsYXkiLCJoaWRlIiwiaXRlbSIsImlzRW1wdHkiLCJkcmF3IiwiaW5uZXJIVE1MIiwiZHJhd0l0ZW0iLCJsaSIsImFwcGVuZENoaWxkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImhhbmRsZU1vdXNlRG93biIsImJpbmQiLCJtb3ZlIiwicHJldmlvdXMiLCIyOSIsImV4dGVuZCIsIm1pbkxlbmd0aCIsImxpbWl0IiwicXVlcnkiLCJzZWxlY3RlZCIsImhhbmRsZUtleVVwIiwia2V5Q29kZSIsImhhbmRsZUtleURvd24iLCJoYW5kbGVGb2N1cyIsImhhbmRsZUJsdXIiLCJub3JtYWxpemUiLCJnZXRDYW5kaWRhdGVzIiwidXBkYXRlIiwicmV2aXNlZERhdGEiLCJjYW5kaWRhdGUiLCJnZXRJdGVtVmFsdWUiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJmaXJlRXZlbnQiLCJjYWxsYmFjayIsImQiLCIkMSIsIi4vbGlzdCIsInh0ZW5kIiwiMzAiLCJlYWNoIiwiY29vcmRFYWNoIiwibGF5ZXIiLCJleHRlbnQiLCJJbmZpbml0eSIsImNvb3JkIiwidHVyZi1tZXRhIiwiMzEiLCJleGNsdWRlV3JhcENvb3JkIiwiaiIsImsiLCJzdG9wRyIsImdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uIiwiaXNHZW9tZXRyeUNvbGxlY3Rpb24iLCJ3cmFwU2hyaW5rIiwiaXNGZWF0dXJlQ29sbGVjdGlvbiIsImlzRmVhdHVyZSIsInN0b3AiLCJmZWF0dXJlcyIsImdlb21ldHJpZXMiLCJwcm9wRWFjaCIsInByb3BlcnRpZXMiLCJjb29yZFJlZHVjZSIsIm1lbW8iLCJwcm9wUmVkdWNlIiwicHJvcCIsIjMyIiwiMzMiLCJkZWZpbmVQcm9wZXJ0eSIsInF1ZXJ5T3JpZ2luIiwidHlwZXMiLCJPUklHSU5fUVVFUlkiLCJxdWVyeURlc3RpbmF0aW9uIiwiREVTVElOQVRJT05fUVVFUlkiLCJxdWVyeU9yaWdpbkNvb3JkaW5hdGVzIiwicXVlcnlEZXN0aW5hdGlvbkNvb3JkaW5hdGVzIiwiY2xlYXJPcmlnaW4iLCJPUklHSU5fQ0xFQVIiLCJldmVudEVtaXQiLCJzZXRFcnJvciIsImNsZWFyRGVzdGluYXRpb24iLCJERVNUSU5BVElPTl9DTEVBUiIsInNldE9wdGlvbnMiLCJTRVRfT1BUSU9OUyIsImhvdmVyTWFya2VyIiwiZmVhdHVyZSIsIl91dGlsczIiLCJjcmVhdGVQb2ludCIsImlkIiwiSE9WRVJfTUFSS0VSIiwic2V0SG92ZXJNYXJrZXIiLCJzZXRSb3V0ZUluZGV4IiwiY3JlYXRlT3JpZ2luIiwiY3JlYXRlRGVzdGluYXRpb24iLCJzZXRQcm9maWxlIiwicHJvZmlsZSIsIl9nZXRTdGF0ZTQiLCJvcmlnaW4iLCJkZXN0aW5hdGlvbiIsIkRJUkVDVElPTlNfUFJPRklMRSIsImZldGNoRGlyZWN0aW9ucyIsIm9yaWdpblBvaW50IiwiZGVzdGluYXRpb25Qb2ludCIsInNldE9yaWdpbkZyb21Db29yZGluYXRlcyIsInZhbGlkQ29vcmRzIiwid3JhcCIsInNldERlc3RpbmF0aW9uRnJvbUNvb3JkaW5hdGVzIiwiYWRkV2F5cG9pbnQiLCJ3YXlwb2ludCIsIl9nZXRTdGF0ZTUiLCJ3YXlwb2ludHMiLCJub3JtYWxpemVXYXlwb2ludCIsInVwZGF0ZVdheXBvaW50cyIsInNldFdheXBvaW50IiwiX2dldFN0YXRlNiIsInJlbW92ZVdheXBvaW50IiwiX2dldFN0YXRlNyIsIndheSIsImNvb3JkaW5hdGVNYXRjaCIsImV2ZW50U3Vic2NyaWJlIiwiZm4iLCJfZ2V0U3RhdGU4IiwiZXZlbnRzIiwiRVZFTlRTIiwibmV3T2JqIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfdXRpbHMiLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJtYXJrZXItc3ltYm9sIiwiT1JJR0lOIiwiREVTVElOQVRJT04iLCJzZXREaXJlY3Rpb25zIiwiZGlyZWN0aW9ucyIsIkRJUkVDVElPTlMiLCJyb3V0ZSIsIldBWVBPSU5UUyIsIl9nZXRTdGF0ZSIsImFwaSIsImFjY2Vzc1Rva2VuIiwicm91dGVJbmRleCIsIl9zdGF0ZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImJ1aWxkRGlyZWN0aW9uc1F1ZXJ5IiwiYWJvcnQiLCJvcGVuIiwib25sb2FkIiwic3RhdHVzIiwiSlNPTiIsInBhcnNlIiwicmVzcG9uc2VUZXh0Iiwicm91dGVzIiwibG9jYXRpb24iLCJvbmVycm9yIiwic2VuZCIsIk9SSUdJTl9GUk9NX0NPT1JESU5BVEVTIiwiREVTVElOQVRJT05fRlJPTV9DT09SRElOQVRFUyIsIlJPVVRFX0lOREVYIiwiX3RoaXMiLCIuLi9jb25zdGFudHMvYWN0aW9uX3R5cGVzIiwiLi4vdXRpbHMiLCIzNCIsIkVSUk9SIiwiMzUiLCJfdHlwZW9mIiwiaXRlcmF0b3IiLCJfc3VnZ2VzdGlvbnMyIiwiX2xvZGFzaDIiLCJfeHRlbmQyIiwiR2VvY29kZXIiLCJfZXYiLCJwbGFjZWhvbGRlciIsInpvb20iLCJmbHlUbyIsIm9uQWRkIiwiX21hcCIsImljb24iLCJpbnB1dCIsIl9pbnB1dEVsIiwiX2NsZWFyRWwiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJtZXRhS2V5IiwiX3F1ZXJ5RnJvbUlucHV0IiwiX3R5cGVhaGVhZCIsImJib3giLCJmaXRCb3VuZHMiLCJjZW50ZXIiLCJfaW5wdXQiLCJmaXJlIiwiYWN0aW9ucyIsIl9jbGVhciIsImxvYWRpbmciLCJfbG9hZGluZ0VsIiwiY29udGFpbmVyIiwicGxhY2VfbmFtZSIsIl9nZW9jb2RlIiwicSIsInByb3hpbWl0eSIsImNvdW50cnkiLCJtYXBib3hnbCIsInRyaW0iLCJyZXN1bHRzIiwiX3Jlc3VsdHMiLCJfY2hhbmdlIiwib25DaGFuZ2UiLCJfcXVlcnkiLCJfc2V0SW5wdXQiLCJmb2N1cyIsImdldFJlc3VsdCIsIl9xdWVyeTIiLCJzZXRJbnB1dCIsImxvZGFzaC5kZWJvdW5jZSIsInN1Z2dlc3Rpb25zIiwiMzYiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2dlb2NvZGVyMiIsIl9sb2Rhc2g0IiwiX3R1cmZFeHRlbnQyIiwidG1wbCIsIklucHV0cyIsImluc3RhbmNlIiwiX2NsYXNzQ2FsbENoZWNrIiwiX3N0b3JlJGdldFN0YXRlIiwib3JpZ2luUXVlcnkiLCJkZXN0aW5hdGlvblF1ZXJ5IiwicmVuZGVyIiwibW9kZSIsIl9zdG9yZSRnZXRTdGF0ZTIiLCJiYiIsInBhZGRpbmciLCJfYWN0aW9ucyIsIl9zdG9yZSRnZXRTdGF0ZTMiLCJnZW9jb2RlciIsIm9yaWdpbklucHV0Iiwib3JpZ2luRWwiLCJxdWVyeVNlbGVjdG9yIiwiZGVzdGluYXRpb25JbnB1dCIsImRlc3RpbmF0aW9uRWwiLCJhbmltYXRlVG9Db29yZGluYXRlcyIsInByb2ZpbGVzIiwicXVlcnlTZWxlY3RvckFsbCIsIl9zdG9yZSRnZXRTdGF0ZTQiLCJfdGhpczIiLCJfc3RvcmUkZ2V0U3RhdGU1Iiwib3JpZ2luUXVlcnlDb29yZGluYXRlcyIsImRlc3RpbmF0aW9uUXVlcnlDb29yZGluYXRlcyIsIi4vZ2VvY29kZXIiLCJsb2Rhc2guaXNlcXVhbCIsImxvZGFzaC50ZW1wbGF0ZSIsInR1cmYtZXh0ZW50IiwiMzciLCJpbnN0cnVjdGlvbnNUZW1wbGF0ZSIsImVycm9yVGVtcGxhdGUiLCJJbnN0cnVjdGlvbnMiLCJ1bml0Iiwic2hvdWxkUmVuZGVyIiwiZGlyZWN0aW9uIiwic3RlcHMiLCJsZWdzIiwiZm9ybWF0IiwiZHVyYXRpb24iLCJkaXN0YW5jZSIsImdldEF0dHJpYnV0ZSIsIjM4IiwiX3JlZHV4IiwiX3JlZHV4VGh1bmsyIiwiX3BvbHlsaW5lIiwiX3JlZHVjZXJzMiIsIl9kaXJlY3Rpb25zX3N0eWxlMiIsIl9pbnB1dHMyIiwiX2luc3RydWN0aW9uczIiLCJzdG9yZVdpdGhNaWRkbGV3YXJlIiwib25EcmFnRG93biIsIl9vbkRyYWdEb3duIiwib25EcmFnTW92ZSIsIl9vbkRyYWdNb3ZlIiwib25EcmFnVXAiLCJfb25EcmFnVXAiLCJfbW92ZSIsIm9uQ2xpY2siLCJfb25DbGljayIsImNvbnRyb2xzIiwiaW5wdXRFbCIsImRpcmVjdGlvbnNFbCIsImlucHV0cyIsImluc3RydWN0aW9ucyIsInN1YnNjcmliZWRBY3Rpb25zIiwibG9hZGVkIiwibWFwU3RhdGUiLCJyZW1vdmVDaGlsZCIsInJlbW92ZVJvdXRlcyIsInN0b3JlVW5zdWJzY3JpYmUiLCJzdHlsZXMiLCJpbnRlcmFjdGl2ZSIsImFkZFNvdXJjZSIsImFkZExheWVyIiwiX3RoaXMzIiwibGluZVN0cmluZyIsImMiLCJyb3V0ZS1pbmRleCIsIm1hbmV1dmVyIiwiZ2V0U291cmNlIiwic2V0RGF0YSIsIl90aGlzNCIsImxuZ0xhdCIsInF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyIsInBvaW50IiwibGF5ZXJzIiwiX3RoaXM1IiwiZ2V0Q2FudmFzIiwiY3Vyc29yIiwiaXNDdXJzb3JPdmVyUG9pbnQiLCJkcmFnUGFuIiwiZGlzYWJsZSIsImVuYWJsZSIsImlzRHJhZ2dpbmciLCJfc3RvcmUkZ2V0U3RhdGU2IiwiX3N0b3JlJGdldFN0YXRlOCIsIi4vYWN0aW9ucyIsIi4vY29udHJvbHMvaW5wdXRzIiwiLi9jb250cm9scy9pbnN0cnVjdGlvbnMiLCIuL2RpcmVjdGlvbnNfc3R5bGUiLCIuL3JlZHVjZXJzIiwiLi91dGlscyIsInJlZHV4IiwicmVkdXgtdGh1bmsiLCIzOSIsImxheW91dCIsImxpbmUtY2FwIiwibGluZS1qb2luIiwicGFpbnQiLCJsaW5lLWNvbG9yIiwibGluZS13aWR0aCIsImNpcmNsZS1yYWRpdXMiLCJjaXJjbGUtY29sb3IiLCJ0ZXh0LWZpZWxkIiwidGV4dC1mb250IiwidGV4dC1zaXplIiwidGV4dC1jb2xvciIsIjQwIiwiX2RpcmVjdGlvbnMiLCJfZGlyZWN0aW9uczIiLCIuL2RpcmVjdGlvbnMiLCI0MSIsIl9kZWVwQXNzaWduIiwiX2RlZXBBc3NpZ24yIiwiLi4vY29uc3RhbnRzL2FjdGlvbl90eXBlcy5qcyIsImRlZXAtYXNzaWduIiwiNDIiLCJmbG9vciIsImgiLCJpbXBlcmlhbCIsIm1pIiwidG9GaXhlZCIsIm1ldHJpYyIsInciLCJjYWxjIiwicnJzc2IiLCJkZXNjcmlwdGlvbiIsImVtYWlsQWRkcmVzcyIsImVtYWlsQm9keSIsImVtYWlsU3ViamVjdCIsImltYWdlIiwidXJsIiwiZmluZCIsImF0dHIiLCJkZWNvZGVVUklDb21wb25lbnQiLCJjc3MiLCJoYXNDbGFzcyIsInBhcnNlRmxvYXQiLCJ3aWR0aCIsIm5vdCIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJpbm5lcldpZHRoIiwiYXBwZW5kIiwiY2xvc2VzdCIsInNjcmVlbkxlZnQiLCJzY3JlZW4iLCJsZWZ0Iiwic2NyZWVuVG9wIiwidG9wIiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50V2lkdGgiLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsImhlaWdodCIsInJlYWR5IiwiaHRtbCIsInByZXZlbnREZWZhdWx0IiwicmVzaXplIiwicnJzc2JJbml0IiwialF1ZXJ5Il0sIm1hcHBpbmdzIjoiQ0FBQSxTQUFVQSxHQUFHLEdBQW9CLGlCQUFWQyxTQUFvQyxvQkFBVEMsT0FBc0JBLE9BQU9ELFFBQVFELFNBQVMsR0FBbUIsbUJBQVRHLFFBQXFCQSxPQUFPQyxJQUFLRCxPQUFPLEdBQUdILE9BQU8sRUFBMEIsb0JBQVRLLE9BQXdCQSxPQUErQixvQkFBVEMsT0FBd0JBLE9BQTZCLG9CQUFQQyxLQUFzQkEsS0FBWUMsTUFBT0MsaUJBQW1CVCxLQUFyVSxDQUE0VSxXQUFxQyxPQUFPLFNBQVVVLEVBQUVDLEVBQUVDLEVBQUVDLEdBQUcsU0FBU0MsRUFBRUMsRUFBRUMsR0FBRyxJQUFJSixFQUFFRyxHQUFHLENBQUMsSUFBSUosRUFBRUksR0FBRyxDQUFDLElBQUlFLEVBQWtCLG1CQUFUQyxTQUFxQkEsUUFBUSxJQUFJRixHQUFHQyxFQUFFLE9BQU9BLEVBQUVGLEdBQUUsR0FBSSxHQUFHSSxFQUFFLE9BQU9BLEVBQUVKLEdBQUUsR0FBSSxJQUFJZixFQUFFLElBQUlvQixNQUFNLHVCQUF1QkwsRUFBRSxLQUFLLE1BQU1mLEVBQUVx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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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VXRpQixHQUFHLFFBQVEseUJBQXlCLEdBQUcsU0FBU2xELEdBQUcsSUFBSUUsRUFBRUgsRUFBRUYsTUFBTStDLEVBQUUxQyxFQUFFczlCLEtBQUssUUFBUXQ5QixFQUFFcTlCLEtBQUssZUFBZXdCLE9BQU8sSUFBSSxLQUFLLytCLEVBQUVnL0IsbUJBQW1CLE1BQU1oL0IsSUFBSUQsRUFBRUMsR0FBR2kvQixPQUFPLFdBQVc1K0IsRUFBRW84QixHQUFHcDlCLEVBQUUsV0FBV2dCLEVBQUVvOEIsSUFBSSxJQUFJLHVCQUF1QnBVLE1BQU1yb0IsRUFBRWsvQixVQUFVN1csRUFBMTFLLENBQTYxSzNvQixPQUFPeS9CO0FBQXIySztBQ0FBO0FBQUEiLCJmaWxlIjoiYXBwLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLk1hcGJveERpcmVjdGlvbnMgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxyXG4vL1xyXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxyXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcclxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXHJcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4vL1xyXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxyXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuLy9cclxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xyXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cclxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXHJcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxyXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXHJcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xyXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcblxyXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcclxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xyXG5cclxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXHJcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXHJcbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XHJcblxyXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3NcclxuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xyXG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXHJcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJuIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XHJcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xyXG5cclxuICBpZiAoIXRoaXMuX2V2ZW50cylcclxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG5cclxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXHJcbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcclxuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XHJcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XHJcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcclxuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIC8vIGZhc3QgY2FzZXNcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgLy8gc2xvd2VyXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XHJcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcclxuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgdmFyIG07XHJcblxyXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXHJcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG5cclxuICBpZiAoIXRoaXMuX2V2ZW50cylcclxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG5cclxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxyXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cclxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxyXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXHJcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xyXG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xyXG5cclxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcclxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxyXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XHJcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcclxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cclxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcclxuICBlbHNlXHJcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cclxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcclxuXHJcbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcclxuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xyXG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XHJcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcclxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCIobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuIFwiICtcclxuXHRcdFx0XHRcdFwiVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XHJcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxyXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcclxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcblxyXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xyXG5cclxuICBmdW5jdGlvbiBnKCkge1xyXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcclxuXHJcbiAgICBpZiAoIWZpcmVkKSB7XHJcbiAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICB0aGlzLm9uKHR5cGUsIGcpO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xyXG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xyXG5cclxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxyXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcclxuXHJcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xyXG4gIHBvc2l0aW9uID0gLTE7XHJcblxyXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxyXG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxyXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xyXG5cclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XHJcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XHJcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxyXG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XHJcbiAgICAgICAgcG9zaXRpb24gPSBpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcclxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxyXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICB2YXIga2V5LCBsaXN0ZW5lcnM7XHJcblxyXG4gIGlmICghdGhpcy5fZXZlbnRzKVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcclxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXHJcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxyXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XHJcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xyXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XHJcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XHJcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XHJcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgIC8vIExJRk8gb3JkZXJcclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxyXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xyXG4gIH1cclxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xyXG4gIHZhciByZXQ7XHJcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcclxuICAgIHJldCA9IFtdO1xyXG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcclxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xyXG4gIGVsc2VcclxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xyXG4gIHJldHVybiByZXQ7XHJcbn07XHJcblxyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xyXG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcclxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xyXG4gIH1cclxuICByZXR1cm4gMDtcclxufTtcclxuXHJcbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xyXG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xyXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcclxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xyXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xyXG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcclxufVxyXG5cclxufSx7fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XHJcblxyXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcclxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXHJcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcclxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cclxuXHJcbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xyXG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSAoKSlcclxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcclxuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XHJcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xyXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XHJcbiAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XHJcbiAgICAgICAgfSBjYXRjaChlKXtcclxuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG59XHJcbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcclxuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xyXG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xyXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xyXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcclxuICAgIH0gY2F0Y2ggKGUpe1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XHJcbiAgICAgICAgfSBjYXRjaCAoZSl7XHJcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxyXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxufVxyXG52YXIgcXVldWUgPSBbXTtcclxudmFyIGRyYWluaW5nID0gZmFsc2U7XHJcbnZhciBjdXJyZW50UXVldWU7XHJcbnZhciBxdWV1ZUluZGV4ID0gLTE7XHJcblxyXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XHJcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xyXG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XHJcbiAgICB9XHJcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xyXG4gICAgaWYgKGRyYWluaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XHJcbiAgICBkcmFpbmluZyA9IHRydWU7XHJcblxyXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcclxuICAgIHdoaWxlKGxlbikge1xyXG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xyXG4gICAgICAgIHF1ZXVlID0gW107XHJcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xyXG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XHJcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xyXG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG59XHJcblxyXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xyXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcclxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XHJcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcclxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XHJcbiAgICB0aGlzLmZ1biA9IGZ1bjtcclxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcclxufVxyXG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcclxufTtcclxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcclxucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcclxucHJvY2Vzcy5lbnYgPSB7fTtcclxucHJvY2Vzcy5hcmd2ID0gW107XHJcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xyXG5wcm9jZXNzLnZlcnNpb25zID0ge307XHJcblxyXG5mdW5jdGlvbiBub29wKCkge31cclxuXHJcbnByb2Nlc3Mub24gPSBub29wO1xyXG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcclxucHJvY2Vzcy5vbmNlID0gbm9vcDtcclxucHJvY2Vzcy5vZmYgPSBub29wO1xyXG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcclxucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xyXG5wcm9jZXNzLmVtaXQgPSBub29wO1xyXG5cclxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxufTtcclxuXHJcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XHJcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG59O1xyXG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xyXG5cclxufSx7fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGlzT2JqID0gcmVxdWlyZSgnaXMtb2JqJyk7XHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcclxuXHJcbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xyXG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1NvdXJjZXMgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzc2lnbktleSh0bywgZnJvbSwga2V5KSB7XHJcblx0dmFyIHZhbCA9IGZyb21ba2V5XTtcclxuXHJcblx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0aWYgKGhhc093blByb3BlcnR5LmNhbGwodG8sIGtleSkpIHtcclxuXHRcdGlmICh0b1trZXldID09PSB1bmRlZmluZWQgfHwgdG9ba2V5XSA9PT0gbnVsbCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QgKCcgKyBrZXkgKyAnKScpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRvLCBrZXkpIHx8ICFpc09iaih2YWwpKSB7XHJcblx0XHR0b1trZXldID0gdmFsO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0b1trZXldID0gYXNzaWduKE9iamVjdCh0b1trZXldKSwgZnJvbVtrZXldKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzc2lnbih0bywgZnJvbSkge1xyXG5cdGlmICh0byA9PT0gZnJvbSkge1xyXG5cdFx0cmV0dXJuIHRvO1xyXG5cdH1cclxuXHJcblx0ZnJvbSA9IE9iamVjdChmcm9tKTtcclxuXHJcblx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcclxuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcclxuXHRcdFx0YXNzaWduS2V5KHRvLCBmcm9tLCBrZXkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcclxuXHRcdHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xyXG5cdFx0XHRcdGFzc2lnbktleSh0bywgZnJvbSwgc3ltYm9sc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0bztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWVwQXNzaWduKHRhcmdldCkge1xyXG5cdHRhcmdldCA9IHRvT2JqZWN0KHRhcmdldCk7XHJcblxyXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XHJcblx0XHRhc3NpZ24odGFyZ2V0LCBhcmd1bWVudHNbc10pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcbn0se1wiaXMtb2JqXCI6NH1dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgpIHtcclxuXHR2YXIgdHlwZSA9IHR5cGVvZiB4O1xyXG5cdHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcclxufTtcclxuXHJcbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbi8qKlxyXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XHJcbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxyXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cclxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxyXG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxyXG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcclxuICovXHJcblxyXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xyXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xyXG5cclxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXHJcbnZhciBOQU4gPSAwIC8gMDtcclxuXHJcbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cclxudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xyXG5cclxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cclxudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xyXG5cclxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cclxudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcclxuXHJcbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cclxudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XHJcblxyXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cclxudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XHJcblxyXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xyXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XHJcblxyXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xyXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XHJcblxyXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xyXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcclxuXHJcbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxuXHJcbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cclxudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbi8qKlxyXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXHJcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxyXG4gKiBvZiB2YWx1ZXMuXHJcbiAqL1xyXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcclxuXHJcbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cclxudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxyXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXHJcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAyLjQuMFxyXG4gKiBAY2F0ZWdvcnkgRGF0ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcclxuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xyXG4gKiB9LCBfLm5vdygpKTtcclxuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cclxuICovXHJcbnZhciBub3cgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxyXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcclxuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxyXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cclxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXHJcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcclxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxyXG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxyXG4gKiBpbnZvY2F0aW9uLlxyXG4gKlxyXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXHJcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXHJcbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cclxuICpcclxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXHJcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cclxuICpcclxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXHJcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxyXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cclxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXHJcbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXHJcbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XHJcbiAqXHJcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxyXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XHJcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxyXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXHJcbiAqIH0pKTtcclxuICpcclxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cclxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XHJcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcclxuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xyXG4gKlxyXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxyXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcclxuICovXHJcbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcclxuICB2YXIgbGFzdEFyZ3MsXHJcbiAgICAgIGxhc3RUaGlzLFxyXG4gICAgICBtYXhXYWl0LFxyXG4gICAgICByZXN1bHQsXHJcbiAgICAgIHRpbWVySWQsXHJcbiAgICAgIGxhc3RDYWxsVGltZSxcclxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxyXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXHJcbiAgICAgIG1heGluZyA9IGZhbHNlLFxyXG4gICAgICB0cmFpbGluZyA9IHRydWU7XHJcblxyXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XHJcbiAgfVxyXG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xyXG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xyXG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xyXG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XHJcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xyXG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xyXG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcclxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XHJcblxyXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcclxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcclxuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xyXG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cclxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcclxuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXHJcbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xyXG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXHJcbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcclxuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXHJcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcclxuICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XHJcblxyXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XHJcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxyXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XHJcblxyXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcclxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXHJcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXHJcbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxyXG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xyXG4gICAgdmFyIHRpbWUgPSBub3coKTtcclxuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcclxuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcclxuICAgIH1cclxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxyXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XHJcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cclxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxyXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XHJcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xyXG4gICAgfVxyXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XHJcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcclxuICAgIH1cclxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcclxuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmx1c2goKSB7XHJcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcclxuICAgIHZhciB0aW1lID0gbm93KCksXHJcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcclxuXHJcbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcclxuICAgIGxhc3RUaGlzID0gdGhpcztcclxuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XHJcblxyXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcclxuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChtYXhpbmcpIHtcclxuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxyXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XHJcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcclxuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcclxuICByZXR1cm4gZGVib3VuY2VkO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXHJcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcclxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3Qoe30pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdChudWxsKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XHJcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxyXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xyXG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XHJcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cclxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLnRvTnVtYmVyKDMuMik7XHJcbiAqIC8vID0+IDMuMlxyXG4gKlxyXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xyXG4gKiAvLyA9PiA1ZS0zMjRcclxuICpcclxuICogXy50b051bWJlcihJbmZpbml0eSk7XHJcbiAqIC8vID0+IEluZmluaXR5XHJcbiAqXHJcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xyXG4gKiAvLyA9PiAzLjJcclxuICovXHJcbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gTkFOO1xyXG4gIH1cclxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XHJcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcclxuICB9XHJcbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xyXG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XHJcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXHJcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcclxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xyXG5cclxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcbn0se31dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbi8qKlxyXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XHJcbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxyXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cclxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxyXG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxyXG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcclxuICovXHJcblxyXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cclxudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XHJcblxyXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXHJcbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcclxuXHJcbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNvbXBhcmlzb24gc3R5bGVzLiAqL1xyXG52YXIgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyA9IDEsXHJcbiAgICBQQVJUSUFMX0NPTVBBUkVfRkxBRyA9IDI7XHJcblxyXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cclxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xyXG5cclxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xyXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxyXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxyXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcclxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXHJcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXHJcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcclxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXHJcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcclxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxyXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXHJcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxyXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXHJcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcclxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxyXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXHJcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xyXG5cclxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcclxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcclxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcclxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcclxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcclxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxyXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXHJcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcclxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXHJcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxyXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcclxuXHJcbi8qKlxyXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXHJcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxyXG4gKi9cclxudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcclxuXHJcbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cclxudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XHJcblxyXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXHJcbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XHJcblxyXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXHJcbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xyXG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cclxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxyXG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxyXG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XHJcbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xyXG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XHJcbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cclxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxyXG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XHJcbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cclxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxyXG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XHJcbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XHJcblxyXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xyXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XHJcblxyXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xyXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcclxuXHJcbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxuXHJcbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXHJcbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcclxuXHJcbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cclxudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcclxuXHJcbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXHJcbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xyXG5cclxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXHJcbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xyXG5cclxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXHJcbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcclxuICB9IGNhdGNoIChlKSB7fVxyXG59KCkpO1xyXG5cclxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cclxudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XHJcblxyXG4vKipcclxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxyXG4gKiBzaG9ydGhhbmRzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXHJcbiAqICBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xyXG4gIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XHJcblxyXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xyXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XHJcbiAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xyXG5cclxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcclxuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcclxuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cclxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcclxuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XHJcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcclxuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxyXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XHJcbiAgICB9IGNhdGNoIChlKSB7fVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcclxuICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xyXG5cclxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XHJcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xyXG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcclxuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcclxuICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xyXG5cclxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xyXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcclxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cclxudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcclxuXHJcbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXHJcbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xyXG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XHJcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xyXG59KCkpO1xyXG5cclxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xyXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xyXG5cclxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcclxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXHJcbiAqIG9mIHZhbHVlcy5cclxuICovXHJcbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xyXG5cclxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cclxudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcclxuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxyXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xyXG4pO1xyXG5cclxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXHJcbnZhciBTeW1ib2wgPSByb290LlN5bWJvbCxcclxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXHJcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxyXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XHJcblxyXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXHJcbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcclxuXHJcbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cclxudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxyXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcclxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcclxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXHJcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXHJcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XHJcblxyXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xyXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxyXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXHJcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxyXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXHJcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xyXG5cclxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXHJcbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXHJcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxyXG4gKi9cclxuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XHJcbiAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XHJcblxyXG4gIHRoaXMuY2xlYXIoKTtcclxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XHJcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGNsZWFyXHJcbiAqIEBtZW1iZXJPZiBIYXNoXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XHJcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGRlbGV0ZVxyXG4gKiBAbWVtYmVyT2YgSGFzaFxyXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xyXG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgZ2V0XHJcbiAqIEBtZW1iZXJPZiBIYXNoXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xyXG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcclxuICBpZiAobmF0aXZlQ3JlYXRlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xyXG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XHJcbiAgfVxyXG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGhhc1xyXG4gKiBAbWVtYmVyT2YgSGFzaFxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcclxuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XHJcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBzZXRcclxuICogQG1lbWJlck9mIEhhc2hcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cclxuICovXHJcbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xyXG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcclxuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxyXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcclxuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcclxuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcclxuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcclxuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xyXG4gIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xyXG5cclxuICB0aGlzLmNsZWFyKCk7XHJcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xyXG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBjbGVhclxyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXHJcbiAqL1xyXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcclxuICB0aGlzLl9fZGF0YV9fID0gW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgZGVsZXRlXHJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcclxuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXHJcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XHJcblxyXG4gIGlmIChpbmRleCA8IDApIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcclxuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XHJcbiAgICBkYXRhLnBvcCgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGdldFxyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XHJcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxyXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xyXG5cclxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGhhc1xyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XHJcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIHNldFxyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xyXG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcclxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcclxuXHJcbiAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cclxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xyXG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcclxuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XHJcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xyXG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cclxuICovXHJcbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcclxuICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcclxuXHJcbiAgdGhpcy5jbGVhcigpO1xyXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcclxuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBjbGVhclxyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcclxuICovXHJcbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XHJcbiAgdGhpcy5fX2RhdGFfXyA9IHtcclxuICAgICdoYXNoJzogbmV3IEhhc2gsXHJcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcclxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBkZWxldGVcclxuICogQG1lbWJlck9mIE1hcENhY2hlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcclxuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgZ2V0XHJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cclxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XHJcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBoYXNcclxuICogQG1lbWJlck9mIE1hcENhY2hlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcclxuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIHNldFxyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xyXG4gIGdldE1hcERhdGEodGhpcywga2V5KS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXHJcbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XHJcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcclxuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xyXG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XHJcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cclxuICovXHJcbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xyXG4gIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcclxuXHJcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcclxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgYWRkXHJcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxyXG4gKiBAYWxpYXMgcHVzaFxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xyXG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGhhc1xyXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cclxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcclxuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xyXG59XHJcblxyXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxyXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcclxuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XHJcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgY2xlYXJcclxuICogQG1lbWJlck9mIFN0YWNrXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xyXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBkZWxldGVcclxuICogQG1lbWJlck9mIFN0YWNrXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcclxuICByZXR1cm4gdGhpcy5fX2RhdGFfX1snZGVsZXRlJ10oa2V5KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgZ2V0XHJcbiAqIEBtZW1iZXJPZiBTdGFja1xyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cclxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XHJcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBoYXNcclxuICogQG1lbWJlck9mIFN0YWNrXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcclxuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIHNldFxyXG4gKiBAbWVtYmVyT2YgU3RhY2tcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XHJcbiAgdmFyIGNhY2hlID0gdGhpcy5fX2RhdGFfXztcclxuICBpZiAoY2FjaGUgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcclxuICAgIHZhciBwYWlycyA9IGNhY2hlLl9fZGF0YV9fO1xyXG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xyXG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgY2FjaGUgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcclxuICB9XHJcbiAgY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxyXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xyXG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XHJcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcclxuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xyXG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cclxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XHJcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cclxuICAvLyBTYWZhcmkgOSBtYWtlcyBgYXJndW1lbnRzLmxlbmd0aGAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cclxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcclxuICAgID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKVxyXG4gICAgOiBbXTtcclxuXHJcbiAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXHJcbiAgICAgIHNraXBJbmRleGVzID0gISFsZW5ndGg7XHJcblxyXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcclxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xyXG4gICAgICByZXN1bHQucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cclxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxyXG4gKi9cclxuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcclxuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG4gIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcclxuICAgICAgcmV0dXJuIGxlbmd0aDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIC0xO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2AuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xyXG4gIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcclxuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JpdG1hc2tdIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuXHJcbiAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcclxuICogICAgIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxyXG4gKiAgICAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcclxuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0KHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcclxuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xyXG4gIH1cclxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcclxuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtiaXRtYXNrXSBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxyXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cclxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XHJcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxyXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxyXG4gICAgICBvYmpUYWcgPSBhcnJheVRhZyxcclxuICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XHJcblxyXG4gIGlmICghb2JqSXNBcnIpIHtcclxuICAgIG9ialRhZyA9IGdldFRhZyhvYmplY3QpO1xyXG4gICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XHJcbiAgfVxyXG4gIGlmICghb3RoSXNBcnIpIHtcclxuICAgIG90aFRhZyA9IGdldFRhZyhvdGhlcik7XHJcbiAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcclxuICB9XHJcbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG9iamVjdCksXHJcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG90aGVyKSxcclxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcclxuXHJcbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcclxuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XHJcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxyXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spXHJcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xyXG4gIH1cclxuICBpZiAoIShiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcpKSB7XHJcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxyXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xyXG5cclxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XHJcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcclxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcclxuXHJcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XHJcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCFpc1NhbWVUYWcpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcclxuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXHJcbiAqICBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcclxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xyXG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XHJcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcclxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xyXG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xyXG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcclxuICB9XHJcbiAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xyXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXHJcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cclxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcclxuICogIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xyXG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcsXHJcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcclxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xyXG5cclxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cclxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XHJcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xyXG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XHJcbiAgfVxyXG4gIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICByZXN1bHQgPSB0cnVlLFxyXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBVTk9SREVSRURfQ09NUEFSRV9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XHJcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XHJcblxyXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cclxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xyXG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxyXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xyXG5cclxuICAgIGlmIChjdXN0b21pemVyKSB7XHJcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxyXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxyXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcclxuICAgIH1cclxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmIChjb21wYXJlZCkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXHJcbiAgICBpZiAoc2Vlbikge1xyXG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmICghc2Vlbi5oYXMob3RoSW5kZXgpICYmXHJcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5hZGQob3RoSW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KSkge1xyXG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCEoXHJcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcclxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spXHJcbiAgICAgICAgKSkge1xyXG4gICAgICByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XHJcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxyXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxyXG4gKlxyXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXHJcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cclxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcclxuICogIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcclxuICBzd2l0Y2ggKHRhZykge1xyXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcclxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxyXG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XHJcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xyXG5cclxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XHJcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcclxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICBjYXNlIGJvb2xUYWc6XHJcbiAgICBjYXNlIGRhdGVUYWc6XHJcbiAgICBjYXNlIG51bWJlclRhZzpcclxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cclxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cclxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XHJcblxyXG4gICAgY2FzZSBlcnJvclRhZzpcclxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcclxuXHJcbiAgICBjYXNlIHJlZ2V4cFRhZzpcclxuICAgIGNhc2Ugc3RyaW5nVGFnOlxyXG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxyXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXHJcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xyXG5cclxuICAgIGNhc2UgbWFwVGFnOlxyXG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XHJcblxyXG4gICAgY2FzZSBzZXRUYWc6XHJcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUc7XHJcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcclxuXHJcbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxyXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xyXG4gICAgICBpZiAoc3RhY2tlZCkge1xyXG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xyXG4gICAgICB9XHJcbiAgICAgIGJpdG1hc2sgfD0gVU5PUkRFUkVEX0NPTVBBUkVfRkxBRztcclxuXHJcbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxyXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XHJcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcclxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgY2FzZSBzeW1ib2xUYWc6XHJcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XHJcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XHJcbiAgICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXHJcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XHJcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRyxcclxuICAgICAgb2JqUHJvcHMgPSBrZXlzKG9iamVjdCksXHJcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcclxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcclxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xyXG5cclxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcclxuICB3aGlsZSAoaW5kZXgtLSkge1xyXG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcclxuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxyXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XHJcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xyXG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XHJcbiAgfVxyXG4gIHZhciByZXN1bHQgPSB0cnVlO1xyXG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcclxuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XHJcblxyXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcclxuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xyXG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xyXG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXHJcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xyXG5cclxuICAgIGlmIChjdXN0b21pemVyKSB7XHJcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxyXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXHJcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XHJcbiAgICB9XHJcbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cclxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcclxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykpXHJcbiAgICAgICAgICA6IGNvbXBhcmVkXHJcbiAgICAgICAgKSkge1xyXG4gICAgICByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XHJcbiAgfVxyXG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XHJcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcclxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XHJcblxyXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXHJcbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXHJcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXHJcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXHJcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xyXG4gICAgICByZXN1bHQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XHJcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cclxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xyXG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xyXG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxyXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cclxuICAgIDogZGF0YS5tYXA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcclxuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XHJcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXHJcbiAqL1xyXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcclxuXHJcbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExLFxyXG4vLyBmb3IgZGF0YSB2aWV3cyBpbiBFZGdlIDwgMTQsIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzLlxyXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XHJcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XHJcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XHJcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XHJcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XHJcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHZhciByZXN1bHQgPSBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSxcclxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcclxuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XHJcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcclxuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XHJcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XHJcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xyXG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xyXG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcclxuICByZXR1cm4gISFsZW5ndGggJiZcclxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXHJcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xyXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xyXG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXHJcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXHJcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XHJcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcclxuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxyXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcclxuXHJcbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xyXG4gIGlmIChmdW5jICE9IG51bGwpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcclxuICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XHJcbiAgICB9IGNhdGNoIChlKSB7fVxyXG4gIH1cclxuICByZXR1cm4gJyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBhXHJcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXHJcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcclxuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcclxuICpcclxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5lcShvYmplY3QsIG90aGVyKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5lcSgnYScsICdhJyk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5lcShOYU4sIE5hTik7XHJcbiAqIC8vID0+IHRydWVcclxuICovXHJcbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xyXG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgMC4xLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcclxuICogIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xyXG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXHJcbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcclxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgMC4xLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc0FycmF5KCdhYmMnKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc0FycmF5KF8ubm9vcCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xyXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXHJcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXHJcbiAqIGlzIGFuIG9iamVjdC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxyXG4gKiAgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcclxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXHJcbiAqIGVxdWl2YWxlbnQuXHJcbiAqXHJcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcclxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxyXG4gKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxyXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cclxuICogbm9kZXMgYXJlICoqbm90Kiogc3VwcG9ydGVkLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcclxuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcclxuICpcclxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIG9iamVjdCA9PT0gb3RoZXI7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xyXG4gIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzRnVuY3Rpb24oXyk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcclxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXHJcbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XHJcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxyXG4gKlxyXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxyXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0xlbmd0aCgzKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc0xlbmd0aCgnMycpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXHJcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcclxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxyXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc09iamVjdCh7fSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcclxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXHJcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XHJcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAzLjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxyXG4gKlxyXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxyXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXHJcbiAqIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBjYXRlZ29yeSBPYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBmdW5jdGlvbiBGb28oKSB7XHJcbiAqICAgdGhpcy5hID0gMTtcclxuICogICB0aGlzLmIgPSAyO1xyXG4gKiB9XHJcbiAqXHJcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XHJcbiAqXHJcbiAqIF8ua2V5cyhuZXcgRm9vKTtcclxuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxyXG4gKlxyXG4gKiBfLmtleXMoJ2hpJyk7XHJcbiAqIC8vID0+IFsnMCcsICcxJ11cclxuICovXHJcbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XHJcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXF1YWw7XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxufSx7fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAoZ2xvYmFsKXtcclxuLyoqXHJcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cclxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXHJcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XHJcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XHJcbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xyXG4gKi9cclxudmFyIHJlSW50ZXJwb2xhdGUgPSByZXF1aXJlKCdsb2Rhc2guX3JlaW50ZXJwb2xhdGUnKSxcclxuICAgIHRlbXBsYXRlU2V0dGluZ3MgPSByZXF1aXJlKCdsb2Rhc2gudGVtcGxhdGVzZXR0aW5ncycpO1xyXG5cclxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXHJcbnZhciBJTkZJTklUWSA9IDEgLyAwLFxyXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XHJcblxyXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXHJcbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXHJcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXHJcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcclxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXHJcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcclxuXHJcbi8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXHJcbnZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcclxuICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcclxuICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XHJcblxyXG4vKipcclxuICogVXNlZCB0byBtYXRjaFxyXG4gKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxyXG4gKi9cclxudmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcclxuXHJcbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cclxudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcclxuXHJcbi8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cclxudmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcclxuXHJcbi8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cclxudmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xyXG5cclxuLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXHJcbnZhciBzdHJpbmdFc2NhcGVzID0ge1xyXG4gICdcXFxcJzogJ1xcXFwnLFxyXG4gIFwiJ1wiOiBcIidcIixcclxuICAnXFxuJzogJ24nLFxyXG4gICdcXHInOiAncicsXHJcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxyXG4gICdcXHUyMDI5JzogJ3UyMDI5J1xyXG59O1xyXG5cclxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cclxudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xyXG5cclxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cclxudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XHJcblxyXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cclxudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcblxyXG4vKipcclxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxyXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXHJcbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cclxuICovXHJcbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcclxuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XHJcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XHJcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XHJcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XHJcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XHJcbiAgfVxyXG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xyXG59XHJcblxyXG4vKipcclxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXHJcbiAqIHNob3J0aGFuZHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cclxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XHJcbiAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcclxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcclxuXHJcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXHJcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcclxuICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XHJcblxyXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xyXG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXHJcbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xyXG4gKiBvZiBgcHJvcHNgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XHJcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcclxuICAgIHJldHVybiBvYmplY3Rba2V5XTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcclxuICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xyXG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cclxudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xyXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbi8qKlxyXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXHJcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxyXG4gKiBvZiB2YWx1ZXMuXHJcbiAqL1xyXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcclxuXHJcbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xyXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2wsXHJcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xyXG5cclxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xyXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXHJcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcclxuXHJcbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xyXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxyXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cclxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cclxuICovXHJcbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xyXG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXHJcbiAgLy8gU2FmYXJpIDkgbWFrZXMgYGFyZ3VtZW50cy5sZW5ndGhgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXHJcbiAgdmFyIHJlc3VsdCA9IChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpXHJcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcclxuICAgIDogW107XHJcblxyXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxyXG4gICAgICBza2lwSW5kZXhlcyA9ICEhbGVuZ3RoO1xyXG5cclxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcclxuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXHJcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoa2V5ID09ICdsZW5ndGgnIHx8IGlzSW5kZXgoa2V5LCBsZW5ndGgpKSkpIHtcclxuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXHJcbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cclxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cclxuICovXHJcbmZ1bmN0aW9uIGFzc2lnbkluRGVmYXVsdHMob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xyXG4gIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xyXG4gICAgcmV0dXJuIHNyY1ZhbHVlO1xyXG4gIH1cclxuICByZXR1cm4gb2JqVmFsdWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XHJcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXHJcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cclxuICovXHJcbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xyXG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xyXG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XHJcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XHJcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XHJcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XHJcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xyXG4gIH1cclxuICB2YXIgcmVzdWx0ID0gW107XHJcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XHJcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcclxuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xyXG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xyXG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xyXG4gIH1cclxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXHJcbiAgICAgIHJlc3VsdCA9IFtdO1xyXG5cclxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xyXG4gICAgICByZXN1bHQucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcclxuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgaW5kZXggPSAtMSxcclxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXHJcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xyXG5cclxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XHJcbiAgICB9XHJcbiAgICBpbmRleCA9IC0xO1xyXG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XHJcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XHJcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcclxuICAgIH1cclxuICAgIG90aGVyQXJnc1tzdGFydF0gPSBhcnJheTtcclxuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcclxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xyXG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xyXG4gIH1cclxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xyXG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xyXG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xyXG5cclxuICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xyXG5cclxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcclxuXHJcbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXHJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXHJcbiAgICAgIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gc291cmNlW2tleV0gOiBuZXdWYWx1ZSk7XHJcbiAgfVxyXG4gIHJldHVybiBvYmplY3Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xyXG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcclxuICAgIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxyXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcclxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcclxuICAgICAgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xyXG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XHJcbiAgICAgIGxlbmd0aCA9IDE7XHJcbiAgICB9XHJcbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcclxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcclxuICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvYmplY3Q7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xyXG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcclxuICByZXR1cm4gISFsZW5ndGggJiZcclxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXHJcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXHJcbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxyXG4gKiAgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcclxuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XHJcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcclxuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxyXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxyXG4gICAgICApIHtcclxuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcclxuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxyXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcclxuXHJcbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxyXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXHJcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cclxuICovXHJcbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcclxuICB2YXIgcmVzdWx0ID0gW107XHJcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcclxuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIGFcclxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcclxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xyXG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xyXG4gKlxyXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmVxKCdhJywgJ2EnKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmVxKE5hTiwgTmFOKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKi9cclxuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XHJcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxyXG4gKiAgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XHJcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cclxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxyXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXHJcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcclxuICogaXMgYW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXHJcbiAqICBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xyXG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXHJcbiAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgMy4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzRXJyb3IoRXJyb3IpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xyXG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGVycm9yVGFnKSB8fFxyXG4gICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgMC4xLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0Z1bmN0aW9uKF8pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XHJcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXHJcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxyXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xyXG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cclxuICpcclxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cclxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNMZW5ndGgoMyk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uaXNMZW5ndGgoJzMnKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxyXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXHJcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcclxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3Qoe30pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdChudWxsKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XHJcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxyXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xyXG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XHJcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcclxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy50b1N0cmluZyhudWxsKTtcclxuICogLy8gPT4gJydcclxuICpcclxuICogXy50b1N0cmluZygtMCk7XHJcbiAqIC8vID0+ICctMCdcclxuICpcclxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiAnMSwyLDMnXHJcbiAqL1xyXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcclxuICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXHJcbiAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXHJcbiAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXHJcbiAqXHJcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAYWxpYXMgZXh0ZW5kV2l0aFxyXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXHJcbiAqIEBzZWUgXy5hc3NpZ25XaXRoXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XHJcbiAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcclxuICogfVxyXG4gKlxyXG4gKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XHJcbiAqXHJcbiAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xyXG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cclxuICovXHJcbnZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcclxuICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxyXG4gKlxyXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxyXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXHJcbiAqIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBjYXRlZ29yeSBPYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBmdW5jdGlvbiBGb28oKSB7XHJcbiAqICAgdGhpcy5hID0gMTtcclxuICogICB0aGlzLmIgPSAyO1xyXG4gKiB9XHJcbiAqXHJcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XHJcbiAqXHJcbiAqIF8ua2V5cyhuZXcgRm9vKTtcclxuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxyXG4gKlxyXG4gKiBfLmtleXMoJ2hpJyk7XHJcbiAqIC8vID0+IFsnMCcsICcxJ11cclxuICovXHJcbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XHJcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cclxuICpcclxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDMuMC4wXHJcbiAqIEBjYXRlZ29yeSBPYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBmdW5jdGlvbiBGb28oKSB7XHJcbiAqICAgdGhpcy5hID0gMTtcclxuICogICB0aGlzLmIgPSAyO1xyXG4gKiB9XHJcbiAqXHJcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XHJcbiAqXHJcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xyXG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcclxuICovXHJcbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcclxuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcclxuICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cclxuICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXHJcbiAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXHJcbiAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cclxuICpcclxuICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcclxuICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXHJcbiAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxyXG4gKlxyXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxyXG4gKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXHJcbiAqXHJcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxyXG4gKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cclxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxyXG4gKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXHJcbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXHJcbiAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXHJcbiAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxyXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxyXG4gKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J3RlbXBsYXRlU291cmNlc1tuXSddXHJcbiAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxyXG4gKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXHJcbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cclxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XHJcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XHJcbiAqIC8vID0+ICdoZWxsbyBmcmVkISdcclxuICpcclxuICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cclxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xyXG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XHJcbiAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXHJcbiAqXHJcbiAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXHJcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XHJcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xyXG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcclxuICpcclxuICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxyXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xyXG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XHJcbiAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xyXG4gKlxyXG4gKiAvLyBVc2UgdGhlIEVTIGRlbGltaXRlciBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgZGVmYXVsdCBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxyXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XHJcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XHJcbiAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcclxuICpcclxuICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cclxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xyXG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcclxuICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcclxuICpcclxuICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxyXG4gKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xyXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xyXG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcclxuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXHJcbiAqXHJcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXHJcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcclxuICogY29tcGlsZWQoZGF0YSk7XHJcbiAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXHJcbiAqXHJcbiAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXHJcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XHJcbiAqIGNvbXBpbGVkLnNvdXJjZTtcclxuICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xyXG4gKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xyXG4gKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcclxuICogLy8gICByZXR1cm4gX19wO1xyXG4gKiAvLyB9XHJcbiAqXHJcbiAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cclxuICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcclxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcclxuICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XHJcbiAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXHJcbiAqXHJcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxyXG4gKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cclxuICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcclxuICogICB2YXIgSlNUID0ge1xcXHJcbiAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxyXG4gKiAgIH07XFxcclxuICogJyk7XHJcbiAqL1xyXG5mdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XHJcbiAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxyXG4gIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcclxuICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cclxuICB2YXIgc2V0dGluZ3MgPSB0ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHMuXy50ZW1wbGF0ZVNldHRpbmdzIHx8IHRlbXBsYXRlU2V0dGluZ3M7XHJcblxyXG4gIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xyXG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcclxuICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgYXNzaWduSW5EZWZhdWx0cyk7XHJcblxyXG4gIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGFzc2lnbkluRGVmYXVsdHMpLFxyXG4gICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXHJcbiAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcclxuXHJcbiAgdmFyIGlzRXNjYXBpbmcsXHJcbiAgICAgIGlzRXZhbHVhdGluZyxcclxuICAgICAgaW5kZXggPSAwLFxyXG4gICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxyXG4gICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XHJcblxyXG4gIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cclxuICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxyXG4gICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcclxuICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXHJcbiAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXHJcbiAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcclxuICAsICdnJyk7XHJcblxyXG4gIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cclxuICB2YXIgc291cmNlVVJMID0gJ3NvdXJjZVVSTCcgaW4gb3B0aW9ucyA/ICcvLyMgc291cmNlVVJMPScgKyBvcHRpb25zLnNvdXJjZVVSTCArICdcXG4nIDogJyc7XHJcblxyXG4gIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xyXG4gICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XHJcblxyXG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXHJcbiAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xyXG5cclxuICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxyXG4gICAgaWYgKGVzY2FwZVZhbHVlKSB7XHJcbiAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xyXG4gICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xyXG4gICAgfVxyXG4gICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcclxuICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcclxuICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xyXG4gICAgfVxyXG4gICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcclxuICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XHJcbiAgICB9XHJcbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcclxuXHJcbiAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cclxuICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXHJcbiAgICByZXR1cm4gbWF0Y2g7XHJcbiAgfSk7XHJcblxyXG4gIHNvdXJjZSArPSBcIic7XFxuXCI7XHJcblxyXG4gIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcclxuICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXHJcbiAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZTtcclxuICBpZiAoIXZhcmlhYmxlKSB7XHJcbiAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcclxuICB9XHJcbiAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxyXG4gIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxyXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcclxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xyXG5cclxuICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxyXG4gIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcclxuICAgICh2YXJpYWJsZVxyXG4gICAgICA/ICcnXHJcbiAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcclxuICAgICkgK1xyXG4gICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcclxuICAgIChpc0VzY2FwaW5nXHJcbiAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xyXG4gICAgICAgOiAnJ1xyXG4gICAgKSArXHJcbiAgICAoaXNFdmFsdWF0aW5nXHJcbiAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXHJcbiAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxyXG4gICAgICA6ICc7XFxuJ1xyXG4gICAgKSArXHJcbiAgICBzb3VyY2UgK1xyXG4gICAgJ3JldHVybiBfX3BcXG59JztcclxuXHJcbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcclxuICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxyXG4gIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXHJcbiAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcclxuICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XHJcbiAgICB0aHJvdyByZXN1bHQ7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxyXG4gKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAzLjAuMFxyXG4gKiBAY2F0ZWdvcnkgVXRpbFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxyXG4gKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cclxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxyXG4gKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XHJcbiAqIH0sICc+Xz4nKTtcclxuICpcclxuICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcclxuICogICBlbGVtZW50cyA9IFtdO1xyXG4gKiB9XHJcbiAqL1xyXG52YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHVuZGVmaW5lZCwgYXJncyk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xyXG4gIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlO1xyXG5cclxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcbn0se1wibG9kYXNoLl9yZWludGVycG9sYXRlXCI6OCxcImxvZGFzaC50ZW1wbGF0ZXNldHRpbmdzXCI6OX1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vKipcclxuICogbG9kYXNoIDMuMC4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxyXG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXHJcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XHJcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS43LjAgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XHJcbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcclxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cclxuICovXHJcblxyXG4vKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xyXG52YXIgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZUludGVycG9sYXRlO1xyXG5cclxufSx7fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAoZ2xvYmFsKXtcclxuLyoqXHJcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cclxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXHJcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XHJcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XHJcbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xyXG4gKi9cclxudmFyIHJlSW50ZXJwb2xhdGUgPSByZXF1aXJlKCdsb2Rhc2guX3JlaW50ZXJwb2xhdGUnKTtcclxuXHJcbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xyXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcclxuXHJcbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cclxudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xyXG5cclxuLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xyXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIidgXS9nLFxyXG4gICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xyXG5cclxuLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cclxudmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXHJcbiAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZztcclxuXHJcbi8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXHJcbnZhciBodG1sRXNjYXBlcyA9IHtcclxuICAnJic6ICcmYW1wOycsXHJcbiAgJzwnOiAnJmx0OycsXHJcbiAgJz4nOiAnJmd0OycsXHJcbiAgJ1wiJzogJyZxdW90OycsXHJcbiAgXCInXCI6ICcmIzM5OycsXHJcbiAgJ2AnOiAnJiM5NjsnXHJcbn07XHJcblxyXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xyXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XHJcblxyXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xyXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcclxuXHJcbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG4gKi9cclxudmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xyXG5cclxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xyXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcclxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXHJcbiAqIG9mIHZhbHVlcy5cclxuICovXHJcbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xyXG5cclxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXHJcbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcclxuXHJcbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xyXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxyXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xyXG5cclxuLyoqXHJcbiAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXHJcbiAqIGVtYmVkZGVkIFJ1YnkgKEVSQikuIENoYW5nZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZVxyXG4gKiBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG52YXIgdGVtcGxhdGVTZXR0aW5ncyA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXHJcbiAgICogQHR5cGUge1JlZ0V4cH1cclxuICAgKi9cclxuICAnZXNjYXBlJzogcmVFc2NhcGUsXHJcblxyXG4gIC8qKlxyXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxyXG4gICAqXHJcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xyXG4gICAqIEB0eXBlIHtSZWdFeHB9XHJcbiAgICovXHJcbiAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXHJcbiAgICogQHR5cGUge1JlZ0V4cH1cclxuICAgKi9cclxuICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxyXG5cclxuICAvKipcclxuICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cclxuICAndmFyaWFibGUnOiAnJyxcclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxyXG4gICAqXHJcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgJ2ltcG9ydHMnOiB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgICdfJzogeyAnZXNjYXBlJzogZXNjYXBlIH1cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXHJcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcclxuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcclxuICB9XHJcbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcclxuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcclxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc09iamVjdExpa2Uoe30pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc09iamVjdExpa2UobnVsbCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcclxuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxyXG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXHJcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8udG9TdHJpbmcobnVsbCk7XHJcbiAqIC8vID0+ICcnXHJcbiAqXHJcbiAqIF8udG9TdHJpbmcoLTApO1xyXG4gKiAvLyA9PiAnLTAnXHJcbiAqXHJcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gJzEsMiwzJ1xyXG4gKi9cclxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIFwiJ1wiLCBhbmQgXCJcXGBcIiBpbiBgc3RyaW5nYCB0b1xyXG4gKiB0aGVpciBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXHJcbiAqXHJcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxyXG4gKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cclxuICpcclxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxyXG4gKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xyXG4gKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXHJcbiAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcclxuICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIEJhY2t0aWNrcyBhcmUgZXNjYXBlZCBiZWNhdXNlIGluIElFIDwgOSwgdGhleSBjYW4gYnJlYWsgb3V0IG9mXHJcbiAqIGF0dHJpYnV0ZSB2YWx1ZXMgb3IgSFRNTCBjb21tZW50cy4gU2VlIFsjNTldKGh0dHBzOi8vaHRtbDVzZWMub3JnLyM1OSksXHJcbiAqIFsjMTAyXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTAyKSwgWyMxMDhdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDgpLCBhbmRcclxuICogWyMxMzNdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMzMpIG9mIHRoZVxyXG4gKiBbSFRNTDUgU2VjdXJpdHkgQ2hlYXRzaGVldF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvKSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKlxyXG4gKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXHJcbiAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXHJcbiAqIFhTUyB2ZWN0b3JzLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cclxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xyXG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xyXG4gKi9cclxuZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xyXG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XHJcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcclxuICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcclxuICAgIDogc3RyaW5nO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlU2V0dGluZ3M7XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxufSx7XCJsb2Rhc2guX3JlaW50ZXJwb2xhdGVcIjo4fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQmFzZWQgb2ZmIG9mIFt0aGUgb2ZmaWNhbCBHb29nbGUgZG9jdW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi91dGlsaXRpZXMvcG9seWxpbmVhbGdvcml0aG0pXHJcbiAqXHJcbiAqIFNvbWUgcGFydHMgZnJvbSBbdGhpcyBpbXBsZW1lbnRhdGlvbl0oaHR0cDovL2ZhY3N0YWZmLnVuY2EuZWR1L21jbWNjbHVyL0dvb2dsZU1hcHMvRW5jb2RlUG9seWxpbmUvUG9seWxpbmVFbmNvZGVyLmpzKVxyXG4gKiBieSBbTWFyayBNY0NsdXJlXShodHRwOi8vZmFjc3RhZmYudW5jYS5lZHUvbWNtY2NsdXIvKVxyXG4gKlxyXG4gKiBAbW9kdWxlIHBvbHlsaW5lXHJcbiAqL1xyXG5cclxudmFyIHBvbHlsaW5lID0ge307XHJcblxyXG5mdW5jdGlvbiBlbmNvZGUoY29vcmRpbmF0ZSwgZmFjdG9yKSB7XHJcbiAgICBjb29yZGluYXRlID0gTWF0aC5yb3VuZChjb29yZGluYXRlICogZmFjdG9yKTtcclxuICAgIGNvb3JkaW5hdGUgPDw9IDE7XHJcbiAgICBpZiAoY29vcmRpbmF0ZSA8IDApIHtcclxuICAgICAgICBjb29yZGluYXRlID0gfmNvb3JkaW5hdGU7XHJcbiAgICB9XHJcbiAgICB2YXIgb3V0cHV0ID0gJyc7XHJcbiAgICB3aGlsZSAoY29vcmRpbmF0ZSA+PSAweDIwKSB7XHJcbiAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKDB4MjAgfCAoY29vcmRpbmF0ZSAmIDB4MWYpKSArIDYzKTtcclxuICAgICAgICBjb29yZGluYXRlID4+PSA1O1xyXG4gICAgfVxyXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29vcmRpbmF0ZSArIDYzKTtcclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIHRvIGEgW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNvb3JkaW5hdGVzIGFycmF5LlxyXG4gKlxyXG4gKiBUaGlzIGlzIGFkYXB0ZWQgZnJvbSB0aGUgaW1wbGVtZW50YXRpb24gaW4gUHJvamVjdC1PU1JNLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmVjaXNpb25cclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9qZWN0LU9TUk0vb3NybS1mcm9udGVuZC9ibG9iL21hc3Rlci9XZWJDb250ZW50L3JvdXRpbmcvT1NSTS5Sb3V0aW5nR2VvbWV0cnkuanNcclxuICovXHJcbnBvbHlsaW5lLmRlY29kZSA9IGZ1bmN0aW9uKHN0ciwgcHJlY2lzaW9uKSB7XHJcbiAgICB2YXIgaW5kZXggPSAwLFxyXG4gICAgICAgIGxhdCA9IDAsXHJcbiAgICAgICAgbG5nID0gMCxcclxuICAgICAgICBjb29yZGluYXRlcyA9IFtdLFxyXG4gICAgICAgIHNoaWZ0ID0gMCxcclxuICAgICAgICByZXN1bHQgPSAwLFxyXG4gICAgICAgIGJ5dGUgPSBudWxsLFxyXG4gICAgICAgIGxhdGl0dWRlX2NoYW5nZSxcclxuICAgICAgICBsb25naXR1ZGVfY2hhbmdlLFxyXG4gICAgICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24gfHwgNSk7XHJcblxyXG4gICAgLy8gQ29vcmRpbmF0ZXMgaGF2ZSB2YXJpYWJsZSBsZW5ndGggd2hlbiBlbmNvZGVkLCBzbyBqdXN0IGtlZXBcclxuICAgIC8vIHRyYWNrIG9mIHdoZXRoZXIgd2UndmUgaGl0IHRoZSBlbmQgb2YgdGhlIHN0cmluZy4gSW4gZWFjaFxyXG4gICAgLy8gbG9vcCBpdGVyYXRpb24sIGEgc2luZ2xlIGNvb3JkaW5hdGUgaXMgZGVjb2RlZC5cclxuICAgIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgc2hpZnQsIHJlc3VsdCwgYW5kIGJ5dGVcclxuICAgICAgICBieXRlID0gbnVsbDtcclxuICAgICAgICBzaGlmdCA9IDA7XHJcbiAgICAgICAgcmVzdWx0ID0gMDtcclxuXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBieXRlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgrKykgLSA2MztcclxuICAgICAgICAgICAgcmVzdWx0IHw9IChieXRlICYgMHgxZikgPDwgc2hpZnQ7XHJcbiAgICAgICAgICAgIHNoaWZ0ICs9IDU7XHJcbiAgICAgICAgfSB3aGlsZSAoYnl0ZSA+PSAweDIwKTtcclxuXHJcbiAgICAgICAgbGF0aXR1ZGVfY2hhbmdlID0gKChyZXN1bHQgJiAxKSA/IH4ocmVzdWx0ID4+IDEpIDogKHJlc3VsdCA+PiAxKSk7XHJcblxyXG4gICAgICAgIHNoaWZ0ID0gcmVzdWx0ID0gMDtcclxuXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBieXRlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgrKykgLSA2MztcclxuICAgICAgICAgICAgcmVzdWx0IHw9IChieXRlICYgMHgxZikgPDwgc2hpZnQ7XHJcbiAgICAgICAgICAgIHNoaWZ0ICs9IDU7XHJcbiAgICAgICAgfSB3aGlsZSAoYnl0ZSA+PSAweDIwKTtcclxuXHJcbiAgICAgICAgbG9uZ2l0dWRlX2NoYW5nZSA9ICgocmVzdWx0ICYgMSkgPyB+KHJlc3VsdCA+PiAxKSA6IChyZXN1bHQgPj4gMSkpO1xyXG5cclxuICAgICAgICBsYXQgKz0gbGF0aXR1ZGVfY2hhbmdlO1xyXG4gICAgICAgIGxuZyArPSBsb25naXR1ZGVfY2hhbmdlO1xyXG5cclxuICAgICAgICBjb29yZGluYXRlcy5wdXNoKFtsYXQgLyBmYWN0b3IsIGxuZyAvIGZhY3Rvcl0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb29yZGluYXRlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY29vcmRpbmF0ZXMgYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxOdW1iZXI+Pn0gY29vcmRpbmF0ZXNcclxuICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvblxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxucG9seWxpbmUuZW5jb2RlID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMsIHByZWNpc2lvbikge1xyXG4gICAgaWYgKCFjb29yZGluYXRlcy5sZW5ndGgpIHsgcmV0dXJuICcnOyB9XHJcblxyXG4gICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24gfHwgNSksXHJcbiAgICAgICAgb3V0cHV0ID0gZW5jb2RlKGNvb3JkaW5hdGVzWzBdWzBdLCBmYWN0b3IpICsgZW5jb2RlKGNvb3JkaW5hdGVzWzBdWzFdLCBmYWN0b3IpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgYSA9IGNvb3JkaW5hdGVzW2ldLCBiID0gY29vcmRpbmF0ZXNbaSAtIDFdO1xyXG4gICAgICAgIG91dHB1dCArPSBlbmNvZGUoYVswXSAtIGJbMF0sIGZhY3Rvcik7XHJcbiAgICAgICAgb3V0cHV0ICs9IGVuY29kZShhWzFdIC0gYlsxXSwgZmFjdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZmxpcHBlZChjb29yZHMpIHtcclxuICAgIHZhciBmbGlwcGVkID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZsaXBwZWQucHVzaChjb29yZHNbaV0uc2xpY2UoKS5yZXZlcnNlKCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZsaXBwZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgR2VvSlNPTiBMaW5lU3RyaW5nIGZlYXR1cmUvZ2VvbWV0cnkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBnZW9qc29uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmVjaXNpb25cclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbnBvbHlsaW5lLmZyb21HZW9KU09OID0gZnVuY3Rpb24oZ2VvanNvbiwgcHJlY2lzaW9uKSB7XHJcbiAgICBpZiAoZ2VvanNvbiAmJiBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJykge1xyXG4gICAgICAgIGdlb2pzb24gPSBnZW9qc29uLmdlb21ldHJ5O1xyXG4gICAgfVxyXG4gICAgaWYgKCFnZW9qc29uIHx8IGdlb2pzb24udHlwZSAhPT0gJ0xpbmVTdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtdXN0IGJlIGEgR2VvSlNPTiBMaW5lU3RyaW5nJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9seWxpbmUuZW5jb2RlKGZsaXBwZWQoZ2VvanNvbi5jb29yZGluYXRlcyksIHByZWNpc2lvbik7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVjb2RlcyB0byBhIEdlb0pTT04gTGluZVN0cmluZyBnZW9tZXRyeS5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqL1xyXG5wb2x5bGluZS50b0dlb0pTT04gPSBmdW5jdGlvbihzdHIsIHByZWNpc2lvbikge1xyXG4gICAgdmFyIGNvb3JkcyA9IHBvbHlsaW5lLmRlY29kZShzdHIsIHByZWNpc2lvbik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcclxuICAgICAgICBjb29yZGluYXRlczogZmxpcHBlZChjb29yZHMpXHJcbiAgICB9O1xyXG59O1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBvbHlsaW5lO1xyXG59XHJcblxyXG59LHt9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmZ1bmN0aW9uIGNyZWF0ZVRodW5rTWlkZGxld2FyZShleHRyYUFyZ3VtZW50KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgICB2YXIgZGlzcGF0Y2ggPSBfcmVmLmRpc3BhdGNoO1xyXG4gICAgdmFyIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICByZXR1cm4gYWN0aW9uKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmFBcmd1bWVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICB9O1xyXG59XHJcblxyXG52YXIgdGh1bmsgPSBjcmVhdGVUaHVua01pZGRsZXdhcmUoKTtcclxudGh1bmsud2l0aEV4dHJhQXJndW1lbnQgPSBjcmVhdGVUaHVua01pZGRsZXdhcmU7XHJcblxyXG5leHBvcnRzWydkZWZhdWx0J10gPSB0aHVuaztcclxufSx7fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gYXBwbHlNaWRkbGV3YXJlO1xyXG5cclxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XHJcblxyXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxyXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXHJcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXHJcbiAqXHJcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cclxuICpcclxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XHJcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cclxuICpcclxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xyXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdG9yZSBlbmhhbmNlciBhcHBseWluZyB0aGUgbWlkZGxld2FyZS5cclxuICovXHJcbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpIHtcclxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGVuaGFuY2VyKSB7XHJcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpO1xyXG4gICAgICB2YXIgX2Rpc3BhdGNoID0gc3RvcmUuZGlzcGF0Y2g7XHJcbiAgICAgIHZhciBjaGFpbiA9IFtdO1xyXG5cclxuICAgICAgdmFyIG1pZGRsZXdhcmVBUEkgPSB7XHJcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxyXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcclxuICAgICAgICAgIHJldHVybiBfZGlzcGF0Y2goYWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIGNoYWluID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XHJcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBfZGlzcGF0Y2ggPSBfY29tcG9zZTJbXCJkZWZhdWx0XCJdLmFwcGx5KHVuZGVmaW5lZCwgY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcclxuXHJcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RvcmUsIHtcclxuICAgICAgICBkaXNwYXRjaDogX2Rpc3BhdGNoXHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICB9O1xyXG59XHJcbn0se1wiLi9jb21wb3NlXCI6MTV9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gYmluZEFjdGlvbkNyZWF0b3JzO1xyXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvci5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXHJcbiAqIHNhbWUga2V5cywgYnV0IHdpdGggZXZlcnkgZnVuY3Rpb24gd3JhcHBlZCBpbnRvIGEgYGRpc3BhdGNoYCBjYWxsIHNvIHRoZXlcclxuICogbWF5IGJlIGludm9rZWQgZGlyZWN0bHkuIFRoaXMgaXMganVzdCBhIGNvbnZlbmllbmNlIG1ldGhvZCwgYXMgeW91IGNhbiBjYWxsXHJcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXHJcbiAqXHJcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxyXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXHJcbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcclxuICogc3ludGF4LiBZb3UgbWF5IGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcclxuICogc3RvcmUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXHJcbiAqIGV2ZXJ5IGFjdGlvbiBjcmVhdG9yIHdyYXBwZWQgaW50byB0aGUgYGRpc3BhdGNoYCBjYWxsLiBJZiB5b3UgcGFzc2VkIGFcclxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcclxuICogZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XHJcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzICE9PSAnb2JqZWN0JyB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgJyArIChhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBhY3Rpb25DcmVhdG9ycykgKyAnLiAnICsgJ0RpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/Jyk7XHJcbiAgfVxyXG5cclxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFjdGlvbkNyZWF0b3JzKTtcclxuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XHJcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcclxufVxyXG59LHt9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAocHJvY2Vzcyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29tYmluZVJlZHVjZXJzO1xyXG5cclxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcclxuXHJcbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XHJcblxyXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XHJcblxyXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcclxuXHJcbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pIHtcclxuICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcclxuICB2YXIgYWN0aW9uTmFtZSA9IGFjdGlvblR5cGUgJiYgJ1wiJyArIGFjdGlvblR5cGUudG9TdHJpbmcoKSArICdcIicgfHwgJ2FuIGFjdGlvbic7XHJcblxyXG4gIHJldHVybiAnR2l2ZW4gYWN0aW9uICcgKyBhY3Rpb25OYW1lICsgJywgcmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkLiAnICsgJ1RvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24pIHtcclxuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XHJcbiAgdmFyIGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgPyAnaW5pdGlhbFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xyXG5cclxuICBpZiAocmVkdWNlcktleXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xyXG4gIH1cclxuXHJcbiAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyW1wiZGVmYXVsdFwiXSkoaW5wdXRTdGF0ZSkpIHtcclxuICAgIHJldHVybiAnVGhlICcgKyBhcmd1bWVudE5hbWUgKyAnIGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCInICsge30udG9TdHJpbmcuY2FsbChpbnB1dFN0YXRlKS5tYXRjaCgvXFxzKFthLXp8QS1aXSspLylbMV0gKyAnXCIuIEV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgJyArICgna2V5czogXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCInKTtcclxuICB9XHJcblxyXG4gIHZhciB1bmV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U3RhdGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSk7XHJcbiAgfSk7XHJcblxyXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICByZXR1cm4gJ1VuZXhwZWN0ZWQgJyArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgJyAnICsgKCdcIicgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArICdcIiBmb3VuZCBpbiAnICsgYXJndW1lbnROYW1lICsgJy4gJykgKyAnRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiAnICsgKCdcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC4nKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzc2VydFJlZHVjZXJTYW5pdHkocmVkdWNlcnMpIHtcclxuICBPYmplY3Qua2V5cyhyZWR1Y2VycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XHJcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgfSk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gJyArICdJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgJyArICdleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5ICcgKyAnbm90IGJlIHVuZGVmaW5lZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdHlwZSA9ICdAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcclxuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogdHlwZSB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiAnICsgKCdEb25cXCd0IHRyeSB0byBoYW5kbGUgJyArIF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUICsgJyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiICcpICsgJ25hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlICcgKyAnY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgJyArICdpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgJyArICdhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuJyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcclxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xyXG4gKiBpbnRvIGEgc2luZ2xlIHN0YXRlIG9iamVjdCwgd2hvc2Uga2V5cyBjb3JyZXNwb25kIHRvIHRoZSBrZXlzIG9mIHRoZSBwYXNzZWRcclxuICogcmVkdWNlciBmdW5jdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWR1Y2VycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGNvcnJlc3BvbmQgdG8gZGlmZmVyZW50XHJcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cclxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cclxuICogdW5kZWZpbmVkIGZvciBhbnkgYWN0aW9uLiBJbnN0ZWFkLCB0aGV5IHNob3VsZCByZXR1cm4gdGhlaXIgaW5pdGlhbCBzdGF0ZVxyXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcclxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cclxuICpcclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxyXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcclxuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XHJcbiAgdmFyIGZpbmFsUmVkdWNlcnMgPSB7fTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XHJcbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcclxuICAgIH1cclxuICB9XHJcbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcclxuXHJcbiAgdmFyIHNhbml0eUVycm9yO1xyXG4gIHRyeSB7XHJcbiAgICBhc3NlcnRSZWR1Y2VyU2FuaXR5KGZpbmFsUmVkdWNlcnMpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHNhbml0eUVycm9yID0gZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbigpIHtcclxuICAgIHZhciBzdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xyXG4gICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcclxuXHJcbiAgICBpZiAoc2FuaXR5RXJyb3IpIHtcclxuICAgICAgdGhyb3cgc2FuaXR5RXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShzdGF0ZSwgZmluYWxSZWR1Y2VycywgYWN0aW9uKTtcclxuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XHJcbiAgICAgICAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKHdhcm5pbmdNZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICB2YXIgbmV4dFN0YXRlID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGtleSA9IGZpbmFsUmVkdWNlcktleXNbaV07XHJcbiAgICAgIHZhciByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1trZXldO1xyXG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW2tleV07XHJcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XHJcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbik7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XHJcbiAgICAgIH1cclxuICAgICAgbmV4dFN0YXRlW2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XHJcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcclxuICAgIH1cclxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XHJcbiAgfTtcclxufVxyXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcclxufSx7XCIuL2NyZWF0ZVN0b3JlXCI6MTYsXCIuL3V0aWxzL3dhcm5pbmdcIjoxOCxcIl9wcm9jZXNzXCI6MixcImxvZGFzaC9pc1BsYWluT2JqZWN0XCI6MjN9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb21wb3NlO1xyXG4vKipcclxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcclxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXHJcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xyXG4gKiBmcm9tIHJpZ2h0IHRvIGxlZnQuIEZvciBleGFtcGxlLCBjb21wb3NlKGYsIGcsIGgpIGlzIGlkZW50aWNhbCB0byBkb2luZ1xyXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cclxuICovXHJcblxyXG5mdW5jdGlvbiBjb21wb3NlKCkge1xyXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgfVxyXG5cclxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xyXG4gICAgICByZXR1cm4gYXJnO1xyXG4gICAgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBsYXN0ID0gZnVuY3NbZnVuY3MubGVuZ3RoIC0gMV07XHJcbiAgICAgIHZhciByZXN0ID0gZnVuY3Muc2xpY2UoMCwgLTEpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHY6IGZ1bmN0aW9uIHYoKSB7XHJcbiAgICAgICAgICByZXR1cm4gcmVzdC5yZWR1Y2VSaWdodChmdW5jdGlvbiAoY29tcG9zZWQsIGYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGYoY29tcG9zZWQpO1xyXG4gICAgICAgICAgfSwgbGFzdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0oKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIF9yZXQgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XHJcbiAgfVxyXG59XHJcbn0se31dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHVuZGVmaW5lZDtcclxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjcmVhdGVTdG9yZTtcclxuXHJcbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XHJcblxyXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XHJcblxyXG52YXIgX3N5bWJvbE9ic2VydmFibGUgPSByZXF1aXJlKCdzeW1ib2wtb2JzZXJ2YWJsZScpO1xyXG5cclxudmFyIF9zeW1ib2xPYnNlcnZhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbE9ic2VydmFibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogVGhlc2UgYXJlIHByaXZhdGUgYWN0aW9uIHR5cGVzIHJlc2VydmVkIGJ5IFJlZHV4LlxyXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cclxuICogRG8gbm90IHJlZmVyZW5jZSB0aGVzZSBhY3Rpb24gdHlwZXMgZGlyZWN0bHkgaW4geW91ciBjb2RlLlxyXG4gKi9cclxudmFyIEFjdGlvblR5cGVzID0gZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHtcclxuICBJTklUOiAnQEByZWR1eC9JTklUJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxyXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cclxuICpcclxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxyXG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXHJcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxyXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cclxuICpcclxuICogQHBhcmFtIHthbnl9IFtpbml0aWFsU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxyXG4gKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxyXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxyXG4gKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXHJcbiAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuaGFuY2VyIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcclxuICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxyXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XHJcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXHJcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpIHtcclxuICB2YXIgX3JlZjI7XHJcblxyXG4gIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGVuaGFuY2VyID0gaW5pdGlhbFN0YXRlO1xyXG4gICAgaW5pdGlhbFN0YXRlID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcclxuICB9XHJcblxyXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XHJcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcclxuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xyXG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcclxuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xyXG5cclxuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xyXG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcclxuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xyXG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxyXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXHJcbiAgICogY2FsbCBgZ2V0U3RhdGUoKWAgdG8gcmVhZCB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGluc2lkZSB0aGUgY2FsbGJhY2suXHJcbiAgICpcclxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xyXG4gICAqIGNhdmVhdHM6XHJcbiAgICpcclxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXHJcbiAgICogSWYgeW91IHN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB3aGlsZSB0aGUgbGlzdGVuZXJzIGFyZSBiZWluZyBpbnZva2VkLCB0aGlzXHJcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXHJcbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXHJcbiAgICogcmVjZW50IHNuYXBzaG90IG9mIHRoZSBzdWJzY3JpcHRpb24gbGlzdC5cclxuICAgKlxyXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxyXG4gICAqIG1pZ2h0IGhhdmUgYmVlbiB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIG5lc3RlZCBgZGlzcGF0Y2goKWAgYmVmb3JlXHJcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcclxuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XHJcbiAgICogc3RhdGUgYnkgdGhlIHRpbWUgaXQgZXhpdHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXHJcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGlzIGNoYW5nZSBsaXN0ZW5lci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcclxuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xyXG5cclxuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcclxuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xyXG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XHJcblxyXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XHJcbiAgICAgIHZhciBpbmRleCA9IG5leHRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXHJcbiAgICpcclxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXHJcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxyXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcclxuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxyXG4gICAqXHJcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cclxuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xyXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxyXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcclxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcclxuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXHJcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXHJcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xyXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcclxuICAgIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MltcImRlZmF1bHRcIl0pKGFjdGlvbikpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gJyArICdVc2UgY3VzdG9tIG1pZGRsZXdhcmUgZm9yIGFzeW5jIGFjdGlvbnMuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xyXG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGlzdGVuZXJzW2ldKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFjdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxyXG4gICAqXHJcbiAgICogWW91IG1pZ2h0IG5lZWQgdGhpcyBpZiB5b3VyIGFwcCBpbXBsZW1lbnRzIGNvZGUgc3BsaXR0aW5nIGFuZCB5b3Ugd2FudCB0b1xyXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcclxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XHJcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY3VycmVudFJlZHVjZXIgPSBuZXh0UmVkdWNlcjtcclxuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxyXG4gICAqIEByZXR1cm5zIHtvYnNlcnZhYmxlfSBBIG1pbmltYWwgb2JzZXJ2YWJsZSBvZiBzdGF0ZSBjaGFuZ2VzLlxyXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XHJcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XHJcbiAgICB2YXIgX3JlZjtcclxuXHJcbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XHJcbiAgICByZXR1cm4gX3JlZiA9IHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cclxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cclxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXHJcbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXHJcbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXHJcbiAgICAgICAqL1xyXG5cclxuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcclxuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcclxuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xyXG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSB9O1xyXG4gICAgICB9XHJcbiAgICB9LCBfcmVmW19zeW1ib2xPYnNlcnZhYmxlMltcImRlZmF1bHRcIl1dID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sIF9yZWY7XHJcbiAgfVxyXG5cclxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxyXG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xyXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXHJcbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xyXG5cclxuICByZXR1cm4gX3JlZjIgPSB7XHJcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXHJcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcclxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcclxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxyXG4gIH0sIF9yZWYyW19zeW1ib2xPYnNlcnZhYmxlMltcImRlZmF1bHRcIl1dID0gb2JzZXJ2YWJsZSwgX3JlZjI7XHJcbn1cclxufSx7XCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiOjIzLFwic3ltYm9sLW9ic2VydmFibGVcIjoyNH1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZXhwb3J0cy5jb21wb3NlID0gZXhwb3J0cy5hcHBseU1pZGRsZXdhcmUgPSBleHBvcnRzLmJpbmRBY3Rpb25DcmVhdG9ycyA9IGV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gZXhwb3J0cy5jcmVhdGVTdG9yZSA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfY3JlYXRlU3RvcmUgPSByZXF1aXJlKCcuL2NyZWF0ZVN0b3JlJyk7XHJcblxyXG52YXIgX2NyZWF0ZVN0b3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVN0b3JlKTtcclxuXHJcbnZhciBfY29tYmluZVJlZHVjZXJzID0gcmVxdWlyZSgnLi9jb21iaW5lUmVkdWNlcnMnKTtcclxuXHJcbnZhciBfY29tYmluZVJlZHVjZXJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbWJpbmVSZWR1Y2Vycyk7XHJcblxyXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYmluZEFjdGlvbkNyZWF0b3JzJyk7XHJcblxyXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9yczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaW5kQWN0aW9uQ3JlYXRvcnMpO1xyXG5cclxudmFyIF9hcHBseU1pZGRsZXdhcmUgPSByZXF1aXJlKCcuL2FwcGx5TWlkZGxld2FyZScpO1xyXG5cclxudmFyIF9hcHBseU1pZGRsZXdhcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwbHlNaWRkbGV3YXJlKTtcclxuXHJcbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xyXG5cclxudmFyIF9jb21wb3NlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvc2UpO1xyXG5cclxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XHJcblxyXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuXHJcbi8qXHJcbiogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxyXG4qIElmIHRoZSBmdW5jdGlvbiBoYXMgYmVlbiBtaW5pZmllZCBhbmQgTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJywgd2FybiB0aGUgdXNlci5cclxuKi9cclxuZnVuY3Rpb24gaXNDcnVzaGVkKCkge31cclxuXHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XHJcbiAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKCdZb3UgYXJlIGN1cnJlbnRseSB1c2luZyBtaW5pZmllZCBjb2RlIG91dHNpZGUgb2YgTk9ERV9FTlYgPT09IFxcJ3Byb2R1Y3Rpb25cXCcuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBEZWZpbmVQbHVnaW4gZm9yIHdlYnBhY2sgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAwMzAwMzEpICcgKyAndG8gZW5zdXJlIHlvdSBoYXZlIHRoZSBjb3JyZWN0IGNvZGUgZm9yIHlvdXIgcHJvZHVjdGlvbiBidWlsZC4nKTtcclxufVxyXG5cclxuZXhwb3J0cy5jcmVhdGVTdG9yZSA9IF9jcmVhdGVTdG9yZTJbXCJkZWZhdWx0XCJdO1xyXG5leHBvcnRzLmNvbWJpbmVSZWR1Y2VycyA9IF9jb21iaW5lUmVkdWNlcnMyW1wiZGVmYXVsdFwiXTtcclxuZXhwb3J0cy5iaW5kQWN0aW9uQ3JlYXRvcnMgPSBfYmluZEFjdGlvbkNyZWF0b3JzMltcImRlZmF1bHRcIl07XHJcbmV4cG9ydHMuYXBwbHlNaWRkbGV3YXJlID0gX2FwcGx5TWlkZGxld2FyZTJbXCJkZWZhdWx0XCJdO1xyXG5leHBvcnRzLmNvbXBvc2UgPSBfY29tcG9zZTJbXCJkZWZhdWx0XCJdO1xyXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcclxufSx7XCIuL2FwcGx5TWlkZGxld2FyZVwiOjEyLFwiLi9iaW5kQWN0aW9uQ3JlYXRvcnNcIjoxMyxcIi4vY29tYmluZVJlZHVjZXJzXCI6MTQsXCIuL2NvbXBvc2VcIjoxNSxcIi4vY3JlYXRlU3RvcmVcIjoxNixcIi4vdXRpbHMvd2FybmluZ1wiOjE4LFwiX3Byb2Nlc3NcIjoyfV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHdhcm5pbmc7XHJcbi8qKlxyXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cclxuICogQHJldHVybnMge3ZvaWR9XHJcbiAqL1xyXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcclxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXHJcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICB9XHJcbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXHJcbiAgdHJ5IHtcclxuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxyXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcclxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxyXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cclxuICB9IGNhdGNoIChlKSB7fVxyXG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cclxufVxyXG59LHt9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xyXG5cclxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXHJcbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xyXG5cclxufSx7XCIuL19vdmVyQXJnXCI6MjF9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xyXG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXHJcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cclxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xyXG4gICAgfSBjYXRjaCAoZSkge31cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpc0hvc3RPYmplY3Q7XHJcblxyXG59LHt9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcclxuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XHJcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XHJcbiAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xyXG5cclxufSx7fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXHJcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XHJcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcclxuXHJcbn0se31dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxyXG4gICAgaXNIb3N0T2JqZWN0ID0gcmVxdWlyZSgnLi9faXNIb3N0T2JqZWN0JyksXHJcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xyXG5cclxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xyXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcblxyXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXHJcbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXHJcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXHJcbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XHJcblxyXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cclxudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XHJcblxyXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXHJcbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcclxuXHJcbi8qKlxyXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXHJcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxyXG4gKiBvZiB2YWx1ZXMuXHJcbiAqL1xyXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXHJcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgMC44LjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICogICB0aGlzLmEgPSAxO1xyXG4gKiB9XHJcbiAqXHJcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xyXG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fFxyXG4gICAgICBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSAhPSBvYmplY3RUYWcgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xyXG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XHJcbiAgcmV0dXJuICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmXHJcbiAgICBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJiBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xyXG5cclxufSx7XCIuL19nZXRQcm90b3R5cGVcIjoxOSxcIi4vX2lzSG9zdE9iamVjdFwiOjIwLFwiLi9pc09iamVjdExpa2VcIjoyMn1dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG4vKiBnbG9iYWwgd2luZG93ICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9wb255ZmlsbCcpKGdsb2JhbCB8fCB3aW5kb3cgfHwgdGhpcyk7XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxufSx7XCIuL3BvbnlmaWxsXCI6MjV9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcclxuXHR2YXIgcmVzdWx0O1xyXG5cdHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcclxuXHJcblx0aWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xyXG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlc3VsdCA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xyXG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxufSx7fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQSB0eXBlYWhlYWQgY29tcG9uZW50IGZvciBpbnB1dHNcclxuICogQGNsYXNzIFN1Z2dlc3Rpb25zXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gZWwgQSB2YWxpZCBIVE1MIGlucHV0IGVsZW1lbnRcclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBbiBhcnJheSBvZiBkYXRhIHVzZWQgZm9yIHJlc3VsdHNcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbWl0PTVdIE1heCBudW1iZXIgb2YgcmVzdWx0cyB0byBkaXNwbGF5IGluIHRoZSBhdXRvIHN1Z2dlc3QgbGlzdC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pbkxlbmd0aD0yXSBOdW1iZXIgb2YgY2hhcmFjdGVycyB0eXBlZCBpbnRvIGFuIGlucHV0IHRvIHRyaWdnZXIgc3VnZ2VzdGlvbnMuXHJcbiAqIEByZXR1cm4ge1N1Z2dlc3Rpb25zfSBgdGhpc2BcclxuICogQGV4YW1wbGVcclxuICogLy8gaW4gdGhlIGJyb3dzZXJcclxuICogdmFyIGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcclxuICogdmFyIGRhdGEgPSBbXHJcbiAqICAgJ1JveSBFbGRyaWRnZScsXHJcbiAqICAgJ1JveSBIYXJncm92ZScsXHJcbiAqICAgJ1JleCBTdGV3YXJ0J1xyXG4gKiBdO1xyXG4gKlxyXG4gKiBuZXcgU3VnZ2VzdGlvbnMoaW5wdXQsIGRhdGEpO1xyXG4gKlxyXG4gKiAvLyB3aXRoIG9wdGlvbnNcclxuICogdmFyIGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcclxuICogdmFyIGRhdGEgPSBbe1xyXG4gKiAgIG5hbWU6ICdSb3kgRWxkcmlkZ2UnLFxyXG4gKiAgIHllYXI6IDE5MTFcclxuICogfSwge1xyXG4gKiAgIG5hbWU6ICdSb3kgSGFyZ3JvdmUnLFxyXG4gKiAgIHllYXI6IDE5NjlcclxuICogfSwge1xyXG4gKiAgIG5hbWU6ICdSZXggU3Rld2FydCcsXHJcbiAqICAgeWVhcjogMTkwN1xyXG4gKiB9XTtcclxuICpcclxuICogdmFyIHR5cGVhaGVhZCA9IG5ldyBTdWdnZXN0aW9ucyhpbnB1dCwgZGF0YSwge1xyXG4gKiAgIGZpbHRlcjogZmFsc2UsIC8vIERpc2FibGUgZmlsdGVyaW5nXHJcbiAqICAgbWluTGVuZ3RoOiAzLCAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0eXBlZCBpbnRvIGFuIGlucHV0IHRvIHRyaWdnZXIgc3VnZ2VzdGlvbnMuXHJcbiAqICAgbGltaXQ6IDMgLy8gIE1heCBudW1iZXIgb2YgcmVzdWx0cyB0byBkaXNwbGF5LlxyXG4gKiB9KTtcclxuICpcclxuICogLy8gQXMgd2UncmUgcGFzc2luZyBhbiBvYmplY3Qgb2YgYW4gYXJyYXlzIGFzIGRhdGEsIG92ZXJyaWRlXHJcbiAqIC8vIGBnZXRJdGVtVmFsdWVgIGJ5IHNwZWNpZnlpbmcgdGhlIHNwZWNpZmljIHByb3BlcnR5IHRvIHNlYXJjaCBvbi5cclxuICogdHlwZWFoZWFkLmdldEl0ZW1WYWx1ZSA9IGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ubmFtZSB9O1xyXG4gKlxyXG4gKiBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuICogICBjb25zb2xlLmxvZyh0eXBlYWhlYWQuc2VsZWN0ZWQpOyAvLyBDdXJyZW50IHNlbGVjdGVkIGl0ZW0uXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiAvLyBXaXRoIGJyb3dzZXJpZnlcclxuICogdmFyIFN1Z2dlc3Rpb25zID0gcmVxdWlyZSgnc3VnZ2VzdGlvbnMnKTtcclxuICpcclxuICogbmV3IFN1Z2dlc3Rpb25zKGlucHV0LCBkYXRhKTtcclxuICovXHJcbnZhciBTdWdnZXN0aW9ucyA9IHJlcXVpcmUoJy4vc3JjL3N1Z2dlc3Rpb25zJyk7XHJcbndpbmRvdy5TdWdnZXN0aW9ucyA9IG1vZHVsZS5leHBvcnRzID0gU3VnZ2VzdGlvbnM7XHJcblxyXG59LHtcIi4vc3JjL3N1Z2dlc3Rpb25zXCI6Mjl9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qXHJcbiAqIEZ1enp5XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9teW9yay9mdXp6eVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTWF0dCBZb3JrXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuICovXHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG52YXIgcm9vdCA9IHRoaXM7XHJcblxyXG52YXIgZnV6enkgPSB7fTtcclxuXHJcbi8vIFVzZSBpbiBub2RlIG9yIGluIGJyb3dzZXJcclxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gZnV6enk7XHJcbn0gZWxzZSB7XHJcbiAgcm9vdC5mdXp6eSA9IGZ1enp5O1xyXG59XHJcblxyXG4vLyBSZXR1cm4gYWxsIGVsZW1lbnRzIG9mIGBhcnJheWAgdGhhdCBoYXZlIGEgZnV6enlcclxuLy8gbWF0Y2ggYWdhaW5zdCBgcGF0dGVybmAuXHJcbmZ1enp5LnNpbXBsZUZpbHRlciA9IGZ1bmN0aW9uKHBhdHRlcm4sIGFycmF5KSB7XHJcbiAgcmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbihzdHJpbmcpIHtcclxuICAgIHJldHVybiBmdXp6eS50ZXN0KHBhdHRlcm4sIHN0cmluZyk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vLyBEb2VzIGBwYXR0ZXJuYCBmdXp6eSBtYXRjaCBgc3RyaW5nYD9cclxuZnV6enkudGVzdCA9IGZ1bmN0aW9uKHBhdHRlcm4sIHN0cmluZykge1xyXG4gIHJldHVybiBmdXp6eS5tYXRjaChwYXR0ZXJuLCBzdHJpbmcpICE9PSBudWxsO1xyXG59O1xyXG5cclxuLy8gSWYgYHBhdHRlcm5gIG1hdGNoZXMgYHN0cmluZ2AsIHdyYXAgZWFjaCBtYXRjaGluZyBjaGFyYWN0ZXJcclxuLy8gaW4gYG9wdHMucHJlYCBhbmQgYG9wdHMucG9zdGAuIElmIG5vIG1hdGNoLCByZXR1cm4gbnVsbFxyXG5mdXp6eS5tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4sIHN0cmluZywgb3B0cykge1xyXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gIHZhciBwYXR0ZXJuSWR4ID0gMFxyXG4gICAgLCByZXN1bHQgPSBbXVxyXG4gICAgLCBsZW4gPSBzdHJpbmcubGVuZ3RoXHJcbiAgICAsIHRvdGFsU2NvcmUgPSAwXHJcbiAgICAsIGN1cnJTY29yZSA9IDBcclxuICAgIC8vIHByZWZpeFxyXG4gICAgLCBwcmUgPSBvcHRzLnByZSB8fCAnJ1xyXG4gICAgLy8gc3VmZml4XHJcbiAgICAsIHBvc3QgPSBvcHRzLnBvc3QgfHwgJydcclxuICAgIC8vIFN0cmluZyB0byBjb21wYXJlIGFnYWluc3QuIFRoaXMgbWlnaHQgYmUgYSBsb3dlcmNhc2UgdmVyc2lvbiBvZiB0aGVcclxuICAgIC8vIHJhdyBzdHJpbmdcclxuICAgICwgY29tcGFyZVN0cmluZyA9ICBvcHRzLmNhc2VTZW5zaXRpdmUgJiYgc3RyaW5nIHx8IHN0cmluZy50b0xvd2VyQ2FzZSgpXHJcbiAgICAsIGNoLCBjb21wYXJlQ2hhcjtcclxuXHJcbiAgcGF0dGVybiA9IG9wdHMuY2FzZVNlbnNpdGl2ZSAmJiBwYXR0ZXJuIHx8IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgLy8gRm9yIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcsIGVpdGhlciBhZGQgaXQgdG8gdGhlIHJlc3VsdFxyXG4gIC8vIG9yIHdyYXAgaW4gdGVtcGxhdGUgaWYgaXQncyB0aGUgbmV4dCBzdHJpbmcgaW4gdGhlIHBhdHRlcm5cclxuICBmb3IodmFyIGlkeCA9IDA7IGlkeCA8IGxlbjsgaWR4KyspIHtcclxuICAgIGNoID0gc3RyaW5nW2lkeF07XHJcbiAgICBpZihjb21wYXJlU3RyaW5nW2lkeF0gPT09IHBhdHRlcm5bcGF0dGVybklkeF0pIHtcclxuICAgICAgY2ggPSBwcmUgKyBjaCArIHBvc3Q7XHJcbiAgICAgIHBhdHRlcm5JZHggKz0gMTtcclxuXHJcbiAgICAgIC8vIGNvbnNlY3V0aXZlIGNoYXJhY3RlcnMgc2hvdWxkIGluY3JlYXNlIHRoZSBzY29yZSBtb3JlIHRoYW4gbGluZWFybHlcclxuICAgICAgY3VyclNjb3JlICs9IDEgKyBjdXJyU2NvcmU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdXJyU2NvcmUgPSAwO1xyXG4gICAgfVxyXG4gICAgdG90YWxTY29yZSArPSBjdXJyU2NvcmU7XHJcbiAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBjaDtcclxuICB9XHJcblxyXG4gIC8vIHJldHVybiByZW5kZXJlZCBzdHJpbmcgaWYgd2UgaGF2ZSBhIG1hdGNoIGZvciBldmVyeSBjaGFyXHJcbiAgaWYocGF0dGVybklkeCA9PT0gcGF0dGVybi5sZW5ndGgpIHtcclxuICAgIHJldHVybiB7cmVuZGVyZWQ6IHJlc3VsdC5qb2luKCcnKSwgc2NvcmU6IHRvdGFsU2NvcmV9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vLyBUaGUgbm9ybWFsIGVudHJ5IHBvaW50LiBGaWx0ZXJzIGBhcnJgIGZvciBtYXRjaGVzIGFnYWluc3QgYHBhdHRlcm5gLlxyXG4vLyBJdCByZXR1cm5zIGFuIGFycmF5IHdpdGggbWF0Y2hpbmcgdmFsdWVzIG9mIHRoZSB0eXBlOlxyXG4vL1xyXG4vLyAgICAgW3tcclxuLy8gICAgICAgICBzdHJpbmc6ICAgJzxiPmxhaCcgLy8gVGhlIHJlbmRlcmVkIHN0cmluZ1xyXG4vLyAgICAgICAsIGluZGV4OiAgICAyICAgICAgICAvLyBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gYGFycmBcclxuLy8gICAgICAgLCBvcmlnaW5hbDogJ2JsYWgnICAgLy8gVGhlIG9yaWdpbmFsIGVsZW1lbnQgaW4gYGFycmBcclxuLy8gICAgIH1dXHJcbi8vXHJcbi8vIGBvcHRzYCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCBiYWcuIERldGFpbHM6XHJcbi8vXHJcbi8vICAgIG9wdHMgPSB7XHJcbi8vICAgICAgICAvLyBzdHJpbmcgdG8gcHV0IGJlZm9yZSBhIG1hdGNoaW5nIGNoYXJhY3RlclxyXG4vLyAgICAgICAgcHJlOiAgICAgJzxiPidcclxuLy9cclxuLy8gICAgICAgIC8vIHN0cmluZyB0byBwdXQgYWZ0ZXIgbWF0Y2hpbmcgY2hhcmFjdGVyXHJcbi8vICAgICAgLCBwb3N0OiAgICAnPC9iPidcclxuLy9cclxuLy8gICAgICAgIC8vIE9wdGlvbmFsIGZ1bmN0aW9uLiBJbnB1dCBpcyBhbiBlbnRyeSBpbiB0aGUgZ2l2ZW4gYXJyYCxcclxuLy8gICAgICAgIC8vIG91dHB1dCBzaG91bGQgYmUgdGhlIHN0cmluZyB0byB0ZXN0IGBwYXR0ZXJuYCBhZ2FpbnN0LlxyXG4vLyAgICAgICAgLy8gSW4gdGhpcyBleGFtcGxlLCBpZiBgYXJyID0gW3tjcnlpbmc6ICdrb2FsYSd9XWAgd2Ugd291bGQgcmV0dXJuXHJcbi8vICAgICAgICAvLyAna29hbGEnLlxyXG4vLyAgICAgICwgZXh0cmFjdDogZnVuY3Rpb24oYXJnKSB7IHJldHVybiBhcmcuY3J5aW5nOyB9XHJcbi8vICAgIH1cclxuZnV6enkuZmlsdGVyID0gZnVuY3Rpb24ocGF0dGVybiwgYXJyLCBvcHRzKSB7XHJcbiAgb3B0cyA9IG9wdHMgfHwge307XHJcbiAgcmV0dXJuIGFyclxyXG4gICAgLnJlZHVjZShmdW5jdGlvbihwcmV2LCBlbGVtZW50LCBpZHgsIGFycikge1xyXG4gICAgICB2YXIgc3RyID0gZWxlbWVudDtcclxuICAgICAgaWYob3B0cy5leHRyYWN0KSB7XHJcbiAgICAgICAgc3RyID0gb3B0cy5leHRyYWN0KGVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciByZW5kZXJlZCA9IGZ1enp5Lm1hdGNoKHBhdHRlcm4sIHN0ciwgb3B0cyk7XHJcbiAgICAgIGlmKHJlbmRlcmVkICE9IG51bGwpIHtcclxuICAgICAgICBwcmV2W3ByZXYubGVuZ3RoXSA9IHtcclxuICAgICAgICAgICAgc3RyaW5nOiByZW5kZXJlZC5yZW5kZXJlZFxyXG4gICAgICAgICAgLCBzY29yZTogcmVuZGVyZWQuc2NvcmVcclxuICAgICAgICAgICwgaW5kZXg6IGlkeFxyXG4gICAgICAgICAgLCBvcmlnaW5hbDogZWxlbWVudFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICAvLyBTb3J0IGJ5IHNjb3JlLiBCcm93c2VycyBhcmUgaW5jb25zaXN0ZW50IHdydCBzdGFibGUvdW5zdGFibGVcclxuICAgIC8vIHNvcnRpbmcsIHNvIGZvcmNlIHN0YWJsZSBieSB1c2luZyB0aGUgaW5kZXggaW4gdGhlIGNhc2Ugb2YgdGllLlxyXG4gICAgLy8gU2VlIGh0dHA6Ly9vZmIubmV0L35zZXRobWwvaXMtc29ydC1zdGFibGUuaHRtbFxyXG4gICAgLnNvcnQoZnVuY3Rpb24oYSxiKSB7XHJcbiAgICAgIHZhciBjb21wYXJlID0gYi5zY29yZSAtIGEuc2NvcmU7XHJcbiAgICAgIGlmKGNvbXBhcmUpIHJldHVybiBjb21wYXJlO1xyXG4gICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblxyXG59KCkpO1xyXG5cclxuXHJcbn0se31dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ1VzZSBzdHJpY3QnO1xyXG5cclxudmFyIExpc3QgPSBmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICB0aGlzLml0ZW1zID0gW107XHJcbiAgdGhpcy5hY3RpdmUgPSAwO1xyXG4gIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XHJcbiAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9ICdzdWdnZXN0aW9ucyc7XHJcblxyXG4gIGNvbXBvbmVudC5lbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmVsZW1lbnQsIGNvbXBvbmVudC5lbC5uZXh0U2libGluZyk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5MaXN0LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG59O1xyXG5cclxuTGlzdC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG59O1xyXG5cclxuTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaXRlbSkge1xyXG4gIHRoaXMuaXRlbXMucHVzaChpdGVtKTtcclxufTtcclxuXHJcbkxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5pdGVtcyA9IFtdO1xyXG4gIHRoaXMuYWN0aXZlID0gMDtcclxufTtcclxuXHJcbkxpc3QucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gIXRoaXMuaXRlbXMubGVuZ3RoO1xyXG59O1xyXG5cclxuTGlzdC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSAnJztcclxuXHJcbiAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICB0aGlzLmhpZGUoKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdGhpcy5kcmF3SXRlbSh0aGlzLml0ZW1zW2ldLCB0aGlzLmFjdGl2ZSA9PT0gaSk7XHJcbiAgfVxyXG5cclxuICB0aGlzLnNob3coKTtcclxufTtcclxuXHJcbkxpc3QucHJvdG90eXBlLmRyYXdJdGVtID0gZnVuY3Rpb24oaXRlbSwgYWN0aXZlKSB7XHJcbiAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSxcclxuICAgIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcblxyXG4gIGlmIChhY3RpdmUpIGxpLmNsYXNzTmFtZSArPSAnIGFjdGl2ZSc7XHJcblxyXG4gIGEuaW5uZXJIVE1MID0gaXRlbS5zdHJpbmc7XHJcblxyXG4gIGxpLmFwcGVuZENoaWxkKGEpO1xyXG4gIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChsaSk7XHJcblxyXG4gIGxpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5oYW5kbGVNb3VzZURvd24uY2FsbCh0aGlzLCBpdGVtKTtcclxuICB9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cclxuTGlzdC5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24oaXRlbSkge1xyXG4gIHRoaXMuY29tcG9uZW50LnZhbHVlKGl0ZW0ub3JpZ2luYWwpO1xyXG4gIHRoaXMuY2xlYXIoKTtcclxuICB0aGlzLmRyYXcoKTtcclxufTtcclxuXHJcbkxpc3QucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihpbmRleCkge1xyXG4gIHRoaXMuYWN0aXZlID0gaW5kZXg7XHJcbiAgdGhpcy5kcmF3KCk7XHJcbn07XHJcblxyXG5MaXN0LnByb3RvdHlwZS5wcmV2aW91cyA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMubW92ZSh0aGlzLmFjdGl2ZSA9PT0gMCA/IHRoaXMuaXRlbXMubGVuZ3RoIC0gMSA6IHRoaXMuYWN0aXZlIC0gMSk7XHJcbn07XHJcblxyXG5MaXN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5tb3ZlKHRoaXMuYWN0aXZlID09PSB0aGlzLml0ZW1zLmxlbmd0aCAtIDEgPyAwIDogdGhpcy5hY3RpdmUgKyAxKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGlzdDtcclxuXHJcbn0se31dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJyk7XHJcbnZhciBmdXp6eSA9IHJlcXVpcmUoJ2Z1enp5Jyk7XHJcbnZhciBMaXN0ID0gcmVxdWlyZSgnLi9saXN0Jyk7XHJcblxyXG52YXIgU3VnZ2VzdGlvbnMgPSBmdW5jdGlvbihlbCwgZGF0YSwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe1xyXG4gICAgbWluTGVuZ3RoOiAyLFxyXG4gICAgbGltaXQ6IDUsXHJcbiAgICBmaWx0ZXI6IHRydWVcclxuICB9LCBvcHRpb25zKTtcclxuXHJcbiAgdGhpcy5lbCA9IGVsO1xyXG4gIHRoaXMuZGF0YSA9IGRhdGEgfHwgW107XHJcbiAgdGhpcy5saXN0ID0gbmV3IExpc3QodGhpcyk7XHJcblxyXG4gIHRoaXMucXVlcnkgPSAnJztcclxuICB0aGlzLnNlbGVjdGVkID0gbnVsbDtcclxuXHJcbiAgdGhpcy5saXN0LmRyYXcoKTtcclxuXHJcbiAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgIHRoaXMuaGFuZGxlS2V5VXAoZS5rZXlDb2RlKTtcclxuICB9LmJpbmQodGhpcyksIGZhbHNlKTtcclxuXHJcbiAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xyXG4gICAgdGhpcy5oYW5kbGVLZXlEb3duKGUpO1xyXG4gIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaGFuZGxlRm9jdXMoKTtcclxuICB9LmJpbmQodGhpcykpO1xyXG5cclxuICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaGFuZGxlQmx1cigpO1xyXG4gIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuU3VnZ2VzdGlvbnMucHJvdG90eXBlLmhhbmRsZUtleVVwID0gZnVuY3Rpb24oa2V5Q29kZSkge1xyXG4gIC8vIDQwIC0gRE9XTlxyXG4gIC8vIDM4IC0gVVBcclxuICAvLyAyNyAtIEVTQ1xyXG4gIC8vIDEzIC0gRU5URVJcclxuICAvLyA5IC0gVEFCXHJcblxyXG4gIGlmIChrZXlDb2RlID09PSA0MCB8fFxyXG4gICAgICBrZXlDb2RlID09PSAzOCB8fFxyXG4gICAgICBrZXlDb2RlID09PSAyNyB8fFxyXG4gICAgICBrZXlDb2RlID09PSAxMyB8fFxyXG4gICAgICBrZXlDb2RlID09PSA5KSByZXR1cm47XHJcblxyXG4gIHRoaXMucXVlcnkgPSB0aGlzLm5vcm1hbGl6ZSh0aGlzLmVsLnZhbHVlKTtcclxuXHJcbiAgdGhpcy5saXN0LmNsZWFyKCk7XHJcblxyXG4gIGlmICh0aGlzLnF1ZXJ5Lmxlbmd0aCA8IHRoaXMub3B0aW9ucy5taW5MZW5ndGgpIHtcclxuICAgIHRoaXMubGlzdC5kcmF3KCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB0aGlzLmdldENhbmRpZGF0ZXMoZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHRoaXMubGlzdC5hZGQoZGF0YVtpXSk7XHJcbiAgICAgIGlmIChpID09PSAodGhpcy5vcHRpb25zLmxpbWl0IC0gMSkpIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgdGhpcy5saXN0LmRyYXcoKTtcclxuICB9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cclxuU3VnZ2VzdGlvbnMucHJvdG90eXBlLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbihlKSB7XHJcbiAgc3dpdGNoIChlLmtleUNvZGUpIHtcclxuICAgIGNhc2UgMTM6IC8vIEVOVEVSXHJcbiAgICBjYXNlIDk6ICAvLyBUQUJcclxuICAgICAgaWYgKCF0aGlzLmxpc3QuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSh0aGlzLmxpc3QuaXRlbXNbdGhpcy5saXN0LmFjdGl2ZV0ub3JpZ2luYWwpO1xyXG4gICAgICAgIHRoaXMubGlzdC5oaWRlKCk7XHJcbiAgICAgIH1cclxuICAgIGJyZWFrO1xyXG4gICAgY2FzZSAyNzogLy8gRVNDXHJcbiAgICAgIGlmICghdGhpcy5saXN0LmlzRW1wdHkoKSkgdGhpcy5saXN0LmhpZGUoKTtcclxuICAgIGJyZWFrO1xyXG4gICAgY2FzZSAzODogLy8gVVBcclxuICAgICAgdGhpcy5saXN0LnByZXZpb3VzKCk7XHJcbiAgICBicmVhaztcclxuICAgIGNhc2UgNDA6IC8vIERPV05cclxuICAgICAgdGhpcy5saXN0Lm5leHQoKTtcclxuICAgIGJyZWFrO1xyXG4gIH1cclxufTtcclxuXHJcblN1Z2dlc3Rpb25zLnByb3RvdHlwZS5oYW5kbGVCbHVyID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5saXN0LmhpZGUoKTtcclxufTtcclxuXHJcblN1Z2dlc3Rpb25zLnByb3RvdHlwZS5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uKCkge1xyXG4gIGlmICghdGhpcy5saXN0LmlzRW1wdHkoKSkgdGhpcy5saXN0LnNob3coKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgZGF0YSBwcmV2aW91c2x5IHBhc3NlZFxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSByZXZpc2VkRGF0YVxyXG4gKi9cclxuU3VnZ2VzdGlvbnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHJldmlzZWREYXRhKSB7XHJcbiAgdGhpcy5kYXRhID0gcmV2aXNlZERhdGE7XHJcbiAgdGhpcy5saXN0LmRyYXcoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGVhcnMgZGF0YVxyXG4gKi9cclxuU3VnZ2VzdGlvbnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5kYXRhID0gW107XHJcbiAgdGhpcy5saXN0LmNsZWFyKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplIHRoZSByZXN1bHRzIGxpc3QgYW5kIGlucHV0IHZhbHVlIGZvciBtYXRjaGluZ1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuU3VnZ2VzdGlvbnMucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xyXG4gIHJldHVybiB2YWx1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFdmFsdWF0ZXMgd2hldGhlciBhbiBhcnJheSBpdGVtIHF1YWxpZmllcyBhcyBhIG1hdGNoIHdpdGggdGhlIGN1cnJlbnQgcXVlcnlcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGNhbmRpZGF0ZSBhIHBvc3NpYmxlIGl0ZW0gZnJvbSB0aGUgYXJyYXkgcGFzc2VkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSB0aGUgY3VycmVudCBxdWVyeVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuU3VnZ2VzdGlvbnMucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24oY2FuZGlkYXRlLCBxdWVyeSkge1xyXG4gIHJldHVybiBjYW5kaWRhdGUuaW5kZXhPZihxdWVyeSkgPiAtMTtcclxufTtcclxuXHJcblN1Z2dlc3Rpb25zLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgdGhpcy5zZWxlY3RlZCA9IHZhbHVlO1xyXG4gIHRoaXMuZWwudmFsdWUgPSB0aGlzLmdldEl0ZW1WYWx1ZSh2YWx1ZSk7XHJcblxyXG4gIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xyXG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xyXG4gICAgZS5pbml0RXZlbnQoJ2NoYW5nZScsIHRydWUsIGZhbHNlKTtcclxuICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5lbC5maXJlRXZlbnQoJ29uY2hhbmdlJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuU3VnZ2VzdGlvbnMucHJvdG90eXBlLmdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gIHZhciBvcHRpb25zID0ge1xyXG4gICAgcHJlOiAnPHN0cm9uZz4nLFxyXG4gICAgcG9zdDogJzwvc3Ryb25nPicsXHJcbiAgICBleHRyYWN0OiBmdW5jdGlvbihkKSB7IHJldHVybiB0aGlzLmdldEl0ZW1WYWx1ZShkKTsgfS5iaW5kKHRoaXMpXHJcbiAgfTtcclxuXHJcbiAgdmFyIHJlc3VsdHMgPSB0aGlzLm9wdGlvbnMuZmlsdGVyID9cclxuICAgIGZ1enp5LmZpbHRlcih0aGlzLnF1ZXJ5LCB0aGlzLmRhdGEsIG9wdGlvbnMpIDpcclxuICAgIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG9yaWdpbmFsOiBkLFxyXG4gICAgICAgIHN0cmluZzogdGhpcy5nZXRJdGVtVmFsdWUoZCkucmVwbGFjZShuZXcgUmVnRXhwKCcoJyArIHRoaXMucXVlcnkgKyAnKScsICdpZycpLCBmdW5jdGlvbigkMSwgbWF0Y2gpIHtcclxuICAgICAgICAgIHJldHVybiAnPHN0cm9uZz4nICsgbWF0Y2ggKyAnPC9zdHJvbmc+JztcclxuICAgICAgICB9KVxyXG4gICAgICB9O1xyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgY2FsbGJhY2socmVzdWx0cyk7XHJcbn07XHJcblxyXG4vKipcclxuICogRm9yIGEgZ2l2ZW4gaXRlbSBpbiB0aGUgZGF0YSBhcnJheSwgcmV0dXJuIHdoYXQgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGNhbmRpZGF0ZSBzdHJpbmdcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpdGVtIGFuIGl0ZW0gZnJvbSB0aGUgZGF0YSBhcnJheVxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGl0ZW1cclxuICovXHJcblN1Z2dlc3Rpb25zLnByb3RvdHlwZS5nZXRJdGVtVmFsdWUgPSBmdW5jdGlvbihpdGVtKSB7XHJcbiAgcmV0dXJuIGl0ZW07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN1Z2dlc3Rpb25zO1xyXG5cclxufSx7XCIuL2xpc3RcIjoyOCxcImZ1enp5XCI6MjcsXCJ4dGVuZFwiOjMyfV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG52YXIgZWFjaCA9IHJlcXVpcmUoJ3R1cmYtbWV0YScpLmNvb3JkRWFjaDtcclxuXHJcbi8qKlxyXG4gKiBUYWtlcyBhbnkge0BsaW5rIEdlb0pTT059IG9iamVjdCwgY2FsY3VsYXRlcyB0aGUgZXh0ZW50IG9mIGFsbCBpbnB1dCBmZWF0dXJlcywgYW5kIHJldHVybnMgYSBib3VuZGluZyBib3guXHJcbiAqXHJcbiAqIEBtb2R1bGUgdHVyZi9leHRlbnRcclxuICogQGNhdGVnb3J5IG1lYXN1cmVtZW50XHJcbiAqIEBwYXJhbSB7R2VvSlNPTn0gaW5wdXQgYW55IHZhbGlkIEdlb0pTT04gT2JqZWN0XHJcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IHRoZSBib3VuZGluZyBib3ggb2YgYGlucHV0YCBnaXZlblxyXG4gKiBhcyBhbiBhcnJheSBpbiBXU0VOIG9yZGVyICh3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGgpXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBpbnB1dCA9IHtcclxuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxyXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xyXG4gKiAgICAge1xyXG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXHJcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcclxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XHJcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcclxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMTQuMTc1MzI5LCAyMi4yNTI0XVxyXG4gKiAgICAgICB9XHJcbiAqICAgICB9LCB7XHJcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcclxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxyXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcclxuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxyXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzExNC4xNzAwMDcsIDIyLjI2Nzk2OV1cclxuICogICAgICAgfVxyXG4gKiAgICAgfSwge1xyXG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXHJcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcclxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XHJcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcclxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMTQuMjAwNjQ5LCAyMi4yNzQ2NDFdXHJcbiAqICAgICAgIH1cclxuICogICAgIH0sIHtcclxuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxyXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXHJcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xyXG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXHJcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTE0LjE4Njc0NCwgMjIuMjY1NzQ1XVxyXG4gKiAgICAgICB9XHJcbiAqICAgICB9XHJcbiAqICAgXVxyXG4gKiB9O1xyXG4gKlxyXG4gKiB2YXIgYmJveCA9IHR1cmYuZXh0ZW50KGlucHV0KTtcclxuICpcclxuICogdmFyIGJib3hQb2x5Z29uID0gdHVyZi5iYm94UG9seWdvbihiYm94KTtcclxuICpcclxuICogdmFyIHJlc3VsdEZlYXR1cmVzID0gaW5wdXQuZmVhdHVyZXMuY29uY2F0KGJib3hQb2x5Z29uKTtcclxuICogdmFyIHJlc3VsdCA9IHtcclxuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxyXG4gKiAgIFwiZmVhdHVyZXNcIjogcmVzdWx0RmVhdHVyZXNcclxuICogfTtcclxuICpcclxuICogLy89cmVzdWx0XHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxheWVyKSB7XHJcbiAgICB2YXIgZXh0ZW50ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xyXG4gICAgZWFjaChsYXllciwgZnVuY3Rpb24oY29vcmQpIHtcclxuICAgICAgaWYgKGV4dGVudFswXSA+IGNvb3JkWzBdKSBleHRlbnRbMF0gPSBjb29yZFswXTtcclxuICAgICAgaWYgKGV4dGVudFsxXSA+IGNvb3JkWzFdKSBleHRlbnRbMV0gPSBjb29yZFsxXTtcclxuICAgICAgaWYgKGV4dGVudFsyXSA8IGNvb3JkWzBdKSBleHRlbnRbMl0gPSBjb29yZFswXTtcclxuICAgICAgaWYgKGV4dGVudFszXSA8IGNvb3JkWzFdKSBleHRlbnRbM10gPSBjb29yZFsxXTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGV4dGVudDtcclxufTtcclxuXHJcbn0se1widHVyZi1tZXRhXCI6MzF9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qKlxyXG4gKiBMYXppbHkgaXRlcmF0ZSBvdmVyIGNvb3JkaW5hdGVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0b1xyXG4gKiBBcnJheS5mb3JFYWNoLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHZhbHVlKVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlV3JhcENvb3JkIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGVcclxuICogdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgcG9pbnQgPSB7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBbMCwgMF0gfTtcclxuICogY29vcmRFYWNoKHBvaW50LCBmdW5jdGlvbihjb29yZHMpIHtcclxuICogICAvLyBjb29yZHMgaXMgZXF1YWwgdG8gWzAsIDBdXHJcbiAqIH0pO1xyXG4gKi9cclxuZnVuY3Rpb24gY29vcmRFYWNoKGxheWVyLCBjYWxsYmFjaywgZXhjbHVkZVdyYXBDb29yZCkge1xyXG4gIHZhciBpLCBqLCBrLCBnLCBnZW9tZXRyeSwgc3RvcEcsIGNvb3JkcyxcclxuICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLFxyXG4gICAgd3JhcFNocmluayA9IDAsXHJcbiAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbixcclxuICAgIGlzRmVhdHVyZUNvbGxlY3Rpb24gPSBsYXllci50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG4gICAgaXNGZWF0dXJlID0gbGF5ZXIudHlwZSA9PT0gJ0ZlYXR1cmUnLFxyXG4gICAgc3RvcCA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBsYXllci5mZWF0dXJlcy5sZW5ndGggOiAxO1xyXG5cclxuICAvLyBUaGlzIGxvZ2ljIG1heSBsb29rIGEgbGl0dGxlIHdlaXJkLiBUaGUgcmVhc29uIHdoeSBpdCBpcyB0aGF0IHdheVxyXG4gIC8vIGlzIGJlY2F1c2UgaXQncyB0cnlpbmcgdG8gYmUgZmFzdC4gR2VvSlNPTiBzdXBwb3J0cyBtdWx0aXBsZSBraW5kc1xyXG4gIC8vIG9mIG9iamVjdHMgYXQgaXRzIHJvb3Q6IEZlYXR1cmVDb2xsZWN0aW9uLCBGZWF0dXJlcywgR2VvbWV0cmllcy5cclxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgaGFuZGxpbmcgYWxsIG9mIHRoZW0sIGFuZCB0aGF0XHJcbiAgLy8gbWVhbnMgdGhhdCBzb21lIG9mIHRoZSBgZm9yYCBsb29wcyB5b3Ugc2VlIGJlbG93IGFjdHVhbGx5IGp1c3QgZG9uJ3QgYXBwbHlcclxuICAvLyB0byBjZXJ0YWluIGlucHV0cy4gRm9yIGluc3RhbmNlLCBpZiB5b3UgZ2l2ZSB0aGlzIGp1c3QgYVxyXG4gIC8vIFBvaW50IGdlb21ldHJ5LCB0aGVuIGJvdGggbG9vcHMgYXJlIHNob3J0LWNpcmN1aXRlZCBhbmQgYWxsIHdlIGRvXHJcbiAgLy8gaXMgZ3JhZHVhbGx5IHJlbmFtZSB0aGUgaW5wdXQgdW50aWwgaXQncyBjYWxsZWQgJ2dlb21ldHJ5Jy5cclxuICAvL1xyXG4gIC8vIFRoaXMgYWxzbyBhaW1zIHRvIGFsbG9jYXRlIGFzIGZldyByZXNvdXJjZXMgYXMgcG9zc2libGU6IGp1c3QgYVxyXG4gIC8vIGZldyBudW1iZXJzIGFuZCBib29sZWFucywgcmF0aGVyIHRoYW4gYW55IHRlbXBvcmFyeSBhcnJheXMgYXMgd291bGRcclxuICAvLyBiZSByZXF1aXJlZCB3aXRoIHRoZSBub3JtYWxpemF0aW9uIGFwcHJvYWNoLlxyXG4gIGZvciAoaSA9IDA7IGkgPCBzdG9wOyBpKyspIHtcclxuXHJcbiAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbiA9IChpc0ZlYXR1cmVDb2xsZWN0aW9uID8gbGF5ZXIuZmVhdHVyZXNbaV0uZ2VvbWV0cnkgOlxyXG4gICAgICAgIChpc0ZlYXR1cmUgPyBsYXllci5nZW9tZXRyeSA6IGxheWVyKSk7XHJcbiAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLnR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nO1xyXG4gICAgc3RvcEcgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXMubGVuZ3RoIDogMTtcclxuXHJcbiAgICBmb3IgKGcgPSAwOyBnIDwgc3RvcEc7IGcrKykge1xyXG5cclxuICAgICAgZ2VvbWV0cnkgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/XHJcbiAgICAgICAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzW2ddIDogZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb247XHJcbiAgICAgIGNvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xyXG5cclxuICAgICAgd3JhcFNocmluayA9IChleGNsdWRlV3JhcENvb3JkICYmXHJcbiAgICAgICAgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyB8fCBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykpID9cclxuICAgICAgICAxIDogMDtcclxuXHJcbiAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XHJcbiAgICAgICAgY2FsbGJhY2soY29vcmRzKTtcclxuICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykgY2FsbGJhY2soY29vcmRzW2pdKTtcclxuICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycpIHtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKVxyXG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvb3Jkc1tqXS5sZW5ndGggLSB3cmFwU2hyaW5rOyBrKyspXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGNvb3Jkc1tqXVtrXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKVxyXG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvb3Jkc1tqXS5sZW5ndGg7IGsrKylcclxuICAgICAgICAgICAgZm9yIChsID0gMDsgbCA8IGNvb3Jkc1tqXVtrXS5sZW5ndGggLSB3cmFwU2hyaW5rOyBsKyspXHJcbiAgICAgICAgICAgICAgY2FsbGJhY2soY29vcmRzW2pdW2tdW2xdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gR2VvbWV0cnkgVHlwZScpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbm1vZHVsZS5leHBvcnRzLmNvb3JkRWFjaCA9IGNvb3JkRWFjaDtcclxuXHJcbi8qKlxyXG4gKiBMYXppbHkgcmVkdWNlIGNvb3JkaW5hdGVzIGluIGFueSBHZW9KU09OIG9iamVjdCBpbnRvIGEgc2luZ2xlIHZhbHVlLFxyXG4gKiBzaW1pbGFyIHRvIGhvdyBBcnJheS5yZWR1Y2Ugd29ya3MuIEhvd2V2ZXIsIGluIHRoaXMgY2FzZSB3ZSBsYXppbHkgcnVuXHJcbiAqIHRoZSByZWR1Y3Rpb24sIHNvIGFuIGFycmF5IG9mIGFsbCBjb29yZGluYXRlcyBpcyB1bm5lY2Vzc2FyeS5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGFueSBHZW9KU09OIG9iamVjdFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChtZW1vLCB2YWx1ZSkgYW5kIHJldHVybnNcclxuICogYSBuZXcgbWVtb1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlV3JhcENvb3JkIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGVcclxuICogdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxyXG4gKiBAcGFyYW0geyp9IG1lbW8gdGhlIHN0YXJ0aW5nIHZhbHVlIG9mIG1lbW86IGNhbiBiZSBhbnkgdHlwZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvb3JkUmVkdWNlKGxheWVyLCBjYWxsYmFjaywgbWVtbywgZXhjbHVkZVdyYXBDb29yZCkge1xyXG4gIGNvb3JkRWFjaChsYXllciwgZnVuY3Rpb24oY29vcmQpIHtcclxuICAgIG1lbW8gPSBjYWxsYmFjayhtZW1vLCBjb29yZCk7XHJcbiAgfSwgZXhjbHVkZVdyYXBDb29yZCk7XHJcbiAgcmV0dXJuIG1lbW87XHJcbn1cclxubW9kdWxlLmV4cG9ydHMuY29vcmRSZWR1Y2UgPSBjb29yZFJlZHVjZTtcclxuXHJcbi8qKlxyXG4gKiBMYXppbHkgaXRlcmF0ZSBvdmVyIHByb3BlcnR5IG9iamVjdHMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvXHJcbiAqIEFycmF5LmZvckVhY2guXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAodmFsdWUpXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBwb2ludCA9IHsgdHlwZTogJ0ZlYXR1cmUnLCBnZW9tZXRyeTogbnVsbCwgcHJvcGVydGllczogeyBmb286IDEgfSB9O1xyXG4gKiBwcm9wRWFjaChwb2ludCwgZnVuY3Rpb24ocHJvcHMpIHtcclxuICogICAvLyBwcm9wcyBpcyBlcXVhbCB0byB7IGZvbzogMX1cclxuICogfSk7XHJcbiAqL1xyXG5mdW5jdGlvbiBwcm9wRWFjaChsYXllciwgY2FsbGJhY2spIHtcclxuICB2YXIgaTtcclxuICBzd2l0Y2ggKGxheWVyLnR5cGUpIHtcclxuICAgICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxyXG4gICAgICAgIGZlYXR1cmVzID0gbGF5ZXIuZmVhdHVyZXM7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxheWVyLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGxheWVyLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnRmVhdHVyZSc6XHJcbiAgICAgICAgY2FsbGJhY2sobGF5ZXIucHJvcGVydGllcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgfVxyXG59XHJcbm1vZHVsZS5leHBvcnRzLnByb3BFYWNoID0gcHJvcEVhY2g7XHJcblxyXG4vKipcclxuICogTGF6aWx5IHJlZHVjZSBwcm9wZXJ0aWVzIGluIGFueSBHZW9KU09OIG9iamVjdCBpbnRvIGEgc2luZ2xlIHZhbHVlLFxyXG4gKiBzaW1pbGFyIHRvIGhvdyBBcnJheS5yZWR1Y2Ugd29ya3MuIEhvd2V2ZXIsIGluIHRoaXMgY2FzZSB3ZSBsYXppbHkgcnVuXHJcbiAqIHRoZSByZWR1Y3Rpb24sIHNvIGFuIGFycmF5IG9mIGFsbCBwcm9wZXJ0aWVzIGlzIHVubmVjZXNzYXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKG1lbW8sIGNvb3JkKSBhbmQgcmV0dXJuc1xyXG4gKiBhIG5ldyBtZW1vXHJcbiAqIEBwYXJhbSB7Kn0gbWVtbyB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgbWVtbzogY2FuIGJlIGFueSB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gcHJvcFJlZHVjZShsYXllciwgY2FsbGJhY2ssIG1lbW8pIHtcclxuICBwcm9wRWFjaChsYXllciwgZnVuY3Rpb24ocHJvcCkge1xyXG4gICAgbWVtbyA9IGNhbGxiYWNrKG1lbW8sIHByb3ApO1xyXG4gIH0pO1xyXG4gIHJldHVybiBtZW1vO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzLnByb3BSZWR1Y2UgPSBwcm9wUmVkdWNlO1xyXG5cclxufSx7fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxyXG5cclxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbmZ1bmN0aW9uIGV4dGVuZCgpIHtcclxuICAgIHZhciB0YXJnZXQgPSB7fVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxyXG5cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YXJnZXRcclxufVxyXG5cclxufSx7fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5xdWVyeU9yaWdpbiA9IHF1ZXJ5T3JpZ2luO1xyXG5leHBvcnRzLnF1ZXJ5RGVzdGluYXRpb24gPSBxdWVyeURlc3RpbmF0aW9uO1xyXG5leHBvcnRzLnF1ZXJ5T3JpZ2luQ29vcmRpbmF0ZXMgPSBxdWVyeU9yaWdpbkNvb3JkaW5hdGVzO1xyXG5leHBvcnRzLnF1ZXJ5RGVzdGluYXRpb25Db29yZGluYXRlcyA9IHF1ZXJ5RGVzdGluYXRpb25Db29yZGluYXRlcztcclxuZXhwb3J0cy5jbGVhck9yaWdpbiA9IGNsZWFyT3JpZ2luO1xyXG5leHBvcnRzLmNsZWFyRGVzdGluYXRpb24gPSBjbGVhckRlc3RpbmF0aW9uO1xyXG5leHBvcnRzLnNldE9wdGlvbnMgPSBzZXRPcHRpb25zO1xyXG5leHBvcnRzLmhvdmVyTWFya2VyID0gaG92ZXJNYXJrZXI7XHJcbmV4cG9ydHMuc2V0Um91dGVJbmRleCA9IHNldFJvdXRlSW5kZXg7XHJcbmV4cG9ydHMuY3JlYXRlT3JpZ2luID0gY3JlYXRlT3JpZ2luO1xyXG5leHBvcnRzLmNyZWF0ZURlc3RpbmF0aW9uID0gY3JlYXRlRGVzdGluYXRpb247XHJcbmV4cG9ydHMuc2V0UHJvZmlsZSA9IHNldFByb2ZpbGU7XHJcbmV4cG9ydHMucmV2ZXJzZSA9IHJldmVyc2U7XHJcbmV4cG9ydHMuc2V0T3JpZ2luRnJvbUNvb3JkaW5hdGVzID0gc2V0T3JpZ2luRnJvbUNvb3JkaW5hdGVzO1xyXG5leHBvcnRzLnNldERlc3RpbmF0aW9uRnJvbUNvb3JkaW5hdGVzID0gc2V0RGVzdGluYXRpb25Gcm9tQ29vcmRpbmF0ZXM7XHJcbmV4cG9ydHMuYWRkV2F5cG9pbnQgPSBhZGRXYXlwb2ludDtcclxuZXhwb3J0cy5zZXRXYXlwb2ludCA9IHNldFdheXBvaW50O1xyXG5leHBvcnRzLnJlbW92ZVdheXBvaW50ID0gcmVtb3ZlV2F5cG9pbnQ7XHJcbmV4cG9ydHMuZXZlbnRTdWJzY3JpYmUgPSBldmVudFN1YnNjcmliZTtcclxuZXhwb3J0cy5ldmVudEVtaXQgPSBldmVudEVtaXQ7XHJcblxyXG52YXIgX2FjdGlvbl90eXBlcyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9hY3Rpb25fdHlwZXMnKTtcclxuXHJcbnZhciB0eXBlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9hY3Rpb25fdHlwZXMpO1xyXG5cclxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcblxyXG52YXIgX3V0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxyXG5cclxudmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcbmZ1bmN0aW9uIG9yaWdpblBvaW50KGNvb3JkaW5hdGVzKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xyXG4gICAgdmFyIG9yaWdpbiA9IF91dGlsczIuZGVmYXVsdC5jcmVhdGVQb2ludChjb29yZGluYXRlcywge1xyXG4gICAgICBpZDogJ29yaWdpbicsXHJcbiAgICAgICdtYXJrZXItc3ltYm9sJzogJ0EnXHJcbiAgICB9KTtcclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6IHR5cGVzLk9SSUdJTiwgb3JpZ2luOiBvcmlnaW4gfSk7XHJcbiAgICBkaXNwYXRjaChldmVudEVtaXQoJ29yaWdpbicsIHsgZmVhdHVyZTogb3JpZ2luIH0pKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXN0aW5hdGlvblBvaW50KGNvb3JkaW5hdGVzKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xyXG4gICAgdmFyIGRlc3RpbmF0aW9uID0gX3V0aWxzMi5kZWZhdWx0LmNyZWF0ZVBvaW50KGNvb3JkaW5hdGVzLCB7XHJcbiAgICAgIGlkOiAnZGVzdGluYXRpb24nLFxyXG4gICAgICAnbWFya2VyLXN5bWJvbCc6ICdCJ1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiB0eXBlcy5ERVNUSU5BVElPTiwgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uIH0pO1xyXG4gICAgZGlzcGF0Y2goZXZlbnRFbWl0KCdkZXN0aW5hdGlvbicsIHsgZmVhdHVyZTogZGVzdGluYXRpb24gfSkpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldERpcmVjdGlvbnMoZGlyZWN0aW9ucykge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcclxuICAgIGRpc3BhdGNoKHtcclxuICAgICAgdHlwZTogdHlwZXMuRElSRUNUSU9OUyxcclxuICAgICAgZGlyZWN0aW9uczogZGlyZWN0aW9uc1xyXG4gICAgfSk7XHJcbiAgICBkaXNwYXRjaChldmVudEVtaXQoJ3JvdXRlJywgeyByb3V0ZTogZGlyZWN0aW9ucyB9KSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlV2F5cG9pbnRzKHdheXBvaW50cykge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiB0eXBlcy5XQVlQT0lOVFMsXHJcbiAgICB3YXlwb2ludHM6IHdheXBvaW50c1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEhvdmVyTWFya2VyKGZlYXR1cmUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogdHlwZXMuSE9WRVJfTUFSS0VSLFxyXG4gICAgaG92ZXJNYXJrZXI6IGZlYXR1cmVcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmZXRjaERpcmVjdGlvbnMoKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUpIHtcclxuICAgIHZhciBfZ2V0U3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG5cclxuICAgIHZhciBhcGkgPSBfZ2V0U3RhdGUuYXBpO1xyXG4gICAgdmFyIGFjY2Vzc1Rva2VuID0gX2dldFN0YXRlLmFjY2Vzc1Rva2VuO1xyXG4gICAgdmFyIHJvdXRlSW5kZXggPSBfZ2V0U3RhdGUucm91dGVJbmRleDtcclxuICAgIHZhciBwcm9maWxlID0gX2dldFN0YXRlLnByb2ZpbGU7XHJcblxyXG4gICAgdmFyIHF1ZXJ5ID0gYnVpbGREaXJlY3Rpb25zUXVlcnkoZ2V0U3RhdGUpO1xyXG5cclxuICAgIC8vIFJlcXVlc3QgcGFyYW1zXHJcbiAgICB2YXIgb3B0aW9ucyA9IFtdO1xyXG4gICAgb3B0aW9ucy5wdXNoKCdnZW9tZXRyaWVzPXBvbHlsaW5lJyk7XHJcbiAgICBvcHRpb25zLnB1c2goJ2FsdGVybmF0aXZlcz10cnVlJyk7XHJcbiAgICBvcHRpb25zLnB1c2goJ3N0ZXBzPXRydWUnKTtcclxuICAgIG9wdGlvbnMucHVzaCgnb3ZlcnZpZXc9ZnVsbCcpO1xyXG4gICAgb3B0aW9ucy5wdXNoKCdhY2Nlc3NfdG9rZW49JyArIGFjY2Vzc1Rva2VuKTtcclxuICAgIHJlcXVlc3QuYWJvcnQoKTtcclxuICAgIHJlcXVlc3Qub3BlbignR0VUJywgYXBpICsgJ21hcGJveC8nICsgcHJvZmlsZSArICcvJyArIHF1ZXJ5ICsgJy5qc29uPycgKyBvcHRpb25zLmpvaW4oJyYnKSwgdHJ1ZSk7XHJcblxyXG4gICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA+PSAyMDAgJiYgcmVxdWVzdC5zdGF0dXMgPCA0MDApIHtcclxuICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgIGlmIChkYXRhLmVycm9yKSB7XHJcbiAgICAgICAgICBkaXNwYXRjaChzZXREaXJlY3Rpb25zKFtdKSk7XHJcbiAgICAgICAgICByZXR1cm4gZGlzcGF0Y2goc2V0RXJyb3IoZGF0YS5lcnJvcikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGlzcGF0Y2goc2V0RXJyb3IobnVsbCkpO1xyXG4gICAgICAgIGlmICghZGF0YS5yb3V0ZXNbcm91dGVJbmRleF0pIGRpc3BhdGNoKHNldFJvdXRlSW5kZXgoMCkpO1xyXG4gICAgICAgIGRpc3BhdGNoKHNldERpcmVjdGlvbnMoZGF0YS5yb3V0ZXMpKTtcclxuXHJcbiAgICAgICAgLy8gUmV2aXNlIG9yaWdpbiAvIGRlc3RpbmF0aW9uIHBvaW50c1xyXG4gICAgICAgIGRpc3BhdGNoKG9yaWdpblBvaW50KGRhdGEud2F5cG9pbnRzWzBdLmxvY2F0aW9uKSk7XHJcbiAgICAgICAgZGlzcGF0Y2goZGVzdGluYXRpb25Qb2ludChkYXRhLndheXBvaW50c1tkYXRhLndheXBvaW50cy5sZW5ndGggLSAxXS5sb2NhdGlvbikpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRpc3BhdGNoKHNldERpcmVjdGlvbnMoW10pKTtcclxuICAgICAgICByZXR1cm4gZGlzcGF0Y2goc2V0RXJyb3IoSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCkubWVzc2FnZSkpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgZGlzcGF0Y2goc2V0RGlyZWN0aW9ucyhbXSkpO1xyXG4gICAgICByZXR1cm4gZGlzcGF0Y2goc2V0RXJyb3IoSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCkubWVzc2FnZSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXF1ZXN0LnNlbmQoKTtcclxuICB9O1xyXG59XHJcblxyXG4vKlxyXG4gKiBCdWlsZCBxdWVyeSB1c2VkIHRvIGZldGNoIGRpcmVjdGlvbnNcclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RhdGVcclxuICovXHJcbmZ1bmN0aW9uIGJ1aWxkRGlyZWN0aW9uc1F1ZXJ5KHN0YXRlKSB7XHJcbiAgdmFyIF9zdGF0ZSA9IHN0YXRlKCk7XHJcblxyXG4gIHZhciBvcmlnaW4gPSBfc3RhdGUub3JpZ2luO1xyXG4gIHZhciBkZXN0aW5hdGlvbiA9IF9zdGF0ZS5kZXN0aW5hdGlvbjtcclxuICB2YXIgd2F5cG9pbnRzID0gX3N0YXRlLndheXBvaW50cztcclxuXHJcblxyXG4gIHZhciBxdWVyeSA9IFtdO1xyXG4gIHF1ZXJ5LnB1c2gob3JpZ2luLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmpvaW4oJywnKSk7XHJcbiAgcXVlcnkucHVzaCgnOycpO1xyXG5cclxuICAvLyBBZGQgYW55IHdheXBvaW50cy5cclxuICBpZiAod2F5cG9pbnRzLmxlbmd0aCkge1xyXG4gICAgd2F5cG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHdheXBvaW50KSB7XHJcbiAgICAgIHF1ZXJ5LnB1c2god2F5cG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuam9pbignLCcpKTtcclxuICAgICAgcXVlcnkucHVzaCgnOycpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBxdWVyeS5wdXNoKGRlc3RpbmF0aW9uLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmpvaW4oJywnKSk7XHJcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChxdWVyeS5qb2luKCcnKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVdheXBvaW50KHdheXBvaW50KSB7XHJcbiAgdmFyIHByb3BlcnRpZXMgPSB7IGlkOiAnd2F5cG9pbnQnIH07XHJcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24od2F5cG9pbnQsIHtcclxuICAgIHByb3BlcnRpZXM6IHdheXBvaW50LnByb3BlcnRpZXMgPyBPYmplY3QuYXNzaWduKHdheXBvaW50LnByb3BlcnRpZXMsIHByb3BlcnRpZXMpIDogcHJvcGVydGllc1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRFcnJvcihlcnJvcikge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcclxuICAgIGRpc3BhdGNoKHtcclxuICAgICAgdHlwZTogJ0VSUk9SJyxcclxuICAgICAgZXJyb3I6IGVycm9yXHJcbiAgICB9KTtcclxuICAgIGlmIChlcnJvcikgZGlzcGF0Y2goZXZlbnRFbWl0KCdlcnJvcicsIHsgZXJyb3I6IGVycm9yIH0pKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdWVyeU9yaWdpbihxdWVyeSkge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiB0eXBlcy5PUklHSU5fUVVFUlksXHJcbiAgICBxdWVyeTogcXVlcnlcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdWVyeURlc3RpbmF0aW9uKHF1ZXJ5KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IHR5cGVzLkRFU1RJTkFUSU9OX1FVRVJZLFxyXG4gICAgcXVlcnk6IHF1ZXJ5XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVlcnlPcmlnaW5Db29yZGluYXRlcyhjb29yZHMpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogdHlwZXMuT1JJR0lOX0ZST01fQ09PUkRJTkFURVMsXHJcbiAgICBjb29yZGluYXRlczogY29vcmRzXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVlcnlEZXN0aW5hdGlvbkNvb3JkaW5hdGVzKGNvb3Jkcykge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiB0eXBlcy5ERVNUSU5BVElPTl9GUk9NX0NPT1JESU5BVEVTLFxyXG4gICAgY29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsZWFyT3JpZ2luKCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcclxuICAgIGRpc3BhdGNoKHtcclxuICAgICAgdHlwZTogdHlwZXMuT1JJR0lOX0NMRUFSXHJcbiAgICB9KTtcclxuICAgIGRpc3BhdGNoKGV2ZW50RW1pdCgnY2xlYXInLCB7IHR5cGU6ICdvcmlnaW4nIH0pKTtcclxuICAgIGRpc3BhdGNoKHNldEVycm9yKG51bGwpKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjbGVhckRlc3RpbmF0aW9uKCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcclxuICAgIGRpc3BhdGNoKHtcclxuICAgICAgdHlwZTogdHlwZXMuREVTVElOQVRJT05fQ0xFQVJcclxuICAgIH0pO1xyXG4gICAgZGlzcGF0Y2goZXZlbnRFbWl0KCdjbGVhcicsIHsgdHlwZTogJ2Rlc3RpbmF0aW9uJyB9KSk7XHJcbiAgICBkaXNwYXRjaChzZXRFcnJvcihudWxsKSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IHR5cGVzLlNFVF9PUFRJT05TLFxyXG4gICAgb3B0aW9uczogb3B0aW9uc1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhvdmVyTWFya2VyKGNvb3JkaW5hdGVzKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xyXG4gICAgdmFyIGZlYXR1cmUgPSBjb29yZGluYXRlcyA/IF91dGlsczIuZGVmYXVsdC5jcmVhdGVQb2ludChjb29yZGluYXRlcywgeyBpZDogJ2hvdmVyJyB9KSA6IHt9O1xyXG4gICAgZGlzcGF0Y2goc2V0SG92ZXJNYXJrZXIoZmVhdHVyZSkpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFJvdXRlSW5kZXgocm91dGVJbmRleCkge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiB0eXBlcy5ST1VURV9JTkRFWCxcclxuICAgIHJvdXRlSW5kZXg6IHJvdXRlSW5kZXhcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVPcmlnaW4oY29vcmRpbmF0ZXMpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgdmFyIF9nZXRTdGF0ZTIgPSBnZXRTdGF0ZSgpO1xyXG5cclxuICAgIHZhciBkZXN0aW5hdGlvbiA9IF9nZXRTdGF0ZTIuZGVzdGluYXRpb247XHJcblxyXG4gICAgZGlzcGF0Y2gob3JpZ2luUG9pbnQoY29vcmRpbmF0ZXMpKTtcclxuICAgIGlmIChkZXN0aW5hdGlvbi5nZW9tZXRyeSkgZGlzcGF0Y2goZmV0Y2hEaXJlY3Rpb25zKCkpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZURlc3RpbmF0aW9uKGNvb3JkaW5hdGVzKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUpIHtcclxuICAgIHZhciBfZ2V0U3RhdGUzID0gZ2V0U3RhdGUoKTtcclxuXHJcbiAgICB2YXIgb3JpZ2luID0gX2dldFN0YXRlMy5vcmlnaW47XHJcblxyXG4gICAgZGlzcGF0Y2goZGVzdGluYXRpb25Qb2ludChjb29yZGluYXRlcykpO1xyXG4gICAgaWYgKG9yaWdpbi5nZW9tZXRyeSkgZGlzcGF0Y2goZmV0Y2hEaXJlY3Rpb25zKCkpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFByb2ZpbGUocHJvZmlsZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIGdldFN0YXRlKSB7XHJcbiAgICB2YXIgX2dldFN0YXRlNCA9IGdldFN0YXRlKCk7XHJcblxyXG4gICAgdmFyIG9yaWdpbiA9IF9nZXRTdGF0ZTQub3JpZ2luO1xyXG4gICAgdmFyIGRlc3RpbmF0aW9uID0gX2dldFN0YXRlNC5kZXN0aW5hdGlvbjtcclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6IHR5cGVzLkRJUkVDVElPTlNfUFJPRklMRSwgcHJvZmlsZTogcHJvZmlsZSB9KTtcclxuICAgIGRpc3BhdGNoKGV2ZW50RW1pdCgncHJvZmlsZScsIHsgcHJvZmlsZTogcHJvZmlsZSB9KSk7XHJcbiAgICBpZiAob3JpZ2luLmdlb21ldHJ5ICYmIGRlc3RpbmF0aW9uLmdlb21ldHJ5KSBkaXNwYXRjaChmZXRjaERpcmVjdGlvbnMoKSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmV2ZXJzZSgpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoKTtcclxuICAgIGlmIChzdGF0ZS5kZXN0aW5hdGlvbi5nZW9tZXRyeSkgZGlzcGF0Y2gob3JpZ2luUG9pbnQoc3RhdGUuZGVzdGluYXRpb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXMpKTtcclxuICAgIGlmIChzdGF0ZS5vcmlnaW4uZ2VvbWV0cnkpIGRpc3BhdGNoKGRlc3RpbmF0aW9uUG9pbnQoc3RhdGUub3JpZ2luLmdlb21ldHJ5LmNvb3JkaW5hdGVzKSk7XHJcbiAgICBpZiAoc3RhdGUub3JpZ2luLmdlb21ldHJ5ICYmIHN0YXRlLmRlc3RpbmF0aW9uLmdlb21ldHJ5KSBkaXNwYXRjaChmZXRjaERpcmVjdGlvbnMoKSk7XHJcbiAgfTtcclxufVxyXG5cclxuLypcclxuICogU2V0IG9yaWdpbiBmcm9tIGNvb3JkaW5hdGVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZXMgW2xuZywgbGF0XSBhcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIHNldE9yaWdpbkZyb21Db29yZGluYXRlcyhjb29yZHMpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoKSB7XHJcbiAgICBpZiAoIV91dGlsczIuZGVmYXVsdC52YWxpZENvb3Jkcyhjb29yZHMpKSBjb29yZHMgPSBbX3V0aWxzMi5kZWZhdWx0LndyYXAoY29vcmRzWzBdKSwgX3V0aWxzMi5kZWZhdWx0LndyYXAoY29vcmRzWzFdKV07XHJcbiAgICBpZiAoaXNOYU4oY29vcmRzWzBdKSAmJiBpc05hTihjb29yZHNbMV0pKSByZXR1cm4gZGlzcGF0Y2goc2V0RXJyb3IobmV3IEVycm9yKCdDb29yZGluYXRlcyBhcmUgbm90IHZhbGlkJykpKTtcclxuICAgIGRpc3BhdGNoKHF1ZXJ5T3JpZ2luQ29vcmRpbmF0ZXMoY29vcmRzKSk7XHJcbiAgICBkaXNwYXRjaChjcmVhdGVPcmlnaW4oY29vcmRzKSk7XHJcbiAgfTtcclxufVxyXG5cclxuLypcclxuICogU2V0IGRlc3RpbmF0aW9uIGZyb20gY29vcmRpbmF0ZXNcclxuICpcclxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZHMgW2xuZywgbGF0XSBhcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIHNldERlc3RpbmF0aW9uRnJvbUNvb3JkaW5hdGVzKGNvb3Jkcykge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcclxuICAgIGlmICghX3V0aWxzMi5kZWZhdWx0LnZhbGlkQ29vcmRzKGNvb3JkcykpIGNvb3JkcyA9IFtfdXRpbHMyLmRlZmF1bHQud3JhcChjb29yZHNbMF0pLCBfdXRpbHMyLmRlZmF1bHQud3JhcChjb29yZHNbMV0pXTtcclxuICAgIGlmIChpc05hTihjb29yZHNbMF0pICYmIGlzTmFOKGNvb3Jkc1sxXSkpIHJldHVybiBkaXNwYXRjaChzZXRFcnJvcihuZXcgRXJyb3IoJ0Nvb3JkaW5hdGVzIGFyZSBub3QgdmFsaWQnKSkpO1xyXG4gICAgZGlzcGF0Y2goY3JlYXRlRGVzdGluYXRpb24oY29vcmRzKSk7XHJcbiAgICBkaXNwYXRjaChxdWVyeURlc3RpbmF0aW9uQ29vcmRpbmF0ZXMoY29vcmRzKSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkV2F5cG9pbnQoaW5kZXgsIHdheXBvaW50KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUpIHtcclxuICAgIHZhciBfZ2V0U3RhdGU1ID0gZ2V0U3RhdGUoKTtcclxuXHJcbiAgICB2YXIgZGVzdGluYXRpb24gPSBfZ2V0U3RhdGU1LmRlc3RpbmF0aW9uO1xyXG4gICAgdmFyIHdheXBvaW50cyA9IF9nZXRTdGF0ZTUud2F5cG9pbnRzO1xyXG5cclxuICAgIHdheXBvaW50cy5zcGxpY2UoaW5kZXgsIDAsIG5vcm1hbGl6ZVdheXBvaW50KHdheXBvaW50KSk7XHJcbiAgICBkaXNwYXRjaCh1cGRhdGVXYXlwb2ludHMod2F5cG9pbnRzKSk7XHJcbiAgICBpZiAoZGVzdGluYXRpb24uZ2VvbWV0cnkpIGRpc3BhdGNoKGZldGNoRGlyZWN0aW9ucygpKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRXYXlwb2ludChpbmRleCwgd2F5cG9pbnQpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgdmFyIF9nZXRTdGF0ZTYgPSBnZXRTdGF0ZSgpO1xyXG5cclxuICAgIHZhciBkZXN0aW5hdGlvbiA9IF9nZXRTdGF0ZTYuZGVzdGluYXRpb247XHJcbiAgICB2YXIgd2F5cG9pbnRzID0gX2dldFN0YXRlNi53YXlwb2ludHM7XHJcblxyXG4gICAgd2F5cG9pbnRzW2luZGV4XSA9IG5vcm1hbGl6ZVdheXBvaW50KHdheXBvaW50KTtcclxuICAgIGRpc3BhdGNoKHVwZGF0ZVdheXBvaW50cyh3YXlwb2ludHMpKTtcclxuICAgIGlmIChkZXN0aW5hdGlvbi5nZW9tZXRyeSkgZGlzcGF0Y2goZmV0Y2hEaXJlY3Rpb25zKCkpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVdheXBvaW50KHdheXBvaW50KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUpIHtcclxuICAgIHZhciBfZ2V0U3RhdGU3ID0gZ2V0U3RhdGUoKTtcclxuXHJcbiAgICB2YXIgZGVzdGluYXRpb24gPSBfZ2V0U3RhdGU3LmRlc3RpbmF0aW9uO1xyXG4gICAgdmFyIHdheXBvaW50cyA9IF9nZXRTdGF0ZTcud2F5cG9pbnRzO1xyXG5cclxuICAgIHdheXBvaW50cyA9IHdheXBvaW50cy5maWx0ZXIoZnVuY3Rpb24gKHdheSkge1xyXG4gICAgICByZXR1cm4gIV91dGlsczIuZGVmYXVsdC5jb29yZGluYXRlTWF0Y2god2F5LCB3YXlwb2ludCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkaXNwYXRjaCh1cGRhdGVXYXlwb2ludHMod2F5cG9pbnRzKSk7XHJcbiAgICBpZiAoZGVzdGluYXRpb24uZ2VvbWV0cnkpIGRpc3BhdGNoKGZldGNoRGlyZWN0aW9ucygpKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBldmVudFN1YnNjcmliZSh0eXBlLCBmbikge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIGdldFN0YXRlKSB7XHJcbiAgICB2YXIgX2dldFN0YXRlOCA9IGdldFN0YXRlKCk7XHJcblxyXG4gICAgdmFyIGV2ZW50cyA9IF9nZXRTdGF0ZTguZXZlbnRzO1xyXG5cclxuICAgIGV2ZW50c1t0eXBlXSA9IGV2ZW50c1t0eXBlXSB8fCBbXTtcclxuICAgIGV2ZW50c1t0eXBlXS5wdXNoKGZuKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IHR5cGVzLkVWRU5UUyxcclxuICAgICAgZXZlbnRzOiBldmVudHNcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXZlbnRFbWl0KHR5cGUsIGRhdGEpIHtcclxuICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgdmFyIF9nZXRTdGF0ZTkgPSBnZXRTdGF0ZSgpO1xyXG5cclxuICAgIHZhciBldmVudHMgPSBfZ2V0U3RhdGU5LmV2ZW50cztcclxuXHJcblxyXG4gICAgaWYgKCFldmVudHNbdHlwZV0pIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiB0eXBlcy5FVkVOVFMsXHJcbiAgICAgICAgZXZlbnRzOiBldmVudHNcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdLnNsaWNlKCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoX3RoaXMsIGRhdGEpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbn0se1wiLi4vY29uc3RhbnRzL2FjdGlvbl90eXBlc1wiOjM0LFwiLi4vdXRpbHNcIjo0Mn1dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbnZhciBERVNUSU5BVElPTiA9IGV4cG9ydHMuREVTVElOQVRJT04gPSAnREVTVElOQVRJT04nO1xyXG52YXIgREVTVElOQVRJT05fQ0xFQVIgPSBleHBvcnRzLkRFU1RJTkFUSU9OX0NMRUFSID0gJ0RFU1RJTkFUSU9OX0NMRUFSJztcclxudmFyIERFU1RJTkFUSU9OX1FVRVJZID0gZXhwb3J0cy5ERVNUSU5BVElPTl9RVUVSWSA9ICdERVNUSU5BVElPTl9RVUVSWSc7XHJcbnZhciBERVNUSU5BVElPTl9GUk9NX0NPT1JESU5BVEVTID0gZXhwb3J0cy5ERVNUSU5BVElPTl9GUk9NX0NPT1JESU5BVEVTID0gJ0RFU1RJTkFUSU9OX0ZST01fQ09PUkRJTkFURVMnO1xyXG52YXIgRElSRUNUSU9OUyA9IGV4cG9ydHMuRElSRUNUSU9OUyA9ICdESVJFQ1RJT05TJztcclxudmFyIERJUkVDVElPTlNfUFJPRklMRSA9IGV4cG9ydHMuRElSRUNUSU9OU19QUk9GSUxFID0gJ0RJUkVDVElPTlNfUFJPRklMRSc7XHJcbnZhciBFVkVOVFMgPSBleHBvcnRzLkVWRU5UUyA9ICdFVkVOVFMnO1xyXG52YXIgRVJST1IgPSBleHBvcnRzLkVSUk9SID0gJ0VSUk9SJztcclxudmFyIEhPVkVSX01BUktFUiA9IGV4cG9ydHMuSE9WRVJfTUFSS0VSID0gJ0hPVkVSX01BUktFUic7XHJcbnZhciBPUklHSU4gPSBleHBvcnRzLk9SSUdJTiA9ICdPUklHSU4nO1xyXG52YXIgT1JJR0lOX0NMRUFSID0gZXhwb3J0cy5PUklHSU5fQ0xFQVIgPSAnT1JJR0lOX0NMRUFSJztcclxudmFyIE9SSUdJTl9RVUVSWSA9IGV4cG9ydHMuT1JJR0lOX1FVRVJZID0gJ09SSUdJTl9RVUVSWSc7XHJcbnZhciBPUklHSU5fRlJPTV9DT09SRElOQVRFUyA9IGV4cG9ydHMuT1JJR0lOX0ZST01fQ09PUkRJTkFURVMgPSAnT1JJR0lOX0ZST01fQ09PUkRJTkFURVMnO1xyXG52YXIgUk9VVEVfSU5ERVggPSBleHBvcnRzLlJPVVRFX0lOREVYID0gJ1JPVVRFX0lOREVYJztcclxudmFyIFNFVF9PUFRJT05TID0gZXhwb3J0cy5TRVRfT1BUSU9OUyA9ICdTRVRfT1BUSU9OUyc7XHJcbnZhciBXQVlQT0lOVFMgPSBleHBvcnRzLldBWVBPSU5UUyA9ICdXQVlQT0lOVFMnO1xyXG5cclxufSx7fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcclxuXHJcbnZhciBfc3VnZ2VzdGlvbnMgPSByZXF1aXJlKCdzdWdnZXN0aW9ucycpO1xyXG5cclxudmFyIF9zdWdnZXN0aW9uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdWdnZXN0aW9ucyk7XHJcblxyXG52YXIgX2xvZGFzaCA9IHJlcXVpcmUoJ2xvZGFzaC5kZWJvdW5jZScpO1xyXG5cclxudmFyIF9sb2Rhc2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9kYXNoKTtcclxuXHJcbnZhciBfeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpO1xyXG5cclxudmFyIF94dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF94dGVuZCk7XHJcblxyXG52YXIgX2V2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xyXG5cclxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcblxyXG52YXIgX3V0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vLyBNYXBib3ggR2VvY29kZXIgdmVyc2lvblxyXG52YXIgQVBJID0gJ2h0dHBzOi8vYXBpLm1hcGJveC5jb20vZ2VvY29kaW5nL3Y1L21hcGJveC5wbGFjZXMvJztcclxuXHJcbi8vIEdlb2NvZGVyIC0gdGhpcyBzbGlnaHRseSBtaW1pY2tzIHRoZSBtYXBib3hsLWdsLWdlb2NvZGVyIGJ1dCBpc24ndCBhbiBleGFjdCByZXBsaWNhLlxyXG4vLyBPbmNlIGdsLWpzIHBsdWdpbnMgY2FuIGJlIGFkZGVkIHRvIGN1c3RvbSBkaXZzLCB3ZSBzaG91bGQgYmUgYWJsZSB0byByZXF1aXJlIG1hcGJveC1nbC1nZW9jb2RlclxyXG4vLyBpbnN0ZWFkIG9mIGluY2x1ZGluZyBpdCBoZXJlXHJcbmZ1bmN0aW9uIEdlb2NvZGVyKG9wdGlvbnMpIHtcclxuICB0aGlzLl9ldiA9IG5ldyBfZXZlbnRzLkV2ZW50RW1pdHRlcigpO1xyXG4gIHRoaXMub3B0aW9ucyA9ICgwLCBfeHRlbmQyLmRlZmF1bHQpKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcblxyXG5HZW9jb2Rlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gIG9wdGlvbnM6IHtcclxuICAgIHBsYWNlaG9sZGVyOiAnU2VhcmNoJyxcclxuICAgIHpvb206IDE2LFxyXG4gICAgZmx5VG86IHRydWVcclxuICB9LFxyXG5cclxuICBvbkFkZDogZnVuY3Rpb24gb25BZGQobWFwKSB7XHJcbiAgICB0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG4gICAgdGhpcy5yZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG4gICAgLy8gVGVtcGxhdGVcclxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgZWwuY2xhc3NOYW1lID0gJ21hcGJveGdsLWN0cmwtZ2VvY29kZXInO1xyXG5cclxuICAgIHZhciBpY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgaWNvbi5jbGFzc05hbWUgPSAnZ2VvY29kZXItaWNvbiBnZW9jb2Rlci1pY29uLXNlYXJjaCc7XHJcblxyXG4gICAgdmFyIGlucHV0ID0gdGhpcy5faW5wdXRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICBpbnB1dC50eXBlID0gJ3RleHQnO1xyXG4gICAgaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXI7XHJcblxyXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsICgwLCBfbG9kYXNoMi5kZWZhdWx0KShmdW5jdGlvbiAoZSkge1xyXG4gICAgICBpZiAoIWUudGFyZ2V0LnZhbHVlKSByZXR1cm4gdGhpcy5fY2xlYXJFbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuXHJcbiAgICAgIC8vIFRBQiwgRVNDLCBMRUZULCBSSUdIVCwgRU5URVIsIFVQLCBET1dOXHJcbiAgICAgIGlmIChlLm1ldGFLZXkgfHwgWzksIDI3LCAzNywgMzksIDEzLCAzOCwgNDBdLmluZGV4T2YoZS5rZXlDb2RlKSAhPT0gLTEpIHJldHVybjtcclxuICAgICAgdGhpcy5fcXVlcnlGcm9tSW5wdXQoZS50YXJnZXQudmFsdWUpO1xyXG4gICAgfS5iaW5kKHRoaXMpKSwgMjAwKTtcclxuXHJcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICBpZiAoZS50YXJnZXQudmFsdWUpIHRoaXMuX2NsZWFyRWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcblxyXG4gICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLl90eXBlYWhlYWQuc2VsZWN0ZWQ7XHJcbiAgICAgIGlmIChzZWxlY3RlZCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmx5VG8pIHtcclxuICAgICAgICAgIGlmIChzZWxlY3RlZC5iYm94ICYmIHNlbGVjdGVkLmNvbnRleHQgJiYgc2VsZWN0ZWQuY29udGV4dC5sZW5ndGggPD0gMyB8fCBzZWxlY3RlZC5iYm94ICYmICFzZWxlY3RlZC5jb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBiYm94ID0gc2VsZWN0ZWQuYmJveDtcclxuICAgICAgICAgICAgbWFwLmZpdEJvdW5kcyhbW2Jib3hbMF0sIGJib3hbMV1dLCBbYmJveFsyXSwgYmJveFszXV1dKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hcC5mbHlUbyh7XHJcbiAgICAgICAgICAgICAgY2VudGVyOiBzZWxlY3RlZC5jZW50ZXIsXHJcbiAgICAgICAgICAgICAgem9vbTogdGhpcy5vcHRpb25zLnpvb21cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lucHV0ID0gc2VsZWN0ZWQ7XHJcbiAgICAgICAgdGhpcy5maXJlKCdyZXN1bHQnLCB7IHJlc3VsdDogc2VsZWN0ZWQgfSk7XHJcbiAgICAgIH1cclxuICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgdmFyIGFjdGlvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGFjdGlvbnMuY2xhc3NMaXN0LmFkZCgnZ2VvY29kZXItcGluLXJpZ2h0Jyk7XHJcblxyXG4gICAgdmFyIGNsZWFyID0gdGhpcy5fY2xlYXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG4gICAgY2xlYXIuY2xhc3NOYW1lID0gJ2dlb2NvZGVyLWljb24gZ2VvY29kZXItaWNvbi1jbG9zZSc7XHJcbiAgICBjbGVhci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsZWFyLmJpbmQodGhpcykpO1xyXG5cclxuICAgIHZhciBsb2FkaW5nID0gdGhpcy5fbG9hZGluZ0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgbG9hZGluZy5jbGFzc05hbWUgPSAnZ2VvY29kZXItaWNvbiBnZW9jb2Rlci1pY29uLWxvYWRpbmcnO1xyXG5cclxuICAgIGFjdGlvbnMuYXBwZW5kQ2hpbGQoY2xlYXIpO1xyXG4gICAgYWN0aW9ucy5hcHBlbmRDaGlsZChsb2FkaW5nKTtcclxuXHJcbiAgICBlbC5hcHBlbmRDaGlsZChpY29uKTtcclxuICAgIGVsLmFwcGVuZENoaWxkKGlucHV0KTtcclxuICAgIGVsLmFwcGVuZENoaWxkKGFjdGlvbnMpO1xyXG5cclxuICAgIC8vIE92ZXJyaWRlIHRoZSBjb250cm9sIGJlaW5nIGFkZGVkIHRvIGNvbnRyb2wgY29udGFpbmVyc1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb250YWluZXIpIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX3R5cGVhaGVhZCA9IG5ldyBfc3VnZ2VzdGlvbnMyLmRlZmF1bHQoaW5wdXQsIFtdLCB7IGZpbHRlcjogZmFsc2UgfSk7XHJcbiAgICB0aGlzLl90eXBlYWhlYWQuZ2V0SXRlbVZhbHVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgcmV0dXJuIGl0ZW0ucGxhY2VfbmFtZTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGVsO1xyXG4gIH0sXHJcblxyXG4gIF9nZW9jb2RlOiBmdW5jdGlvbiBfZ2VvY29kZShxLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5fbG9hZGluZ0VsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xyXG4gICAgdGhpcy5maXJlKCdsb2FkaW5nJyk7XHJcblxyXG4gICAgdmFyIG9wdGlvbnMgPSBbXTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJveGltaXR5KSBvcHRpb25zLnB1c2goJ3Byb3hpbWl0eT0nICsgdGhpcy5vcHRpb25zLnByb3hpbWl0eS5qb2luKCkpO1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5iYm94KSBvcHRpb25zLnB1c2goJ2Jib3g9JyArIHRoaXMub3B0aW9ucy5iYm94LmpvaW4oKSk7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvdW50cnkpIG9wdGlvbnMucHVzaCgnY291bnRyeT0nICsgdGhpcy5vcHRpb25zLmNvdW50cnkpO1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy50eXBlcykgb3B0aW9ucy5wdXNoKCd0eXBlcz0nICsgdGhpcy5vcHRpb25zLnR5cGVzKTtcclxuXHJcbiAgICB2YXIgYWNjZXNzVG9rZW4gPSB0aGlzLm9wdGlvbnMuYWNjZXNzVG9rZW4gPyB0aGlzLm9wdGlvbnMuYWNjZXNzVG9rZW4gOiBtYXBib3hnbC5hY2Nlc3NUb2tlbjtcclxuICAgIG9wdGlvbnMucHVzaCgnYWNjZXNzX3Rva2VuPScgKyBhY2Nlc3NUb2tlbik7XHJcblxyXG4gICAgdGhpcy5yZXF1ZXN0LmFib3J0KCk7XHJcbiAgICB0aGlzLnJlcXVlc3Qub3BlbignR0VUJywgQVBJICsgZW5jb2RlVVJJQ29tcG9uZW50KHEudHJpbSgpKSArICcuanNvbj8nICsgb3B0aW9ucy5qb2luKCcmJyksIHRydWUpO1xyXG4gICAgdGhpcy5yZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5fbG9hZGluZ0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG4gICAgICBpZiAodGhpcy5yZXF1ZXN0LnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5yZXF1ZXN0LnN0YXR1cyA8IDQwMCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZSh0aGlzLnJlcXVlc3QucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICBpZiAoZGF0YS5mZWF0dXJlcy5sZW5ndGgpIHtcclxuICAgICAgICAgIHRoaXMuX2NsZWFyRWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX2NsZWFyRWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XHJcbiAgICAgICAgICB0aGlzLl90eXBlYWhlYWQuc2VsZWN0ZWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5maXJlKCdyZXN1bHRzJywgeyByZXN1bHRzOiBkYXRhLmZlYXR1cmVzIH0pO1xyXG4gICAgICAgIHRoaXMuX3R5cGVhaGVhZC51cGRhdGUoZGF0YS5mZWF0dXJlcyk7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEuZmVhdHVyZXMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7IGVycm9yOiBKU09OLnBhcnNlKHRoaXMucmVxdWVzdC5yZXNwb25zZVRleHQpLm1lc3NhZ2UgfSk7XHJcbiAgICAgIH1cclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLnJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5fbG9hZGluZ0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG4gICAgICB0aGlzLmZpcmUoJ2Vycm9yJywgeyBlcnJvcjogSlNPTi5wYXJzZSh0aGlzLnJlcXVlc3QucmVzcG9uc2VUZXh0KS5tZXNzYWdlIH0pO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMucmVxdWVzdC5zZW5kKCk7XHJcbiAgfSxcclxuXHJcbiAgX3F1ZXJ5RnJvbUlucHV0OiBmdW5jdGlvbiBfcXVlcnlGcm9tSW5wdXQocSkge1xyXG4gICAgcSA9IHEudHJpbSgpO1xyXG4gICAgaWYgKCFxKSB0aGlzLl9jbGVhcigpO1xyXG4gICAgaWYgKHEubGVuZ3RoID4gMikge1xyXG4gICAgICB0aGlzLl9nZW9jb2RlKHEsIGZ1bmN0aW9uIChyZXN1bHRzKSB7XHJcbiAgICAgICAgdGhpcy5fcmVzdWx0cyA9IHJlc3VsdHM7XHJcbiAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX2NoYW5nZTogZnVuY3Rpb24gX2NoYW5nZSgpIHtcclxuICAgIHZhciBvbkNoYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XHJcbiAgICBvbkNoYW5nZS5pbml0RXZlbnQoJ2NoYW5nZScsIHRydWUsIGZhbHNlKTtcclxuICAgIHRoaXMuX2lucHV0RWwuZGlzcGF0Y2hFdmVudChvbkNoYW5nZSk7XHJcbiAgfSxcclxuXHJcbiAgX3F1ZXJ5OiBmdW5jdGlvbiBfcXVlcnkoaW5wdXQpIHtcclxuICAgIGlmICghaW5wdXQpIHJldHVybjtcclxuICAgIGlmICgodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpbnB1dCkpID09PSAnb2JqZWN0JyAmJiBpbnB1dC5sZW5ndGgpIHtcclxuICAgICAgaW5wdXQgPSBbX3V0aWxzMi5kZWZhdWx0LndyYXAoaW5wdXRbMF0pLCBfdXRpbHMyLmRlZmF1bHQud3JhcChpbnB1dFsxXSldLmpvaW4oKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9nZW9jb2RlKGlucHV0LCBmdW5jdGlvbiAocmVzdWx0cykge1xyXG4gICAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzWzBdO1xyXG4gICAgICB0aGlzLl9yZXN1bHRzID0gcmVzdWx0cztcclxuICAgICAgdGhpcy5fdHlwZWFoZWFkLnNlbGVjdGVkID0gcmVzdWx0O1xyXG4gICAgICB0aGlzLl9pbnB1dEVsLnZhbHVlID0gcmVzdWx0LnBsYWNlX25hbWU7XHJcbiAgICAgIHRoaXMuX2NoYW5nZSgpO1xyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxuICB9LFxyXG5cclxuICBfc2V0SW5wdXQ6IGZ1bmN0aW9uIF9zZXRJbnB1dChpbnB1dCkge1xyXG4gICAgaWYgKCFpbnB1dCkgcmV0dXJuO1xyXG4gICAgaWYgKCh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlucHV0KSkgPT09ICdvYmplY3QnICYmIGlucHV0Lmxlbmd0aCkge1xyXG4gICAgICBpbnB1dCA9IFtfdXRpbHMyLmRlZmF1bHQud3JhcChpbnB1dFswXSksIF91dGlsczIuZGVmYXVsdC53cmFwKGlucHV0WzFdKV0uam9pbigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCBpbnB1dCB2YWx1ZSB0byBwYXNzZWQgdmFsdWUgYW5kIGNsZWFyIGV2ZXJ5dGhpbmcgZWxzZS5cclxuICAgIHRoaXMuX2lucHV0RWwudmFsdWUgPSBpbnB1dDtcclxuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcclxuICAgIHRoaXMuX3R5cGVhaGVhZC5zZWxlY3RlZCA9IG51bGw7XHJcbiAgICB0aGlzLl90eXBlYWhlYWQuY2xlYXIoKTtcclxuICAgIHRoaXMuX2NoYW5nZSgpO1xyXG4gIH0sXHJcblxyXG4gIF9jbGVhcjogZnVuY3Rpb24gX2NsZWFyKCkge1xyXG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xyXG4gICAgdGhpcy5faW5wdXRFbC52YWx1ZSA9ICcnO1xyXG4gICAgdGhpcy5fdHlwZWFoZWFkLnNlbGVjdGVkID0gbnVsbDtcclxuICAgIHRoaXMuX3R5cGVhaGVhZC5jbGVhcigpO1xyXG4gICAgdGhpcy5fY2hhbmdlKCk7XHJcbiAgICB0aGlzLl9pbnB1dEVsLmZvY3VzKCk7XHJcbiAgICB0aGlzLl9jbGVhckVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG4gICAgdGhpcy5maXJlKCdjbGVhcicpO1xyXG4gIH0sXHJcblxyXG4gIGdldFJlc3VsdDogZnVuY3Rpb24gZ2V0UmVzdWx0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lucHV0O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCAmIHF1ZXJ5IHRoZSBpbnB1dFxyXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBxdWVyeSBBbiBhcnJheSBvZiBjb29yZGluYXRlcyBbbG5nLCBsYXRdIG9yIGxvY2F0aW9uIG5hbWUgYXMgYSBzdHJpbmcuXHJcbiAgICogQHJldHVybnMge0dlb2NvZGVyfSB0aGlzXHJcbiAgICovXHJcbiAgcXVlcnk6IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeTIpIHtcclxuICAgIHRoaXMuX3F1ZXJ5KF9xdWVyeTIpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGlucHV0XHJcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHZhbHVlIEFuIGFycmF5IG9mIGNvb3JkaW5hdGVzIFtsbmcsIGxhdF0gb3IgbG9jYXRpb24gbmFtZSBhcyBhIHN0cmluZy4gQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIGp1c3Qgc2V0cyB0aGUgaW5wdXQgYW5kIGRvZXMgbm90IHRyaWdnZXIgYW4gQVBJIHJlcXVlc3QuXHJcbiAgICogQHJldHVybnMge0dlb2NvZGVyfSB0aGlzXHJcbiAgICovXHJcbiAgc2V0SW5wdXQ6IGZ1bmN0aW9uIHNldElucHV0KHZhbHVlKSB7XHJcbiAgICB0aGlzLl9zZXRJbnB1dCh2YWx1ZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTdWJzY3JpYmUgdG8gZXZlbnRzIHRoYXQgaGFwcGVuIHdpdGhpbiB0aGUgcGx1Z2luLlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIG5hbWUgb2YgZXZlbnQuIEF2YWlsYWJsZSBldmVudHMgYW5kIHRoZSBkYXRhIHBhc3NlZCBpbnRvIHRoZWlyIHJlc3BlY3RpdmUgZXZlbnQgb2JqZWN0cyBhcmU6XHJcbiAgICpcclxuICAgKiAtIF9fY2xlYXJfXyBgRW1pdHRlZCB3aGVuIHRoZSBpbnB1dCBpcyBjbGVhcmVkYFxyXG4gICAqIC0gX19sb2FkaW5nX18gYEVtaXR0ZWQgd2hlbiB0aGUgZ2VvY29kZXIgaXMgbG9va2luZyB1cCBhIHF1ZXJ5YFxyXG4gICAqIC0gX19yZXN1bHRzX18gYHsgcmVzdWx0cyB9IEZpcmVkIHdoZW4gdGhlIGdlb2NvZGVyIHJldHVybnMgYSByZXNwb25zZWBcclxuICAgKiAtIF9fcmVzdWx0X18gYHsgcmVzdWx0IH0gRmlyZWQgd2hlbiBpbnB1dCBpcyBzZXRgXHJcbiAgICogLSBfX2Vycm9yX18gYHsgZXJyb3IgfSBFcnJvciBhcyBzdHJpbmdcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBmdW5jdGlvbiB0aGF0J3MgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuXHJcbiAgICogQHJldHVybnMge0dlb2NvZGVyfSB0aGlzO1xyXG4gICAqL1xyXG4gIG9uOiBmdW5jdGlvbiBvbih0eXBlLCBmbikge1xyXG4gICAgdGhpcy5fZXYub24odHlwZSwgZm4pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRmlyZSBhbiBldmVudFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGV2ZW50IG5hbWUuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgZXZlbnQgZGF0YSB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBzdWJzY3JpYmVkLlxyXG4gICAqIEByZXR1cm5zIHtHZW9jb2Rlcn0gdGhpc1xyXG4gICAqL1xyXG4gIGZpcmU6IGZ1bmN0aW9uIGZpcmUodHlwZSwgZGF0YSkge1xyXG4gICAgdGhpcy5fZXYuZW1pdCh0eXBlLCBkYXRhKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbiBldmVudFxyXG4gICAqIEByZXR1cm5zIHtHZW9jb2Rlcn0gdGhpc1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEV2ZW50IG5hbWUuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdGhhdCBzaG91bGQgdW5zdWJzY3JpYmUgdG8gdGhlIGV2ZW50IGVtaXR0ZWQuXHJcbiAgICovXHJcbiAgb2ZmOiBmdW5jdGlvbiBvZmYodHlwZSwgZm4pIHtcclxuICAgIHRoaXMuX2V2LnJlbW92ZUxpc3RlbmVyKHR5cGUsIGZuKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2VvY29kZXI7XHJcblxyXG59LHtcIi4uL3V0aWxzXCI6NDIsXCJldmVudHNcIjoxLFwibG9kYXNoLmRlYm91bmNlXCI6NSxcInN1Z2dlc3Rpb25zXCI6MjYsXCJ4dGVuZFwiOjMyfV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XHJcblxyXG52YXIgX2dlb2NvZGVyID0gcmVxdWlyZSgnLi9nZW9jb2RlcicpO1xyXG5cclxudmFyIF9nZW9jb2RlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZW9jb2Rlcik7XHJcblxyXG52YXIgX2xvZGFzaCA9IHJlcXVpcmUoJ2xvZGFzaC50ZW1wbGF0ZScpO1xyXG5cclxudmFyIF9sb2Rhc2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9kYXNoKTtcclxuXHJcbnZhciBfbG9kYXNoMyA9IHJlcXVpcmUoJ2xvZGFzaC5pc2VxdWFsJyk7XHJcblxyXG52YXIgX2xvZGFzaDQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2Rhc2gzKTtcclxuXHJcbnZhciBfdHVyZkV4dGVudCA9IHJlcXVpcmUoJ3R1cmYtZXh0ZW50Jyk7XHJcblxyXG52YXIgX3R1cmZFeHRlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHVyZkV4dGVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbiAvLyBzdWJzdGFjay9icmZzIzM5XHJcbnZhciB0bXBsID0gKDAsIF9sb2Rhc2gyLmRlZmF1bHQpKFwiPGRpdiBjbGFzcz0nbWFwYm94LWRpcmVjdGlvbnMtY29tcG9uZW50IG1hcGJveC1kaXJlY3Rpb25zLWlucHV0cyc+XFxuICA8ZGl2IGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1jb21wb25lbnQta2V5bGluZSc+XFxuICAgIDxkaXYgY2xhc3M9J21hcGJveC1kaXJlY3Rpb25zLW9yaWdpbic+XFxuICAgICAgPGxhYmVsIGNsYXNzPSdtYXBib3gtZm9ybS1sYWJlbCc+XFxuICAgICAgICA8c3BhbiBjbGFzcz0nZGlyZWN0aW9ucy1pY29uIGRpcmVjdGlvbnMtaWNvbi1kZXBhcnQnIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOiM5M0FGRDc7JyA+PC9zcGFuPlxcbiAgICAgIDwvbGFiZWw+XFxuICAgICAgPGRpdiBpZD0nbWFwYm94LWRpcmVjdGlvbnMtb3JpZ2luLWlucHV0Jz48L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxidXR0b25cXG4gICAgICBjbGFzcz0nZGlyZWN0aW9ucy1pY29uIGRpcmVjdGlvbnMtaWNvbi1yZXZlcnNlIGRpcmVjdGlvbnMtcmV2ZXJzZSBqcy1yZXZlcnNlLWlucHV0cydcXG4gICAgICB0aXRsZT0nUmV2ZXJzZSBvcmlnaW4gJmFtcDsgZGVzdGluYXRpb24nPlxcbiAgICA8L2J1dHRvbj5cXG5cXG4gICAgPGRpdiBjbGFzcz0nbWFwYm94LWRpcmVjdGlvbnMtZGVzdGluYXRpb24nPlxcbiAgICAgIDxsYWJlbCBjbGFzcz0nbWFwYm94LWZvcm0tbGFiZWwnPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9J2RpcmVjdGlvbnMtaWNvbiBkaXJlY3Rpb25zLWljb24tYXJyaXZlJyBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjojNjA4QkM3Oyc+PC9zcGFuPlxcbiAgICAgIDwvbGFiZWw+XFxuICAgICAgPGRpdiBpZD0nbWFwYm94LWRpcmVjdGlvbnMtZGVzdGluYXRpb24taW5wdXQnPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcblxcbiAgPGRpdiBjbGFzcz0nbWFwYm94LWRpcmVjdGlvbnMtcHJvZmlsZSBtYXBib3gtZGlyZWN0aW9ucy1jb21wb25lbnQta2V5bGluZSBtYXBib3gtZGlyZWN0aW9ucy1jbGVhcmZpeCc+IDxpbnB1dFxcbiAgICAgIGlkPSdtYXBib3gtZGlyZWN0aW9ucy1wcm9maWxlLWRyaXZpbmcnXFxuICAgICAgdHlwZT0ncmFkaW8nXFxuICAgICAgbmFtZT0ncHJvZmlsZSdcXG4gICAgICA8JSBpZiAocHJvZmlsZSA9PT0gJ2RyaXZpbmcnKSB7ICU+Y2hlY2tlZDwlIH0gJT5cXG4gICAgLz5cXG4gICAgPGxhYmVsIGZvcj0nbWFwYm94LWRpcmVjdGlvbnMtcHJvZmlsZS1kcml2aW5nJz5Ecml2aW5nPC9sYWJlbD5cXG4gICAgPGlucHV0XFxuICAgICAgaWQ9J21hcGJveC1kaXJlY3Rpb25zLXByb2ZpbGUtd2Fsa2luZydcXG4gICAgICB0eXBlPSdyYWRpbydcXG4gICAgICBuYW1lPSdwcm9maWxlJ1xcbiAgICAgIDwlIGlmIChwcm9maWxlID09PSAnd2Fsa2luZycpIHsgJT5jaGVja2VkPCUgfSAlPlxcbiAgICAvPlxcbiAgICA8bGFiZWwgZm9yPSdtYXBib3gtZGlyZWN0aW9ucy1wcm9maWxlLXdhbGtpbmcnPldhbGtpbmc8L2xhYmVsPlxcbiAgICA8aW5wdXRcXG4gICAgICBpZD0nbWFwYm94LWRpcmVjdGlvbnMtcHJvZmlsZS1jeWNsaW5nJ1xcbiAgICAgIHR5cGU9J3JhZGlvJ1xcbiAgICAgIG5hbWU9J3Byb2ZpbGUnXFxuICAgICAgPCUgaWYgKHByb2ZpbGUgPT09ICdjeWNsaW5nJykgeyAlPmNoZWNrZWQ8JSB9ICU+XFxuICAgIC8+XFxuICAgIDxsYWJlbCBmb3I9J21hcGJveC1kaXJlY3Rpb25zLXByb2ZpbGUtY3ljbGluZyc+Q3ljbGluZzwvbGFiZWw+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIik7XHJcblxyXG4vKipcclxuICogSW5wdXRzIGNvbnRyb2xsZXJcclxuICpcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgU3VtbWFyeSBwYXJlbnQgY29udGFpbmVyXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdG9yZSBBIHJlZHV4IHN0b3JlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb25zIEFjdGlvbnMgYW4gZWxlbWVudCBjYW4gZGlzcGF0Y2hcclxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwYm94Z2wgaW5zdGFuY2VcclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG52YXIgSW5wdXRzID0gZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIElucHV0cyhlbCwgc3RvcmUsIGFjdGlvbnMsIG1hcCkge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElucHV0cyk7XHJcblxyXG4gICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgdmFyIG9yaWdpblF1ZXJ5ID0gX3N0b3JlJGdldFN0YXRlLm9yaWdpblF1ZXJ5O1xyXG4gICAgdmFyIGRlc3RpbmF0aW9uUXVlcnkgPSBfc3RvcmUkZ2V0U3RhdGUuZGVzdGluYXRpb25RdWVyeTtcclxuICAgIHZhciBwcm9maWxlID0gX3N0b3JlJGdldFN0YXRlLnByb2ZpbGU7XHJcblxyXG5cclxuICAgIGVsLmlubmVySFRNTCA9IHRtcGwoe1xyXG4gICAgICBvcmlnaW5RdWVyeTogb3JpZ2luUXVlcnksXHJcbiAgICAgIGRlc3RpbmF0aW9uUXVlcnk6IGRlc3RpbmF0aW9uUXVlcnksXHJcbiAgICAgIHByb2ZpbGU6IHByb2ZpbGVcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuY29udGFpbmVyID0gZWw7XHJcbiAgICB0aGlzLmFjdGlvbnMgPSBhY3Rpb25zO1xyXG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xyXG4gICAgdGhpcy5fbWFwID0gbWFwO1xyXG5cclxuICAgIHRoaXMub25BZGQoKTtcclxuICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlQ2xhc3MoSW5wdXRzLCBbe1xyXG4gICAga2V5OiAnYW5pbWF0ZVRvQ29vcmRpbmF0ZXMnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVUb0Nvb3JkaW5hdGVzKG1vZGUsIGNvb3Jkcykge1xyXG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlMiA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIHZhciBvcmlnaW4gPSBfc3RvcmUkZ2V0U3RhdGUyLm9yaWdpbjtcclxuICAgICAgdmFyIGRlc3RpbmF0aW9uID0gX3N0b3JlJGdldFN0YXRlMi5kZXN0aW5hdGlvbjtcclxuXHJcblxyXG4gICAgICBpZiAob3JpZ2luLmdlb21ldHJ5ICYmIGRlc3RpbmF0aW9uLmdlb21ldHJ5ICYmICEoMCwgX2xvZGFzaDQuZGVmYXVsdCkob3JpZ2luLmdlb21ldHJ5LCBkZXN0aW5hdGlvbi5nZW9tZXRyeSkpIHtcclxuXHJcbiAgICAgICAgLy8gQW5pbWF0ZSBtYXAgdG8gZml0IGJvdW5kcy5cclxuICAgICAgICB2YXIgYmIgPSAoMCwgX3R1cmZFeHRlbnQyLmRlZmF1bHQpKHtcclxuICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcbiAgICAgICAgICBmZWF0dXJlczogW29yaWdpbiwgZGVzdGluYXRpb25dXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuX21hcC5maXRCb3VuZHMoW1tiYlswXSwgYmJbMV1dLCBbYmJbMl0sIGJiWzNdXV0sIHsgcGFkZGluZzogODAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fbWFwLmZseVRvKHsgY2VudGVyOiBjb29yZHMgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdvbkFkZCcsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25BZGQoKSB7XHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgX2FjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XHJcbiAgICAgIHZhciBjbGVhck9yaWdpbiA9IF9hY3Rpb25zLmNsZWFyT3JpZ2luO1xyXG4gICAgICB2YXIgY2xlYXJEZXN0aW5hdGlvbiA9IF9hY3Rpb25zLmNsZWFyRGVzdGluYXRpb247XHJcbiAgICAgIHZhciBjcmVhdGVPcmlnaW4gPSBfYWN0aW9ucy5jcmVhdGVPcmlnaW47XHJcbiAgICAgIHZhciBjcmVhdGVEZXN0aW5hdGlvbiA9IF9hY3Rpb25zLmNyZWF0ZURlc3RpbmF0aW9uO1xyXG4gICAgICB2YXIgc2V0UHJvZmlsZSA9IF9hY3Rpb25zLnNldFByb2ZpbGU7XHJcbiAgICAgIHZhciByZXZlcnNlID0gX2FjdGlvbnMucmV2ZXJzZTtcclxuXHJcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUzID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgdmFyIGdlb2NvZGVyID0gX3N0b3JlJGdldFN0YXRlMy5nZW9jb2RlcjtcclxuICAgICAgdmFyIGFjY2Vzc1Rva2VuID0gX3N0b3JlJGdldFN0YXRlMy5hY2Nlc3NUb2tlbjtcclxuXHJcblxyXG4gICAgICB0aGlzLm9yaWdpbklucHV0ID0gbmV3IF9nZW9jb2RlcjIuZGVmYXVsdChPYmplY3QuYXNzaWduKHt9LCB7XHJcbiAgICAgICAgZmx5VG86IGZhbHNlLFxyXG4gICAgICAgIHBsYWNlaG9sZGVyOiAnU3RhcnRvcnQnLFxyXG4gICAgICAgIGFjY2Vzc1Rva2VuOiBhY2Nlc3NUb2tlblxyXG4gICAgICB9LCBnZW9jb2RlcikpO1xyXG5cclxuICAgICAgdmFyIG9yaWdpbkVsID0gdGhpcy5vcmlnaW5JbnB1dC5vbkFkZCgpO1xyXG4gICAgICB2YXIgb3JpZ2luQ29udGFpbmVyRWwgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjbWFwYm94LWRpcmVjdGlvbnMtb3JpZ2luLWlucHV0Jyk7XHJcbiAgICAgIG9yaWdpbkNvbnRhaW5lckVsLmFwcGVuZENoaWxkKG9yaWdpbkVsKTtcclxuXHJcbiAgICAgIHRoaXMuZGVzdGluYXRpb25JbnB1dCA9IG5ldyBfZ2VvY29kZXIyLmRlZmF1bHQoT2JqZWN0LmFzc2lnbih7fSwge1xyXG4gICAgICAgIGZseVRvOiBmYWxzZSxcclxuICAgICAgICBwbGFjZWhvbGRlcjogJ1ppZWxvcnQnLFxyXG4gICAgICAgIGFjY2Vzc1Rva2VuOiBhY2Nlc3NUb2tlblxyXG4gICAgICB9LCBnZW9jb2RlcikpO1xyXG5cclxuICAgICAgdmFyIGRlc3RpbmF0aW9uRWwgPSB0aGlzLmRlc3RpbmF0aW9uSW5wdXQub25BZGQoKTtcclxuICAgICAgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignI21hcGJveC1kaXJlY3Rpb25zLWRlc3RpbmF0aW9uLWlucHV0JykuYXBwZW5kQ2hpbGQoZGVzdGluYXRpb25FbCk7XHJcblxyXG4gICAgICB0aGlzLm9yaWdpbklucHV0Lm9uKCdyZXN1bHQnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciBjb29yZHMgPSBlLnJlc3VsdC5jZW50ZXI7XHJcbiAgICAgICAgY3JlYXRlT3JpZ2luKGNvb3Jkcyk7XHJcbiAgICAgICAgX3RoaXMuYW5pbWF0ZVRvQ29vcmRpbmF0ZXMoJ29yaWdpbicsIGNvb3Jkcyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5vcmlnaW5JbnB1dC5vbignY2xlYXInLCBjbGVhck9yaWdpbik7XHJcblxyXG4gICAgICB0aGlzLmRlc3RpbmF0aW9uSW5wdXQub24oJ3Jlc3VsdCcsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIGNvb3JkcyA9IGUucmVzdWx0LmNlbnRlcjtcclxuICAgICAgICBjcmVhdGVEZXN0aW5hdGlvbihjb29yZHMpO1xyXG4gICAgICAgIF90aGlzLmFuaW1hdGVUb0Nvb3JkaW5hdGVzKCdkZXN0aW5hdGlvbicsIGNvb3Jkcyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5kZXN0aW5hdGlvbklucHV0Lm9uKCdjbGVhcicsIGNsZWFyRGVzdGluYXRpb24pO1xyXG5cclxuICAgICAgLy8gRHJpdmluZyAvIFdhbGtpbmcgLyBDeWNsaW5nIHByb2ZpbGVzXHJcbiAgICAgIHZhciBwcm9maWxlcyA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXScpO1xyXG4gICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHByb2ZpbGVzLCBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBzZXRQcm9maWxlKGVsLmlkLnJlcGxhY2UoJ21hcGJveC1kaXJlY3Rpb25zLXByb2ZpbGUtJywgJycpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBSZXZlcnNpbmcgT3JpZ2luIC8gRGVzdGluYXRpb25cclxuICAgICAgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignLmpzLXJldmVyc2UtaW5wdXRzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZTQgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgICB2YXIgb3JpZ2luID0gX3N0b3JlJGdldFN0YXRlNC5vcmlnaW47XHJcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gX3N0b3JlJGdldFN0YXRlNC5kZXN0aW5hdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKG9yaWdpbikgX3RoaXMuYWN0aW9ucy5xdWVyeURlc3RpbmF0aW9uKG9yaWdpbi5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uKSBfdGhpcy5hY3Rpb25zLnF1ZXJ5T3JpZ2luKGRlc3RpbmF0aW9uLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuICAgICAgICByZXZlcnNlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ3JlbmRlcicsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHJcbiAgICAgIHRoaXMuc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlNSA9IF90aGlzMi5zdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgICB2YXIgb3JpZ2luUXVlcnkgPSBfc3RvcmUkZ2V0U3RhdGU1Lm9yaWdpblF1ZXJ5O1xyXG4gICAgICAgIHZhciBkZXN0aW5hdGlvblF1ZXJ5ID0gX3N0b3JlJGdldFN0YXRlNS5kZXN0aW5hdGlvblF1ZXJ5O1xyXG4gICAgICAgIHZhciBvcmlnaW5RdWVyeUNvb3JkaW5hdGVzID0gX3N0b3JlJGdldFN0YXRlNS5vcmlnaW5RdWVyeUNvb3JkaW5hdGVzO1xyXG4gICAgICAgIHZhciBkZXN0aW5hdGlvblF1ZXJ5Q29vcmRpbmF0ZXMgPSBfc3RvcmUkZ2V0U3RhdGU1LmRlc3RpbmF0aW9uUXVlcnlDb29yZGluYXRlcztcclxuXHJcblxyXG4gICAgICAgIGlmIChvcmlnaW5RdWVyeSkge1xyXG4gICAgICAgICAgX3RoaXMyLm9yaWdpbklucHV0LnF1ZXJ5KG9yaWdpblF1ZXJ5KTtcclxuICAgICAgICAgIF90aGlzMi5hY3Rpb25zLnF1ZXJ5T3JpZ2luKG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uUXVlcnkpIHtcclxuICAgICAgICAgIF90aGlzMi5kZXN0aW5hdGlvbklucHV0LnF1ZXJ5KGRlc3RpbmF0aW9uUXVlcnkpO1xyXG4gICAgICAgICAgX3RoaXMyLmFjdGlvbnMucXVlcnlEZXN0aW5hdGlvbihudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcmlnaW5RdWVyeUNvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICBfdGhpczIub3JpZ2luSW5wdXQuc2V0SW5wdXQob3JpZ2luUXVlcnlDb29yZGluYXRlcyk7XHJcbiAgICAgICAgICBfdGhpczIuYW5pbWF0ZVRvQ29vcmRpbmF0ZXMoJ29yaWdpbicsIG9yaWdpblF1ZXJ5Q29vcmRpbmF0ZXMpO1xyXG4gICAgICAgICAgX3RoaXMyLmFjdGlvbnMucXVlcnlPcmlnaW5Db29yZGluYXRlcyhudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkZXN0aW5hdGlvblF1ZXJ5Q29vcmRpbmF0ZXMpIHtcclxuICAgICAgICAgIF90aGlzMi5kZXN0aW5hdGlvbklucHV0LnNldElucHV0KGRlc3RpbmF0aW9uUXVlcnlDb29yZGluYXRlcyk7XHJcbiAgICAgICAgICBfdGhpczIuYW5pbWF0ZVRvQ29vcmRpbmF0ZXMoJ2Rlc3RpbmF0aW9uJywgZGVzdGluYXRpb25RdWVyeUNvb3JkaW5hdGVzKTtcclxuICAgICAgICAgIF90aGlzMi5hY3Rpb25zLnF1ZXJ5RGVzdGluYXRpb25Db29yZGluYXRlcyhudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1dKTtcclxuXHJcbiAgcmV0dXJuIElucHV0cztcclxufSgpO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gSW5wdXRzO1xyXG5cclxufSx7XCIuL2dlb2NvZGVyXCI6MzUsXCJsb2Rhc2guaXNlcXVhbFwiOjYsXCJsb2Rhc2gudGVtcGxhdGVcIjo3LFwidHVyZi1leHRlbnRcIjozMH1dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xyXG5cclxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcblxyXG52YXIgX3V0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzKTtcclxuXHJcbnZhciBfbG9kYXNoID0gcmVxdWlyZSgnbG9kYXNoLnRlbXBsYXRlJyk7XHJcblxyXG52YXIgX2xvZGFzaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2Rhc2gpO1xyXG5cclxudmFyIF9sb2Rhc2gzID0gcmVxdWlyZSgnbG9kYXNoLmlzZXF1YWwnKTtcclxuXHJcbnZhciBfbG9kYXNoNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZGFzaDMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG4gLy8gc3Vic3RhY2svYnJmcyMzOVxyXG52YXIgaW5zdHJ1Y3Rpb25zVGVtcGxhdGUgPSAoMCwgX2xvZGFzaDIuZGVmYXVsdCkoXCI8ZGl2IGNsYXNzPSdkaXJlY3Rpb25zLWNvbnRyb2wgZGlyZWN0aW9ucy1jb250cm9sLWRpcmVjdGlvbnMnPlxcbiAgPGRpdiBjbGFzcz0nbWFwYm94LWRpcmVjdGlvbnMtY29tcG9uZW50IG1hcGJveC1kaXJlY3Rpb25zLXJvdXRlLXN1bW1hcnk8JSBpZiAocm91dGVzID4gMSkgeyAlPiBtYXBib3gtZGlyZWN0aW9ucy1tdWx0aXBsZTwlIH0gJT4nPlxcbiAgICA8JSBpZiAocm91dGVzID4gMSkgeyAlPlxcbiAgICA8ZGl2IGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1yb3V0ZXMgbWFwYm94LWRpcmVjdGlvbnMtY2xlYXJmaXgnPlxcbiAgICAgIDwlIGZvciAodmFyIGkgPSAwOyBpIDwgcm91dGVzOyBpKyspIHsgJT5cXG4gICAgICAgIDxpbnB1dCB0eXBlPSdyYWRpbycgbmFtZT0ncm91dGVzJyBpZD0nPCU9IGkgJT4nIDwlIGlmIChpID09PSByb3V0ZUluZGV4KSB7ICU+Y2hlY2tlZDwlIH0gJT4+XFxuICAgICAgICA8bGFiZWwgZm9yPSc8JT0gaSAlPicgY2xhc3M9J21hcGJveC1kaXJlY3Rpb25zLXJvdXRlJz48JT0gaSArIDEgJT48L2xhYmVsPlxcbiAgICAgIDwlIH0gJT5cXG4gICAgPC9kaXY+XFxuICAgIDwlIH0gJT5cXG4gICAgPGgxPjwlLSBkdXJhdGlvbiAlPjwvaDE+XFxuICAgIDxzcGFuPjwlLSBkaXN0YW5jZSAlPjwvc3Bhbj5cXG4gIDwvZGl2PlxcblxcbiAgPGRpdiBjbGFzcz0nbWFwYm94LWRpcmVjdGlvbnMtaW5zdHJ1Y3Rpb25zJz5cXG4gICAgPGRpdiBjbGFzcz0nbWFwYm94LWRpcmVjdGlvbnMtaW5zdHJ1Y3Rpb25zLXdyYXBwZXInPlxcbiAgICAgIDxvbCBjbGFzcz0nbWFwYm94LWRpcmVjdGlvbnMtc3RlcHMnPlxcbiAgICAgICAgPCUgc3RlcHMuZm9yRWFjaChmdW5jdGlvbihzdGVwKSB7ICU+XFxuICAgICAgICAgIDwlXFxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gc3RlcC5kaXN0YW5jZSA/IGZvcm1hdChzdGVwLmRpc3RhbmNlKSA6IGZhbHNlO1xcbiAgICAgICAgICAgIHZhciBpY29uID0gc3RlcC5tYW5ldXZlci5tb2RpZmllciA/IHN0ZXAubWFuZXV2ZXIubW9kaWZpZXIucmVwbGFjZSgvXFxcXHMrL2csICctJykudG9Mb3dlckNhc2UoKSA6IHN0ZXAubWFuZXV2ZXIudHlwZS5yZXBsYWNlKC9cXFxccysvZywgJy0nKS50b0xvd2VyQ2FzZSgpO1xcblxcbiAgICAgICAgICAgIGlmIChzdGVwLm1hbmV1dmVyLnR5cGUgPT09ICdhcnJpdmUnIHx8IHN0ZXAubWFuZXV2ZXIudHlwZSA9PT0gJ2RlcGFydCcpIHtcXG4gICAgICAgICAgICAgIGljb24gPSBzdGVwLm1hbmV1dmVyLnR5cGU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChzdGVwLm1hbmV1dmVyLnR5cGUgPT09ICdyb3VuZGFib3V0JyB8fCBzdGVwLm1hbmV1dmVyLnR5cGUgPT09ICdyb3RhcnknKSB7XFxuICAgICAgICAgICAgICBpY29uPSAncm91bmRhYm91dCc7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHZhciBsbmcgPSBzdGVwLm1hbmV1dmVyLmxvY2F0aW9uWzBdO1xcbiAgICAgICAgICAgIHZhciBsYXQgPSBzdGVwLm1hbmV1dmVyLmxvY2F0aW9uWzFdO1xcbiAgICAgICAgICAlPlxcbiAgICAgICAgICA8bGlcXG4gICAgICAgICAgICBkYXRhLWxhdD0nPCU9IGxhdCAlPidcXG4gICAgICAgICAgICBkYXRhLWxuZz0nPCU9IGxuZyAlPidcXG4gICAgICAgICAgICBjbGFzcz0nbWFwYm94LWRpcmVjdGlvbnMtc3RlcCc+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9J2RpcmVjdGlvbnMtaWNvbiBkaXJlY3Rpb25zLWljb24tPCU9IGljb24gJT4nPjwvc3Bhbj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1zdGVwLW1hbmV1dmVyJz5cXG4gICAgICAgICAgICAgIDwlPSBzdGVwLm1hbmV1dmVyLmluc3RydWN0aW9uICU+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPCUgaWYgKGRpc3RhbmNlKSB7ICU+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1zdGVwLWRpc3RhbmNlJz5cXG4gICAgICAgICAgICAgICAgPCU9IGRpc3RhbmNlICU+XFxuICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8JSB9ICU+XFxuICAgICAgICAgIDwvbGk+XFxuICAgICAgICA8JSB9KTsgJT5cXG4gICAgICA8L29sPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiKTtcclxudmFyIGVycm9yVGVtcGxhdGUgPSAoMCwgX2xvZGFzaDIuZGVmYXVsdCkoXCI8ZGl2IGNsYXNzPSdkaXJlY3Rpb25zLWNvbnRyb2wgZGlyZWN0aW9ucy1jb250cm9sLWRpcmVjdGlvbnMnPlxcbiAgPGRpdiBjbGFzcz0nbWFwYm94LWRpcmVjdGlvbnMtZXJyb3InPlxcbiAgICA8JT0gZXJyb3IgJT5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiKTtcclxuXHJcblxyXG4vKipcclxuICogU3VtbWFyeS9JbnN0cnVjdGlvbnMgY29udHJvbGxlclxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBTdW1tYXJ5IHBhcmVudCBjb250YWluZXJcclxuICogQHBhcmFtIHtPYmplY3R9IHN0b3JlIEEgcmVkdXggc3RvcmVcclxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbnMgQWN0aW9ucyBhbiBlbGVtZW50IGNhbiBkaXNwYXRjaFxyXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXBib3hnbCBpbnN0YW5jZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciBJbnN0cnVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gSW5zdHJ1Y3Rpb25zKGVsLCBzdG9yZSwgYWN0aW9ucywgbWFwKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5zdHJ1Y3Rpb25zKTtcclxuXHJcbiAgICB0aGlzLmNvbnRhaW5lciA9IGVsO1xyXG4gICAgdGhpcy5hY3Rpb25zID0gYWN0aW9ucztcclxuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcclxuICAgIHRoaXMuX21hcCA9IG1hcDtcclxuICAgIHRoaXMuZGlyZWN0aW9ucyA9IHt9O1xyXG4gICAgdGhpcy5yZW5kZXIoKTtcclxuICB9XHJcblxyXG4gIF9jcmVhdGVDbGFzcyhJbnN0cnVjdGlvbnMsIFt7XHJcbiAgICBrZXk6ICdyZW5kZXInLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgIHRoaXMuc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2FjdGlvbnMgPSBfdGhpcy5hY3Rpb25zO1xyXG4gICAgICAgIHZhciBob3Zlck1hcmtlciA9IF9hY3Rpb25zLmhvdmVyTWFya2VyO1xyXG4gICAgICAgIHZhciBzZXRSb3V0ZUluZGV4ID0gX2FjdGlvbnMuc2V0Um91dGVJbmRleDtcclxuXHJcbiAgICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgICAgIHZhciByb3V0ZUluZGV4ID0gX3N0b3JlJGdldFN0YXRlLnJvdXRlSW5kZXg7XHJcbiAgICAgICAgdmFyIHVuaXQgPSBfc3RvcmUkZ2V0U3RhdGUudW5pdDtcclxuICAgICAgICB2YXIgZGlyZWN0aW9ucyA9IF9zdG9yZSRnZXRTdGF0ZS5kaXJlY3Rpb25zO1xyXG4gICAgICAgIHZhciBlcnJvciA9IF9zdG9yZSRnZXRTdGF0ZS5lcnJvcjtcclxuXHJcbiAgICAgICAgdmFyIHNob3VsZFJlbmRlciA9ICEoMCwgX2xvZGFzaDQuZGVmYXVsdCkoZGlyZWN0aW9uc1tyb3V0ZUluZGV4XSwgX3RoaXMuZGlyZWN0aW9ucyk7XHJcblxyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgX3RoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IGVycm9yVGVtcGxhdGUoeyBlcnJvcjogZXJyb3IgfSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGlyZWN0aW9ucy5sZW5ndGggJiYgc2hvdWxkUmVuZGVyKSB7XHJcbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gX3RoaXMuZGlyZWN0aW9ucyA9IGRpcmVjdGlvbnNbcm91dGVJbmRleF07XHJcbiAgICAgICAgICBfdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gaW5zdHJ1Y3Rpb25zVGVtcGxhdGUoe1xyXG4gICAgICAgICAgICByb3V0ZUluZGV4OiByb3V0ZUluZGV4LFxyXG4gICAgICAgICAgICByb3V0ZXM6IGRpcmVjdGlvbnMubGVuZ3RoLFxyXG4gICAgICAgICAgICBzdGVwczogZGlyZWN0aW9uLmxlZ3NbMF0uc3RlcHMsIC8vIFRvZG86IFJlc3BlY3QgYWxsIGxlZ3MsXHJcbiAgICAgICAgICAgIGZvcm1hdDogX3V0aWxzMi5kZWZhdWx0LmZvcm1hdFt1bml0XSxcclxuICAgICAgICAgICAgZHVyYXRpb246IF91dGlsczIuZGVmYXVsdC5mb3JtYXRbdW5pdF0oZGlyZWN0aW9uLmRpc3RhbmNlKSxcclxuICAgICAgICAgICAgZGlzdGFuY2U6IF91dGlsczIuZGVmYXVsdC5mb3JtYXQuZHVyYXRpb24oZGlyZWN0aW9uLmR1cmF0aW9uKVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdmFyIHN0ZXBzID0gX3RoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5tYXBib3gtZGlyZWN0aW9ucy1zdGVwJyk7XHJcblxyXG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChzdGVwcywgZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBsbmcgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbG5nJyk7XHJcbiAgICAgICAgICAgIHZhciBsYXQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGF0Jyk7XHJcblxyXG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgaG92ZXJNYXJrZXIoW2xuZywgbGF0XSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgaG92ZXJNYXJrZXIobnVsbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgX3RoaXMuX21hcC5mbHlUbyh7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXI6IFtsbmcsIGxhdF0sXHJcbiAgICAgICAgICAgICAgICB6b29tOiAxNlxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHZhciByb3V0ZXMgPSBfdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdJyk7XHJcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHJvdXRlcywgZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgc2V0Um91dGVJbmRleChwYXJzZUludChlLnRhcmdldC5pZCwgMTApKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKF90aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgJiYgc2hvdWxkUmVuZGVyKSB7XHJcbiAgICAgICAgICBfdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBJbnN0cnVjdGlvbnM7XHJcbn0oKTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IEluc3RydWN0aW9ucztcclxuXHJcbn0se1wiLi4vdXRpbHNcIjo0MixcImxvZGFzaC5pc2VxdWFsXCI6NixcImxvZGFzaC50ZW1wbGF0ZVwiOjd9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcclxuXHJcbnZhciBfcmVkdXggPSByZXF1aXJlKCdyZWR1eCcpO1xyXG5cclxudmFyIF9yZWR1eFRodW5rID0gcmVxdWlyZSgncmVkdXgtdGh1bmsnKTtcclxuXHJcbnZhciBfcmVkdXhUaHVuazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWR1eFRodW5rKTtcclxuXHJcbnZhciBfcG9seWxpbmUgPSByZXF1aXJlKCdwb2x5bGluZScpO1xyXG5cclxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxuXHJcbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xyXG5cclxudmFyIF9yZWR1Y2VycyA9IHJlcXVpcmUoJy4vcmVkdWNlcnMnKTtcclxuXHJcbnZhciBfcmVkdWNlcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVkdWNlcnMpO1xyXG5cclxudmFyIF9hY3Rpb25zID0gcmVxdWlyZSgnLi9hY3Rpb25zJyk7XHJcblxyXG52YXIgYWN0aW9ucyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9hY3Rpb25zKTtcclxuXHJcbnZhciBfZGlyZWN0aW9uc19zdHlsZSA9IHJlcXVpcmUoJy4vZGlyZWN0aW9uc19zdHlsZScpO1xyXG5cclxudmFyIF9kaXJlY3Rpb25zX3N0eWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RpcmVjdGlvbnNfc3R5bGUpO1xyXG5cclxudmFyIF9pbnB1dHMgPSByZXF1aXJlKCcuL2NvbnRyb2xzL2lucHV0cycpO1xyXG5cclxudmFyIF9pbnB1dHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5wdXRzKTtcclxuXHJcbnZhciBfaW5zdHJ1Y3Rpb25zID0gcmVxdWlyZSgnLi9jb250cm9scy9pbnN0cnVjdGlvbnMnKTtcclxuXHJcbnZhciBfaW5zdHJ1Y3Rpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luc3RydWN0aW9ucyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG52YXIgc3RvcmVXaXRoTWlkZGxld2FyZSA9ICgwLCBfcmVkdXguYXBwbHlNaWRkbGV3YXJlKShfcmVkdXhUaHVuazIuZGVmYXVsdCkoX3JlZHV4LmNyZWF0ZVN0b3JlKTtcclxudmFyIHN0b3JlID0gc3RvcmVXaXRoTWlkZGxld2FyZShfcmVkdWNlcnMyLmRlZmF1bHQpO1xyXG5cclxuLy8gU3RhdGUgb2JqZWN0IG1hbmFnZW1lbnQgdmlhIHJlZHV4XHJcblxyXG5cclxuLy8gQ29udHJvbHNcclxuXHJcbi8qKlxyXG4gKiBUaGUgRGlyZWN0aW9ucyBjb250cm9sXHJcbiAqIEBjbGFzcyBNYXBib3hEaXJlY3Rpb25zXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnN0eWxlc10gT3ZlcnJpZGUgZGVmYXVsdCBsYXllciBwcm9wZXJ0aWVzIG9mIHRoZSBbZGlyZWN0aW9ucyBzb3VyY2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWRpcmVjdGlvbnMvYmxvYi9tYXN0ZXIvc3JjL2RpcmVjdGlvbnNfc3R5bGUuanMpLiBEb2N1bWVudGF0aW9uIGZvciBlYWNoIHByb3BlcnR5IGFyZSBzcGVjaWZpZWQgaW4gdGhlIFtNYXBib3ggR0wgU3R5bGUgUmVmZXJlbmNlXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLykuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hY2Nlc3NUb2tlbj1udWxsXSBSZXF1aXJlZCB1bmxlc3MgYG1hcGJveGdsLmFjY2Vzc1Rva2VuYCBpcyBzZXQgZ2xvYmFsbHlcclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbnRlcmFjdGl2ZT10cnVlXSBFbmFibGUvRGlzYWJsZSBtb3VzZSBvciB0b3VjaCBpbnRlcmFjdGl2aXR5IGZyb20gdGhlIHBsdWdpblxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvZmlsZT1cImRyaXZpbmctdHJhZmZpY1wiXSBSb3V0aW5nIHByb2ZpbGUgdG8gdXNlLiBPcHRpb25zOiBgZHJpdmluZy10cmFmZmljYCwgYGRyaXZpbmdgLCBgd2Fsa2luZ2AsIGBjeWNsaW5nYFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudW5pdD1cImltcGVyaWFsXCJdIE1lYXN1cmVtZW50IHN5c3RlbSB0byBiZSB1c2VkIGluIG5hdmlnYXRpb24gaW5zdHJ1Y3Rpb25zLiBPcHRpb25zOiBgaW1wZXJpYWxgLCBgbWV0cmljYFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZ2VvY29kZXJdIFBhc3Mgb3B0aW9ucyBhdmFpbGFibGUgdG8gbWFwYm94LWdsLWdlb2NvZGVyIGFzIFtkb2N1bWVudGVkIGhlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWdlb2NvZGVyL2Jsb2IvbWFzdGVyL0FQSS5tZCNtYXBib3hnbGdlb2NvZGVyKS5cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNvbnRyb2xzXVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbnRyb2xzLmlucHV0cz10cnVlXSBIaWRlIG9yIGRpc3BsYXkgdGhlIGlucHV0cyBjb250cm9sLlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbnRyb2xzLmluc3RydWN0aW9ucz10cnVlXSBIaWRlIG9yIGRpc3BsYXkgdGhlIGluc3RydWN0aW9ucyBjb250cm9sLlxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgTWFwYm94RGlyZWN0aW9ucyA9IHJlcXVpcmUoJy4uL3NyYy9pbmRleCcpO1xyXG4gKiB2YXIgZGlyZWN0aW9ucyA9IG5ldyBNYXBib3hEaXJlY3Rpb25zKHtcclxuICogICBhY2Nlc3NUb2tlbjogJ1lPVVItTUFQQk9YLUFDQ0VTUy1UT0tFTicsXHJcbiAqICAgdW5pdDogJ21ldHJpYycsXHJcbiAqICAgcHJvZmlsZTogJ2N5Y2xpbmcnXHJcbiAqIH0pO1xyXG4gKiAvLyBhZGQgdG8geW91ciBtYXBib3hnbCBtYXBcclxuICogbWFwLmFkZENvbnRyb2woZGlyZWN0aW9ucyk7XHJcbiAqXHJcbiAqIEByZXR1cm4ge01hcGJveERpcmVjdGlvbnN9IGB0aGlzYFxyXG4gKi9cclxudmFyIE1hcGJveERpcmVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gTWFwYm94RGlyZWN0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFwYm94RGlyZWN0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5hY3Rpb25zID0gKDAsIF9yZWR1eC5iaW5kQWN0aW9uQ3JlYXRvcnMpKGFjdGlvbnMsIHN0b3JlLmRpc3BhdGNoKTtcclxuICAgIHRoaXMuYWN0aW9ucy5zZXRPcHRpb25zKG9wdGlvbnMgfHwge30pO1xyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICB0aGlzLm9uRHJhZ0Rvd24gPSB0aGlzLl9vbkRyYWdEb3duLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9uRHJhZ01vdmUgPSB0aGlzLl9vbkRyYWdNb3ZlLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9uRHJhZ1VwID0gdGhpcy5fb25EcmFnVXAuYmluZCh0aGlzKTtcclxuICAgIHRoaXMubW92ZSA9IHRoaXMuX21vdmUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMub25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIF9jcmVhdGVDbGFzcyhNYXBib3hEaXJlY3Rpb25zLCBbe1xyXG4gICAga2V5OiAnb25BZGQnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQWRkKG1hcCkge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgdGhpcy5fbWFwID0gbWFwO1xyXG5cclxuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgICB2YXIgY29udHJvbHMgPSBfc3RvcmUkZ2V0U3RhdGUuY29udHJvbHM7XHJcblxyXG5cclxuICAgICAgdmFyIGVsID0gdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgZWwuY2xhc3NOYW1lID0gJ21hcGJveGdsLWN0cmwtZGlyZWN0aW9ucyBtYXBib3hnbC1jdHJsJztcclxuXHJcbiAgICAgIC8vIEFkZCBjb250cm9scyB0byB0aGUgcGFnZVxyXG4gICAgICB2YXIgaW5wdXRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICBpbnB1dEVsLmNsYXNzTmFtZSA9ICdkaXJlY3Rpb25zLWNvbnRyb2wgZGlyZWN0aW9ucy1jb250cm9sLWlucHV0cyc7XHJcbiAgICAgIG5ldyBfaW5wdXRzMi5kZWZhdWx0KGlucHV0RWwsIHN0b3JlLCB0aGlzLmFjdGlvbnMsIHRoaXMuX21hcCk7XHJcblxyXG4gICAgICB2YXIgZGlyZWN0aW9uc0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIGRpcmVjdGlvbnNFbC5jbGFzc05hbWUgPSAnZGlyZWN0aW9ucy1jb250cm9sIGRpcmVjdGlvbnMtY29udHJvbC1pbnN0cnVjdGlvbnMnO1xyXG5cclxuICAgICAgbmV3IF9pbnN0cnVjdGlvbnMyLmRlZmF1bHQoZGlyZWN0aW9uc0VsLCBzdG9yZSwge1xyXG4gICAgICAgIGhvdmVyTWFya2VyOiB0aGlzLmFjdGlvbnMuaG92ZXJNYXJrZXIsXHJcbiAgICAgICAgc2V0Um91dGVJbmRleDogdGhpcy5hY3Rpb25zLnNldFJvdXRlSW5kZXhcclxuICAgICAgfSwgdGhpcy5fbWFwKTtcclxuXHJcbiAgICAgIGlmIChjb250cm9scy5pbnB1dHMpIGVsLmFwcGVuZENoaWxkKGlucHV0RWwpO1xyXG4gICAgICBpZiAoY29udHJvbHMuaW5zdHJ1Y3Rpb25zKSBlbC5hcHBlbmRDaGlsZChkaXJlY3Rpb25zRWwpO1xyXG5cclxuICAgICAgdGhpcy5zdWJzY3JpYmVkQWN0aW9ucygpO1xyXG4gICAgICBpZiAodGhpcy5fbWFwLmxvYWRlZCgpKSB0aGlzLm1hcFN0YXRlKCk7ZWxzZSB0aGlzLl9tYXAub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzLm1hcFN0YXRlKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaGFzIGJlZW4gYWRkZWQgdG8uIFRoaXMgaXMgY2FsbGVkIGJ5IGBtYXAucmVtb3ZlQ29udHJvbGAsXHJcbiAgICAgKiB3aGljaCBpcyB0aGUgcmVjb21tZW5kZWQgbWV0aG9kIHRvIHJlbW92ZSBjb250cm9scy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Q29udHJvbH0gYHRoaXNgXHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnb25SZW1vdmUnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVtb3ZlKG1hcCkge1xyXG4gICAgICB0aGlzLmNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyKTtcclxuICAgICAgdGhpcy5yZW1vdmVSb3V0ZXMoKTtcclxuICAgICAgbWFwLm9mZignbW91c2Vkb3duJywgdGhpcy5vbkRyYWdEb3duKTtcclxuICAgICAgbWFwLm9mZignbW91c2Vtb3ZlJywgdGhpcy5tb3ZlKTtcclxuICAgICAgbWFwLm9mZigndG91Y2hzdGFydCcsIHRoaXMub25EcmFnRG93bik7XHJcbiAgICAgIG1hcC5vZmYoJ3RvdWNoc3RhcnQnLCB0aGlzLm1vdmUpO1xyXG4gICAgICBtYXAub2ZmKCdjbGljaycsIHRoaXMub25DbGljayk7XHJcbiAgICAgIGlmICh0aGlzLnN0b3JlVW5zdWJzY3JpYmUpIHtcclxuICAgICAgICB0aGlzLnN0b3JlVW5zdWJzY3JpYmUoKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5zdG9yZVVuc3Vic2NyaWJlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX21hcCA9IG51bGw7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ21hcFN0YXRlJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBTdGF0ZSgpIHtcclxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlMiA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgICB2YXIgcHJvZmlsZSA9IF9zdG9yZSRnZXRTdGF0ZTIucHJvZmlsZTtcclxuICAgICAgdmFyIHN0eWxlcyA9IF9zdG9yZSRnZXRTdGF0ZTIuc3R5bGVzO1xyXG4gICAgICB2YXIgaW50ZXJhY3RpdmUgPSBfc3RvcmUkZ2V0U3RhdGUyLmludGVyYWN0aXZlO1xyXG5cclxuICAgICAgLy8gRW1pdCBhbnkgZGVmYXVsdCBvciBvcHRpb24gc2V0IGNvbmZpZ1xyXG5cclxuICAgICAgdGhpcy5hY3Rpb25zLmV2ZW50RW1pdCgncHJvZmlsZScsIHsgcHJvZmlsZTogcHJvZmlsZSB9KTtcclxuXHJcbiAgICAgIHZhciBnZW9qc29uID0ge1xyXG4gICAgICAgIHR5cGU6ICdnZW9qc29uJyxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG4gICAgICAgICAgZmVhdHVyZXM6IFtdXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gQWRkIGFuZCBzZXQgZGF0YSB0aGVtZSBsYXllci9zdHlsZVxyXG4gICAgICB0aGlzLl9tYXAuYWRkU291cmNlKCdkaXJlY3Rpb25zJywgZ2VvanNvbik7XHJcblxyXG4gICAgICAvLyBBZGQgZGlyZWN0aW9uIHNwZWNpZmljIHN0eWxlcyB0byB0aGUgbWFwXHJcbiAgICAgIF9kaXJlY3Rpb25zX3N0eWxlMi5kZWZhdWx0LmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzMi5fbWFwLmFkZExheWVyKHN0eWxlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoc3R5bGVzICYmIHN0eWxlcy5sZW5ndGgpIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gICAgICAgIHJldHVybiBfdGhpczIuX21hcC5hZGRMYXllcihzdHlsZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKGludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3VzZWRvd24nLCB0aGlzLm9uRHJhZ0Rvd24pO1xyXG4gICAgICAgIHRoaXMuX21hcC5vbignbW91c2Vtb3ZlJywgdGhpcy5tb3ZlKTtcclxuICAgICAgICB0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcclxuXHJcbiAgICAgICAgdGhpcy5fbWFwLm9uKCd0b3VjaHN0YXJ0JywgdGhpcy5tb3ZlKTtcclxuICAgICAgICB0aGlzLl9tYXAub24oJ3RvdWNoc3RhcnQnLCB0aGlzLm9uRHJhZ0Rvd24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnc3Vic2NyaWJlZEFjdGlvbnMnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZWRBY3Rpb25zKCkge1xyXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuXHJcbiAgICAgIHRoaXMuc3RvcmVVbnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZTMgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgICB2YXIgb3JpZ2luID0gX3N0b3JlJGdldFN0YXRlMy5vcmlnaW47XHJcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gX3N0b3JlJGdldFN0YXRlMy5kZXN0aW5hdGlvbjtcclxuICAgICAgICB2YXIgaG92ZXJNYXJrZXIgPSBfc3RvcmUkZ2V0U3RhdGUzLmhvdmVyTWFya2VyO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb25zID0gX3N0b3JlJGdldFN0YXRlMy5kaXJlY3Rpb25zO1xyXG4gICAgICAgIHZhciByb3V0ZUluZGV4ID0gX3N0b3JlJGdldFN0YXRlMy5yb3V0ZUluZGV4O1xyXG5cclxuXHJcbiAgICAgICAgdmFyIGdlb2pzb24gPSB7XHJcbiAgICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG4gICAgICAgICAgZmVhdHVyZXM6IFtvcmlnaW4sIGRlc3RpbmF0aW9uLCBob3Zlck1hcmtlcl0uZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLmdlb21ldHJ5O1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoZGlyZWN0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgIGRpcmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSwgaW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsaW5lU3RyaW5nID0ge1xyXG4gICAgICAgICAgICAgIGdlb21ldHJ5OiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXHJcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogKDAsIF9wb2x5bGluZS5kZWNvZGUpKGZlYXR1cmUuZ2VvbWV0cnksIDUpLm1hcChmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgICAgJ3JvdXRlLWluZGV4JzogaW5kZXgsXHJcbiAgICAgICAgICAgICAgICByb3V0ZTogaW5kZXggPT09IHJvdXRlSW5kZXggPyAnc2VsZWN0ZWQnIDogJ2FsdGVybmF0ZSdcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBnZW9qc29uLmZlYXR1cmVzLnB1c2gobGluZVN0cmluZyk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gcm91dGVJbmRleCkge1xyXG4gICAgICAgICAgICAgIC8vIENvbGxlY3QgYW55IHBvc3NpYmxlIHdheXBvaW50cyBmcm9tIHN0ZXBzXHJcbiAgICAgICAgICAgICAgZmVhdHVyZS5sZWdzWzBdLnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLm1hbmV1dmVyLnR5cGUgPT09ICd3YXlwb2ludCcpIHtcclxuICAgICAgICAgICAgICAgICAgZ2VvanNvbi5mZWF0dXJlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGQubWFuZXV2ZXIubG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6ICd3YXlwb2ludCdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfdGhpczMuX21hcC5zdHlsZSAmJiBfdGhpczMuX21hcC5nZXRTb3VyY2UoJ2RpcmVjdGlvbnMnKSkge1xyXG4gICAgICAgICAgX3RoaXMzLl9tYXAuZ2V0U291cmNlKCdkaXJlY3Rpb25zJykuc2V0RGF0YShnZW9qc29uKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ19vbkNsaWNrJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25DbGljayhlKSB7XHJcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xyXG5cclxuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZTQgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgdmFyIG9yaWdpbiA9IF9zdG9yZSRnZXRTdGF0ZTQub3JpZ2luO1xyXG5cclxuICAgICAgdmFyIGNvb3JkcyA9IFtlLmxuZ0xhdC5sbmcsIGUubG5nTGF0LmxhdF07XHJcblxyXG4gICAgICBpZiAoIW9yaWdpbi5nZW9tZXRyeSkge1xyXG4gICAgICAgIHRoaXMuYWN0aW9ucy5zZXRPcmlnaW5Gcm9tQ29vcmRpbmF0ZXMoY29vcmRzKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5fbWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhlLnBvaW50LCB7XHJcbiAgICAgICAgICBsYXllcnM6IFsnZGlyZWN0aW9ucy1vcmlnaW4tcG9pbnQnLCAnZGlyZWN0aW9ucy1kZXN0aW5hdGlvbi1wb2ludCcsICdkaXJlY3Rpb25zLXdheXBvaW50LXBvaW50JywgJ2RpcmVjdGlvbnMtcm91dGUtbGluZS1hbHQnXVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoZmVhdHVyZXMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGFueSB3YXlwb2ludHNcclxuICAgICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgICAgaWYgKGYubGF5ZXIuaWQgPT09ICdkaXJlY3Rpb25zLXdheXBvaW50LXBvaW50Jykge1xyXG4gICAgICAgICAgICAgIF90aGlzNC5hY3Rpb25zLnJlbW92ZVdheXBvaW50KGYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpZiAoZmVhdHVyZXNbMF0ucHJvcGVydGllcy5yb3V0ZSA9PT0gJ2FsdGVybmF0ZScpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZmVhdHVyZXNbMF0ucHJvcGVydGllc1sncm91dGUtaW5kZXgnXTtcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLnNldFJvdXRlSW5kZXgoaW5kZXgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmFjdGlvbnMuc2V0RGVzdGluYXRpb25Gcm9tQ29vcmRpbmF0ZXMoY29vcmRzKTtcclxuICAgICAgICAgIHRoaXMuX21hcC5mbHlUbyh7IGNlbnRlcjogY29vcmRzIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ19tb3ZlJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZShlKSB7XHJcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xyXG5cclxuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZTUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgdmFyIGhvdmVyTWFya2VyID0gX3N0b3JlJGdldFN0YXRlNS5ob3Zlck1hcmtlcjtcclxuXHJcblxyXG4gICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLl9tYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGUucG9pbnQsIHtcclxuICAgICAgICBsYXllcnM6IFsnZGlyZWN0aW9ucy1yb3V0ZS1saW5lLWFsdCcsICdkaXJlY3Rpb25zLXJvdXRlLWxpbmUnLCAnZGlyZWN0aW9ucy1vcmlnaW4tcG9pbnQnLCAnZGlyZWN0aW9ucy1kZXN0aW5hdGlvbi1wb2ludCcsICdkaXJlY3Rpb25zLWhvdmVyLXBvaW50J11cclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLl9tYXAuZ2V0Q2FudmFzKCkuc3R5bGUuY3Vyc29yID0gZmVhdHVyZXMubGVuZ3RoID8gJ3BvaW50ZXInIDogJyc7XHJcblxyXG4gICAgICBpZiAoZmVhdHVyZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5pc0N1cnNvck92ZXJQb2ludCA9IGZlYXR1cmVzWzBdO1xyXG4gICAgICAgIHRoaXMuX21hcC5kcmFnUGFuLmRpc2FibGUoKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGEgcG9zc2libGUgd2F5cG9pbnQgbWFya2VyIHdoZW4gaG92ZXJpbmcgb3ZlciB0aGUgYWN0aXZlIHJvdXRlIGxpbmVcclxuICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAgICAgICAgICBpZiAoZmVhdHVyZS5sYXllci5pZCA9PT0gJ2RpcmVjdGlvbnMtcm91dGUtbGluZScpIHtcclxuICAgICAgICAgICAgX3RoaXM1LmFjdGlvbnMuaG92ZXJNYXJrZXIoW2UubG5nTGF0LmxuZywgZS5sbmdMYXQubGF0XSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGhvdmVyTWFya2VyLmdlb21ldHJ5KSB7XHJcbiAgICAgICAgICAgIF90aGlzNS5hY3Rpb25zLmhvdmVyTWFya2VyKG51bGwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNDdXJzb3JPdmVyUG9pbnQpIHtcclxuICAgICAgICB0aGlzLmlzQ3Vyc29yT3ZlclBvaW50ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbWFwLmRyYWdQYW4uZW5hYmxlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdfb25EcmFnRG93bicsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJhZ0Rvd24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc0N1cnNvck92ZXJQb2ludCkgcmV0dXJuO1xyXG4gICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0aGlzLmlzQ3Vyc29yT3ZlclBvaW50O1xyXG4gICAgICB0aGlzLl9tYXAuZ2V0Q2FudmFzKCkuc3R5bGUuY3Vyc29yID0gJ2dyYWInO1xyXG5cclxuICAgICAgdGhpcy5fbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLm9uRHJhZ01vdmUpO1xyXG4gICAgICB0aGlzLl9tYXAub24oJ21vdXNldXAnLCB0aGlzLm9uRHJhZ1VwKTtcclxuXHJcbiAgICAgIHRoaXMuX21hcC5vbigndG91Y2htb3ZlJywgdGhpcy5vbkRyYWdNb3ZlKTtcclxuICAgICAgdGhpcy5fbWFwLm9uKCd0b3VjaGVuZCcsIHRoaXMub25EcmFnVXApO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ19vbkRyYWdNb3ZlJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25EcmFnTW92ZShlKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSByZXR1cm47XHJcblxyXG4gICAgICB2YXIgY29vcmRzID0gW2UubG5nTGF0LmxuZywgZS5sbmdMYXQubGF0XTtcclxuICAgICAgc3dpdGNoICh0aGlzLmlzRHJhZ2dpbmcubGF5ZXIuaWQpIHtcclxuICAgICAgICBjYXNlICdkaXJlY3Rpb25zLW9yaWdpbi1wb2ludCc6XHJcbiAgICAgICAgICB0aGlzLmFjdGlvbnMuY3JlYXRlT3JpZ2luKGNvb3Jkcyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkaXJlY3Rpb25zLWRlc3RpbmF0aW9uLXBvaW50JzpcclxuICAgICAgICAgIHRoaXMuYWN0aW9ucy5jcmVhdGVEZXN0aW5hdGlvbihjb29yZHMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZGlyZWN0aW9ucy1ob3Zlci1wb2ludCc6XHJcbiAgICAgICAgICB0aGlzLmFjdGlvbnMuaG92ZXJNYXJrZXIoY29vcmRzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnX29uRHJhZ1VwJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25EcmFnVXAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSByZXR1cm47XHJcblxyXG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlNiA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgICB2YXIgaG92ZXJNYXJrZXIgPSBfc3RvcmUkZ2V0U3RhdGU2LmhvdmVyTWFya2VyO1xyXG4gICAgICB2YXIgb3JpZ2luID0gX3N0b3JlJGdldFN0YXRlNi5vcmlnaW47XHJcbiAgICAgIHZhciBkZXN0aW5hdGlvbiA9IF9zdG9yZSRnZXRTdGF0ZTYuZGVzdGluYXRpb247XHJcblxyXG5cclxuICAgICAgc3dpdGNoICh0aGlzLmlzRHJhZ2dpbmcubGF5ZXIuaWQpIHtcclxuICAgICAgICBjYXNlICdkaXJlY3Rpb25zLW9yaWdpbi1wb2ludCc6XHJcbiAgICAgICAgICB0aGlzLmFjdGlvbnMuc2V0T3JpZ2luRnJvbUNvb3JkaW5hdGVzKG9yaWdpbi5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkaXJlY3Rpb25zLWRlc3RpbmF0aW9uLXBvaW50JzpcclxuICAgICAgICAgIHRoaXMuYWN0aW9ucy5zZXREZXN0aW5hdGlvbkZyb21Db29yZGluYXRlcyhkZXN0aW5hdGlvbi5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkaXJlY3Rpb25zLWhvdmVyLXBvaW50JzpcclxuICAgICAgICAgIC8vIEFkZCB3YXlwb2ludCBpZiBhIHN1ZmZpY2VudCBhbW91bnQgb2YgZHJhZ2dpbmcgaGFzIG9jY3VycmVkLlxyXG4gICAgICAgICAgaWYgKGhvdmVyTWFya2VyLmdlb21ldHJ5ICYmICFfdXRpbHMyLmRlZmF1bHQuY29vcmRpbmF0ZU1hdGNoKHRoaXMuaXNEcmFnZ2luZywgaG92ZXJNYXJrZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5hZGRXYXlwb2ludCgwLCBob3Zlck1hcmtlcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX21hcC5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSAnJztcclxuXHJcbiAgICAgIHRoaXMuX21hcC5vZmYoJ3RvdWNobW92ZScsIHRoaXMub25EcmFnTW92ZSk7XHJcbiAgICAgIHRoaXMuX21hcC5vZmYoJ3RvdWNoZW5kJywgdGhpcy5vbkRyYWdVcCk7XHJcblxyXG4gICAgICB0aGlzLl9tYXAub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLm9uRHJhZ01vdmUpO1xyXG4gICAgICB0aGlzLl9tYXAub2ZmKCdtb3VzZXVwJywgdGhpcy5vbkRyYWdVcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQVBJIE1ldGhvZHNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFR1cm4gb24gb3Igb2ZmIGludGVyYWN0aXZpdHlcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdGUgc2V0cyBpbnRlcmFjdGl2aXR5IGJhc2VkIG9uIGEgc3RhdGUgb2YgYHRydWVgIG9yIGBmYWxzZWAuXHJcbiAgICAgKiBAcmV0dXJucyB7TWFwYm94RGlyZWN0aW9uc30gdGhpc1xyXG4gICAgICovXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogJ2ludGVyYWN0aXZlJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcmFjdGl2ZShzdGF0ZSkge1xyXG4gICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICB0aGlzLl9tYXAub24oJ3RvdWNoc3RhcnQnLCB0aGlzLm1vdmUpO1xyXG4gICAgICAgIHRoaXMuX21hcC5vbigndG91Y2hzdGFydCcsIHRoaXMub25EcmFnRG93bik7XHJcblxyXG4gICAgICAgIHRoaXMuX21hcC5vbignbW91c2Vkb3duJywgdGhpcy5vbkRyYWdEb3duKTtcclxuICAgICAgICB0aGlzLl9tYXAub24oJ21vdXNlbW92ZScsIHRoaXMubW92ZSk7XHJcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMub25DbGljayk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fbWFwLm9mZigndG91Y2hzdGFydCcsIHRoaXMubW92ZSk7XHJcbiAgICAgICAgdGhpcy5fbWFwLm9mZigndG91Y2hzdGFydCcsIHRoaXMub25EcmFnRG93bik7XHJcblxyXG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ21vdXNlZG93bicsIHRoaXMub25EcmFnRG93bik7XHJcbiAgICAgICAgdGhpcy5fbWFwLm9mZignbW91c2Vtb3ZlJywgdGhpcy5tb3ZlKTtcclxuICAgICAgICB0aGlzLl9tYXAub2ZmKCdjbGljaycsIHRoaXMub25DbGljayk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgb3JpZ2luIG9mIHRoZSBjdXJyZW50IHJvdXRlLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gb3JpZ2luXHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnZ2V0T3JpZ2luJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcmlnaW4oKSB7XHJcbiAgICAgIHJldHVybiBzdG9yZS5nZXRTdGF0ZSgpLm9yaWdpbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgb3JpZ2luLiBfTm90ZTpfIGNhbGxpbmcgdGhpcyBtZXRob2QgcmVxdWlyZXMgdGhlIFttYXAgbG9hZCBldmVudF0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNNYXAubG9hZClcclxuICAgICAqIHRvIGhhdmUgcnVuLlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fFN0cmluZ30gcXVlcnkgQW4gYXJyYXkgb2YgY29vcmRpbmF0ZXMgW2xuZywgbGF0XSBvciBsb2NhdGlvbiBuYW1lIGFzIGEgc3RyaW5nLlxyXG4gICAgICogQHJldHVybnMge01hcGJveERpcmVjdGlvbnN9IHRoaXNcclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6ICdzZXRPcmlnaW4nLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yaWdpbihxdWVyeSkge1xyXG4gICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRoaXMuYWN0aW9ucy5xdWVyeU9yaWdpbihxdWVyeSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5hY3Rpb25zLnNldE9yaWdpbkZyb21Db29yZGluYXRlcyhxdWVyeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIGN1cnJlbnQgcm91dGUuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0aW5hdGlvblxyXG4gICAgICovXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogJ2dldERlc3RpbmF0aW9uJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXN0aW5hdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHN0b3JlLmdldFN0YXRlKCkuZGVzdGluYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGRlc3RpbmF0aW9uLiBfTm90ZTpfIGNhbGxpbmcgdGhpcyBtZXRob2QgcmVxdWlyZXMgdGhlIFttYXAgbG9hZCBldmVudF0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNNYXAubG9hZClcclxuICAgICAqIHRvIGhhdmUgcnVuLlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fFN0cmluZ30gcXVlcnkgQW4gYXJyYXkgb2YgY29vcmRpbmF0ZXMgW2xuZywgbGF0XSBvciBsb2NhdGlvbiBuYW1lIGFzIGEgc3RyaW5nLlxyXG4gICAgICogQHJldHVybnMge01hcGJveERpcmVjdGlvbnN9IHRoaXNcclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6ICdzZXREZXN0aW5hdGlvbicsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGVzdGluYXRpb24ocXVlcnkpIHtcclxuICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aGlzLmFjdGlvbnMucXVlcnlEZXN0aW5hdGlvbihxdWVyeSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5hY3Rpb25zLnNldERlc3RpbmF0aW9uRnJvbUNvb3JkaW5hdGVzKHF1ZXJ5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2FwIHRoZSBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uLlxyXG4gICAgICogQHJldHVybnMge01hcGJveERpcmVjdGlvbnN9IHRoaXNcclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6ICdyZXZlcnNlJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xyXG4gICAgICB0aGlzLmFjdGlvbnMucmV2ZXJzZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHdheXBvaW50IHRvIHRoZSByb3V0ZS4gX05vdGU6XyBjYWxsaW5nIHRoaXMgbWV0aG9kIHJlcXVpcmVzIHRoZVxyXG4gICAgICogW21hcCBsb2FkIGV2ZW50XShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvI01hcC5sb2FkKSB0byBoYXZlIHJ1bi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBwb3NpdGlvbiB3YXlwb2ludCBzaG91bGQgYmUgcGxhY2VkIGluIHRoZSB3YXlwb2ludCBhcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fFBvaW50fSB3YXlwb2ludCBjYW4gYmUgYSBHZW9KU09OIFBvaW50IEZlYXR1cmUgb3IgW2xuZywgbGF0XSBjb29yZGluYXRlcy5cclxuICAgICAqIEByZXR1cm5zIHtNYXBib3hEaXJlY3Rpb25zfSB0aGlzO1xyXG4gICAgICovXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogJ2FkZFdheXBvaW50JyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRXYXlwb2ludChpbmRleCwgd2F5cG9pbnQpIHtcclxuICAgICAgaWYgKCF3YXlwb2ludC50eXBlKSB3YXlwb2ludCA9IF91dGlsczIuZGVmYXVsdC5jcmVhdGVQb2ludCh3YXlwb2ludCwgeyBpZDogJ3dheXBvaW50JyB9KTtcclxuICAgICAgdGhpcy5hY3Rpb25zLmFkZFdheXBvaW50KGluZGV4LCB3YXlwb2ludCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIHRoZSB3YXlwb2ludCBhdCBhIGdpdmVuIGluZGV4IGluIHRoZSByb3V0ZS4gX05vdGU6XyBjYWxsaW5nIHRoaXNcclxuICAgICAqIG1ldGhvZCByZXF1aXJlcyB0aGUgW21hcCBsb2FkIGV2ZW50XShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvI01hcC5sb2FkKVxyXG4gICAgICogdG8gaGF2ZSBydW4uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggaW5kZXhlZCBwb3NpdGlvbiBvZiB0aGUgd2F5cG9pbnQgdG8gdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj58UG9pbnR9IHdheXBvaW50IGNhbiBiZSBhIEdlb0pTT04gUG9pbnQgRmVhdHVyZSBvciBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHJldHVybnMge01hcGJveERpcmVjdGlvbnN9IHRoaXM7XHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnc2V0V2F5cG9pbnQnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFdheXBvaW50KGluZGV4LCB3YXlwb2ludCkge1xyXG4gICAgICBpZiAoIXdheXBvaW50LnR5cGUpIHdheXBvaW50ID0gX3V0aWxzMi5kZWZhdWx0LmNyZWF0ZVBvaW50KHdheXBvaW50LCB7IGlkOiAnd2F5cG9pbnQnIH0pO1xyXG4gICAgICB0aGlzLmFjdGlvbnMuc2V0V2F5cG9pbnQoaW5kZXgsIHdheXBvaW50KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYSB3YXlwb2ludCBmcm9tIHRoZSByb3V0ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBwb3NpdGlvbiBpbiB0aGUgd2F5cG9pbnRzIGFycmF5LlxyXG4gICAgICogQHJldHVybnMge01hcGJveERpcmVjdGlvbnN9IHRoaXM7XHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAncmVtb3ZlV2F5cG9pbnQnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVdheXBvaW50KGluZGV4KSB7XHJcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGU3ID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIHZhciB3YXlwb2ludHMgPSBfc3RvcmUkZ2V0U3RhdGU3LndheXBvaW50cztcclxuXHJcbiAgICAgIHRoaXMuYWN0aW9ucy5yZW1vdmVXYXlwb2ludCh3YXlwb2ludHNbaW5kZXhdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaCBhbGwgY3VycmVudCB3YXlwb2ludHMgaW4gYSByb3V0ZS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gd2F5cG9pbnRzXHJcbiAgICAgKi9cclxuXHJcbiAgfSx7XHJcbiAgICBrZXk6ICdnZXREaXN0YW5jZUFuZER1cmF0aW9uJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaXN0YW5jZUFuZER1cmF0aW9uKCkge1xyXG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlOCA9IHN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICAgIGlmKF9zdG9yZSRnZXRTdGF0ZTggPT09IG51bGwpe1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBkaXJlY3Rpb25zID0gX3N0b3JlJGdldFN0YXRlOC5kaXJlY3Rpb25zO1xyXG4gICAgICB2YXIgcm91dGVJbmRleCA9IF9zdG9yZSRnZXRTdGF0ZTgucm91dGVJbmRleDtcclxuICAgICAgdmFyIHVuaXQgPSBfc3RvcmUkZ2V0U3RhdGU4LnVuaXQ7XHJcblxyXG4gICAgICBpZihkaXJlY3Rpb25zW3JvdXRlSW5kZXhdID09PSBudWxsKXtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIHZhciBkdXJhdGlvbiA9IF91dGlsczIuZGVmYXVsdC5mb3JtYXQuZHVyYXRpb24oZGlyZWN0aW9uc1tyb3V0ZUluZGV4XS5kdXJhdGlvbik7XHJcbiAgICAgIHZhciBkaXN0YW5jZSA9IF91dGlsczIuZGVmYXVsdC5mb3JtYXRbdW5pdF0oZGlyZWN0aW9uc1tyb3V0ZUluZGV4XS5kaXN0YW5jZSk7XHJcblxyXG4gICAgICByZXR1cm4ge2R1cmF0aW9uLCBkaXN0YW5jZX07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCByb3V0ZXMgYW5kIHdheXBvaW50cyBmcm9tIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge01hcGJveERpcmVjdGlvbnN9IHRoaXM7XHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnZ2V0V2F5cG9pbnRzJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXYXlwb2ludHMoKSB7XHJcbiAgICAgIHJldHVybiBzdG9yZS5nZXRTdGF0ZSgpLndheXBvaW50cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIHJvdXRlcyBhbmQgd2F5cG9pbnRzIGZyb20gdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7TWFwYm94RGlyZWN0aW9uc30gdGhpcztcclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6ICdyZW1vdmVSb3V0ZXMnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVJvdXRlcygpIHtcclxuICAgICAgdGhpcy5hY3Rpb25zLmNsZWFyT3JpZ2luKCk7XHJcbiAgICAgIHRoaXMuYWN0aW9ucy5jbGVhckRlc3RpbmF0aW9uKCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIHRvIGV2ZW50cyB0aGF0IGhhcHBlbiB3aXRoaW4gdGhlIHBsdWdpbi5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIG5hbWUgb2YgZXZlbnQuIEF2YWlsYWJsZSBldmVudHMgYW5kIHRoZSBkYXRhIHBhc3NlZCBpbnRvIHRoZWlyIHJlc3BlY3RpdmUgZXZlbnQgb2JqZWN0cyBhcmU6XHJcbiAgICAgKlxyXG4gICAgICogLSBfX2NsZWFyX18gYHsgdHlwZTogfSBUeXBlIGlzIG9uZSBvZiAnb3JpZ2luJyBvciAnZGVzdGluYXRpb24nYFxyXG4gICAgICogLSBfX2xvYWRpbmdfXyBgeyB0eXBlOiB9IFR5cGUgaXMgb25lIG9mICdvcmlnaW4nIG9yICdkZXN0aW5hdGlvbidgXHJcbiAgICAgKiAtIF9fcHJvZmlsZV9fIGB7IHByb2ZpbGUgfSBQcm9maWxlIGlzIG9uZSBvZiAnZHJpdmluZycsICd3YWxraW5nJywgb3IgJ2N5Y2xpbmcnYFxyXG4gICAgICogLSBfX29yaWdpbl9fIGB7IGZlYXR1cmUgfSBGaXJlZCB3aGVuIG9yaWdpbiBpcyBzZXRgXHJcbiAgICAgKiAtIF9fZGVzdGluYXRpb25fXyBgeyBmZWF0dXJlIH0gRmlyZWQgd2hlbiBkZXN0aW5hdGlvbiBpcyBzZXRgXHJcbiAgICAgKiAtIF9fcm91dGVfXyBgeyByb3V0ZSB9IEZpcmVkIHdoZW4gYSByb3V0ZSBpcyB1cGRhdGVkYFxyXG4gICAgICogLSBfX2Vycm9yX18gYHsgZXJyb3IgfSBFcnJvciBhcyBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGZ1bmN0aW9uIHRoYXQncyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtNYXBib3hEaXJlY3Rpb25zfSB0aGlzO1xyXG4gICAgICovXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogJ29uJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbih0eXBlLCBmbikge1xyXG4gICAgICB0aGlzLmFjdGlvbnMuZXZlbnRTdWJzY3JpYmUodHlwZSwgZm4pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBNYXBib3hEaXJlY3Rpb25zO1xyXG59KCk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBNYXBib3hEaXJlY3Rpb25zO1xyXG5cclxufSx7XCIuL2FjdGlvbnNcIjozMyxcIi4vY29udHJvbHMvaW5wdXRzXCI6MzYsXCIuL2NvbnRyb2xzL2luc3RydWN0aW9uc1wiOjM3LFwiLi9kaXJlY3Rpb25zX3N0eWxlXCI6MzksXCIuL3JlZHVjZXJzXCI6NDEsXCIuL3V0aWxzXCI6NDIsXCJwb2x5bGluZVwiOjEwLFwicmVkdXhcIjoxNyxcInJlZHV4LXRodW5rXCI6MTF9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG52YXIgc3R5bGUgPSBbe1xyXG4gICdpZCc6ICdkaXJlY3Rpb25zLXJvdXRlLWxpbmUtYWx0JyxcclxuICAndHlwZSc6ICdsaW5lJyxcclxuICAnc291cmNlJzogJ2RpcmVjdGlvbnMnLFxyXG4gICdsYXlvdXQnOiB7XHJcbiAgICAnbGluZS1jYXAnOiAncm91bmQnLFxyXG4gICAgJ2xpbmUtam9pbic6ICdyb3VuZCdcclxuICB9LFxyXG4gICdwYWludCc6IHtcclxuICAgICdsaW5lLWNvbG9yJzogJyNiYmInLFxyXG4gICAgJ2xpbmUtd2lkdGgnOiA0XHJcbiAgfSxcclxuICAnZmlsdGVyJzogWydhbGwnLCBbJ2luJywgJyR0eXBlJywgJ0xpbmVTdHJpbmcnXSwgWydpbicsICdyb3V0ZScsICdhbHRlcm5hdGUnXV1cclxufSwge1xyXG4gICdpZCc6ICdkaXJlY3Rpb25zLXJvdXRlLWxpbmUnLFxyXG4gICd0eXBlJzogJ2xpbmUnLFxyXG4gICdzb3VyY2UnOiAnZGlyZWN0aW9ucycsXHJcbiAgJ2xheW91dCc6IHtcclxuICAgICdsaW5lLWNhcCc6ICdyb3VuZCcsXHJcbiAgICAnbGluZS1qb2luJzogJ3JvdW5kJ1xyXG4gIH0sXHJcbiAgJ3BhaW50Jzoge1xyXG4gICAgJ2xpbmUtY29sb3InOiAnIzYwOEJDNycsXHJcbiAgICAnbGluZS13aWR0aCc6IDRcclxuICB9LFxyXG4gICdmaWx0ZXInOiBbJ2FsbCcsIFsnaW4nLCAnJHR5cGUnLCAnTGluZVN0cmluZyddLCBbJ2luJywgJ3JvdXRlJywgJ3NlbGVjdGVkJ11dXHJcbn0sIHtcclxuICAnaWQnOiAnZGlyZWN0aW9ucy1ob3Zlci1wb2ludC1jYXNpbmcnLFxyXG4gICd0eXBlJzogJ2NpcmNsZScsXHJcbiAgJ3NvdXJjZSc6ICdkaXJlY3Rpb25zJyxcclxuICAncGFpbnQnOiB7XHJcbiAgICAnY2lyY2xlLXJhZGl1cyc6IDgsXHJcbiAgICAnY2lyY2xlLWNvbG9yJzogJyNmZmYnXHJcbiAgfSxcclxuICAnZmlsdGVyJzogWydhbGwnLCBbJ2luJywgJyR0eXBlJywgJ1BvaW50J10sIFsnaW4nLCAnaWQnLCAnaG92ZXInXV1cclxufSwge1xyXG4gICdpZCc6ICdkaXJlY3Rpb25zLWhvdmVyLXBvaW50JyxcclxuICAndHlwZSc6ICdjaXJjbGUnLFxyXG4gICdzb3VyY2UnOiAnZGlyZWN0aW9ucycsXHJcbiAgJ3BhaW50Jzoge1xyXG4gICAgJ2NpcmNsZS1yYWRpdXMnOiA2LFxyXG4gICAgJ2NpcmNsZS1jb2xvcic6ICcjM2JiMmQwJ1xyXG4gIH0sXHJcbiAgJ2ZpbHRlcic6IFsnYWxsJywgWydpbicsICckdHlwZScsICdQb2ludCddLCBbJ2luJywgJ2lkJywgJ2hvdmVyJ11dXHJcbn0sIHtcclxuICAnaWQnOiAnZGlyZWN0aW9ucy13YXlwb2ludC1wb2ludC1jYXNpbmcnLFxyXG4gICd0eXBlJzogJ2NpcmNsZScsXHJcbiAgJ3NvdXJjZSc6ICdkaXJlY3Rpb25zJyxcclxuICAncGFpbnQnOiB7XHJcbiAgICAnY2lyY2xlLXJhZGl1cyc6IDgsXHJcbiAgICAnY2lyY2xlLWNvbG9yJzogJyNmZmYnXHJcbiAgfSxcclxuICAnZmlsdGVyJzogWydhbGwnLCBbJ2luJywgJyR0eXBlJywgJ1BvaW50J10sIFsnaW4nLCAnaWQnLCAnd2F5cG9pbnQnXV1cclxufSwge1xyXG4gICdpZCc6ICdkaXJlY3Rpb25zLXdheXBvaW50LXBvaW50JyxcclxuICAndHlwZSc6ICdjaXJjbGUnLFxyXG4gICdzb3VyY2UnOiAnZGlyZWN0aW9ucycsXHJcbiAgJ3BhaW50Jzoge1xyXG4gICAgJ2NpcmNsZS1yYWRpdXMnOiA2LFxyXG4gICAgJ2NpcmNsZS1jb2xvcic6ICcjNjA4QkM3J1xyXG4gIH0sXHJcbiAgJ2ZpbHRlcic6IFsnYWxsJywgWydpbicsICckdHlwZScsICdQb2ludCddLCBbJ2luJywgJ2lkJywgJ3dheXBvaW50J11dXHJcbn0sIHtcclxuICAnaWQnOiAnZGlyZWN0aW9ucy1vcmlnaW4tcG9pbnQnLFxyXG4gICd0eXBlJzogJ2NpcmNsZScsXHJcbiAgJ3NvdXJjZSc6ICdkaXJlY3Rpb25zJyxcclxuICAncGFpbnQnOiB7XHJcbiAgICAnY2lyY2xlLXJhZGl1cyc6IDE4LFxyXG4gICAgJ2NpcmNsZS1jb2xvcic6ICcjOTNBRkQ3J1xyXG4gIH0sXHJcbiAgJ2ZpbHRlcic6IFsnYWxsJywgWydpbicsICckdHlwZScsICdQb2ludCddLCBbJ2luJywgJ21hcmtlci1zeW1ib2wnLCAnQSddXVxyXG59LCB7XHJcbiAgJ2lkJzogJ2RpcmVjdGlvbnMtb3JpZ2luLWxhYmVsJyxcclxuICAndHlwZSc6ICdzeW1ib2wnLFxyXG4gICdzb3VyY2UnOiAnZGlyZWN0aW9ucycsXHJcbiAgJ2xheW91dCc6IHtcclxuICAgICd0ZXh0LWZpZWxkJzogJ0EnLFxyXG4gICAgJ3RleHQtZm9udCc6IFsnT3BlbiBTYW5zIEJvbGQnLCAnQXJpYWwgVW5pY29kZSBNUyBCb2xkJ10sXHJcbiAgICAndGV4dC1zaXplJzogMTJcclxuICB9LFxyXG4gICdwYWludCc6IHtcclxuICAgICd0ZXh0LWNvbG9yJzogJyNmZmYnXHJcbiAgfSxcclxuICAnZmlsdGVyJzogWydhbGwnLCBbJ2luJywgJyR0eXBlJywgJ1BvaW50J10sIFsnaW4nLCAnbWFya2VyLXN5bWJvbCcsICdBJ11dXHJcbn0sIHtcclxuICAnaWQnOiAnZGlyZWN0aW9ucy1kZXN0aW5hdGlvbi1wb2ludCcsXHJcbiAgJ3R5cGUnOiAnY2lyY2xlJyxcclxuICAnc291cmNlJzogJ2RpcmVjdGlvbnMnLFxyXG4gICdwYWludCc6IHtcclxuICAgICdjaXJjbGUtcmFkaXVzJzogMTgsXHJcbiAgICAnY2lyY2xlLWNvbG9yJzogJyM2MDhCQzcnXHJcbiAgfSxcclxuICAnZmlsdGVyJzogWydhbGwnLCBbJ2luJywgJyR0eXBlJywgJ1BvaW50J10sIFsnaW4nLCAnbWFya2VyLXN5bWJvbCcsICdCJ11dXHJcbn0sIHtcclxuICAnaWQnOiAnZGlyZWN0aW9ucy1kZXN0aW5hdGlvbi1sYWJlbCcsXHJcbiAgJ3R5cGUnOiAnc3ltYm9sJyxcclxuICAnc291cmNlJzogJ2RpcmVjdGlvbnMnLFxyXG4gICdsYXlvdXQnOiB7XHJcbiAgICAndGV4dC1maWVsZCc6ICdCJyxcclxuICAgICd0ZXh0LWZvbnQnOiBbJ09wZW4gU2FucyBCb2xkJywgJ0FyaWFsIFVuaWNvZGUgTVMgQm9sZCddLFxyXG4gICAgJ3RleHQtc2l6ZSc6IDEyXHJcbiAgfSxcclxuICAncGFpbnQnOiB7XHJcbiAgICAndGV4dC1jb2xvcic6ICcjZmZmJ1xyXG4gIH0sXHJcbiAgJ2ZpbHRlcic6IFsnYWxsJywgWydpbicsICckdHlwZScsICdQb2ludCddLCBbJ2luJywgJ21hcmtlci1zeW1ib2wnLCAnQiddXVxyXG59XTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHN0eWxlO1xyXG5cclxufSx7fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX2RpcmVjdGlvbnMgPSByZXF1aXJlKCcuL2RpcmVjdGlvbnMnKTtcclxuXHJcbnZhciBfZGlyZWN0aW9uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXJlY3Rpb25zKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9kaXJlY3Rpb25zMi5kZWZhdWx0O1xyXG5cclxufSx7XCIuL2RpcmVjdGlvbnNcIjozOH1dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2FjdGlvbl90eXBlcyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9hY3Rpb25fdHlwZXMuanMnKTtcclxuXHJcbnZhciB0eXBlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9hY3Rpb25fdHlwZXMpO1xyXG5cclxudmFyIF9kZWVwQXNzaWduID0gcmVxdWlyZSgnZGVlcC1hc3NpZ24nKTtcclxuXHJcbnZhciBfZGVlcEFzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwQXNzaWduKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxyXG5cclxudmFyIGluaXRpYWxTdGF0ZSA9IHtcclxuICAvLyBPcHRpb25zIHNldCBvbiBpbml0aWFsaXphdGlvblxyXG4gIGFwaTogJ2h0dHBzOi8vYXBpLm1hcGJveC5jb20vZGlyZWN0aW9ucy92NS8nLFxyXG4gIHByb2ZpbGU6ICdkcml2aW5nLXRyYWZmaWMnLFxyXG4gIHVuaXQ6ICdpbXBlcmlhbCcsXHJcbiAgcHJveGltaXR5OiBmYWxzZSxcclxuICBzdHlsZXM6IFtdLFxyXG5cclxuICAvLyBVSSBjb250cm9sc1xyXG4gIGNvbnRyb2xzOiB7XHJcbiAgICBpbnB1dHM6IHRydWUsXHJcbiAgICBpbnN0cnVjdGlvbnM6IHRydWVcclxuICB9LFxyXG5cclxuICAvLyBPcHRpb25hbCBzZXR0aW5nIHRvIHBhc3Mgb3B0aW9ucyBhdmFpbGFibGUgdG8gbWFwYm94LWdsLWdlb2NvZGVyXHJcbiAgZ2VvY29kZXI6IHt9LFxyXG5cclxuICBpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuXHJcbiAgLy8gQ29udGFpbmVyIGZvciBjbGllbnQgcmVnaXN0ZXJlZCBldmVudHNcclxuICBldmVudHM6IHt9LFxyXG5cclxuICAvLyBNYXJrZXIgZmVhdHVyZSBkcmF3biBvbiB0aGUgbWFwIGF0IGFueSBwb2ludC5cclxuICBvcmlnaW46IHt9LFxyXG4gIGRlc3RpbmF0aW9uOiB7fSxcclxuICBob3Zlck1hcmtlcjoge30sXHJcbiAgd2F5cG9pbnRzOiBbXSxcclxuXHJcbiAgLy8gVXNlciBpbnB1dCBzdHJpbmdzIG9yIHJlc3VsdCByZXR1cm5lZCBmcm9tIGdlb2NvZGVyXHJcbiAgb3JpZ2luUXVlcnk6IG51bGwsXHJcbiAgZGVzdGluYXRpb25RdWVyeTogbnVsbCxcclxuICBvcmlnaW5RdWVyeUNvb3JkaW5hdGVzOiBudWxsLFxyXG4gIGRlc3RpbmF0aW9uUXVlcnlDb29yZGluYXRlczogbnVsbCxcclxuXHJcbiAgLy8gRGlyZWN0aW9ucyBkYXRhXHJcbiAgZGlyZWN0aW9uczogW10sXHJcbiAgcm91dGVJbmRleDogMFxyXG59O1xyXG5cclxuZnVuY3Rpb24gZGF0YSgpIHtcclxuICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBpbml0aWFsU3RhdGUgOiBhcmd1bWVudHNbMF07XHJcbiAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcclxuXHJcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgY2FzZSB0eXBlcy5TRVRfT1BUSU9OUzpcclxuICAgICAgcmV0dXJuICgwLCBfZGVlcEFzc2lnbjIuZGVmYXVsdCkoe30sIHN0YXRlLCBhY3Rpb24ub3B0aW9ucyk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5ESVJFQ1RJT05TX1BST0ZJTEU6XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIHByb2ZpbGU6IGFjdGlvbi5wcm9maWxlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgdHlwZXMuT1JJR0lOOlxyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcclxuICAgICAgICBvcmlnaW46IGFjdGlvbi5vcmlnaW4sXHJcbiAgICAgICAgaG92ZXJNYXJrZXI6IHt9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgdHlwZXMuREVTVElOQVRJT046XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIGRlc3RpbmF0aW9uOiBhY3Rpb24uZGVzdGluYXRpb24sXHJcbiAgICAgICAgaG92ZXJNYXJrZXI6IHt9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgdHlwZXMuSE9WRVJfTUFSS0VSOlxyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcclxuICAgICAgICBob3Zlck1hcmtlcjogYWN0aW9uLmhvdmVyTWFya2VyXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgdHlwZXMuV0FZUE9JTlRTOlxyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcclxuICAgICAgICB3YXlwb2ludHM6IGFjdGlvbi53YXlwb2ludHNcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5PUklHSU5fUVVFUlk6XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIG9yaWdpblF1ZXJ5OiBhY3Rpb24ucXVlcnlcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5ERVNUSU5BVElPTl9RVUVSWTpcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgZGVzdGluYXRpb25RdWVyeTogYWN0aW9uLnF1ZXJ5XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgdHlwZXMuT1JJR0lOX0ZST01fQ09PUkRJTkFURVM6XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIG9yaWdpblF1ZXJ5Q29vcmRpbmF0ZXM6IGFjdGlvbi5jb29yZGluYXRlc1xyXG4gICAgICB9KTtcclxuXHJcbiAgICBjYXNlIHR5cGVzLkRFU1RJTkFUSU9OX0ZST01fQ09PUkRJTkFURVM6XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIGRlc3RpbmF0aW9uUXVlcnlDb29yZGluYXRlczogYWN0aW9uLmNvb3JkaW5hdGVzXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgdHlwZXMuT1JJR0lOX0NMRUFSOlxyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcclxuICAgICAgICBvcmlnaW46IHt9LFxyXG4gICAgICAgIG9yaWdpblF1ZXJ5OiAnJyxcclxuICAgICAgICB3YXlwb2ludHM6IFtdLFxyXG4gICAgICAgIGRpcmVjdGlvbnM6IFtdXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgdHlwZXMuREVTVElOQVRJT05fQ0xFQVI6XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIGRlc3RpbmF0aW9uOiB7fSxcclxuICAgICAgICBkZXN0aW5hdGlvblF1ZXJ5OiAnJyxcclxuICAgICAgICB3YXlwb2ludHM6IFtdLFxyXG4gICAgICAgIGRpcmVjdGlvbnM6IFtdXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgdHlwZXMuRElSRUNUSU9OUzpcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgZGlyZWN0aW9uczogYWN0aW9uLmRpcmVjdGlvbnNcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5ST1VURV9JTkRFWDpcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgcm91dGVJbmRleDogYWN0aW9uLnJvdXRlSW5kZXhcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5FUlJPUjpcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvclxyXG4gICAgICB9KTtcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBkYXRhO1xyXG5cclxufSx7XCIuLi9jb25zdGFudHMvYWN0aW9uX3R5cGVzLmpzXCI6MzQsXCJkZWVwLWFzc2lnblwiOjN9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5mdW5jdGlvbiB2YWxpZENvb3Jkcyhjb29yZHMpIHtcclxuICByZXR1cm4gY29vcmRzWzBdID49IC0xODAgJiYgY29vcmRzWzBdIDw9IDE4MCAmJiBjb29yZHNbMV0gPj0gLTkwICYmIGNvb3Jkc1sxXSA8PSA5MDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29vcmRpbmF0ZU1hdGNoKGEsIGIpIHtcclxuICBhID0gYS5nZW9tZXRyeS5jb29yZGluYXRlcztcclxuICBiID0gYi5nZW9tZXRyeS5jb29yZGluYXRlcztcclxuICByZXR1cm4gYS5qb2luKCkgPT09IGIuam9pbigpIHx8IGFbMF0udG9GaXhlZCgzKSA9PT0gYlswXS50b0ZpeGVkKDMpICYmIGFbMV0udG9GaXhlZCgzKSA9PT0gYlsxXS50b0ZpeGVkKDMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cmFwKG4pIHtcclxuICB2YXIgZCA9IDE4MCAtIC0xODA7XHJcbiAgdmFyIHcgPSAoKG4gLSAtMTgwKSAlIGQgKyBkKSAlIGQgKyAtMTgwO1xyXG4gIHJldHVybiB3ID09PSAtMTgwID8gMTgwIDogdztcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUG9pbnQoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogJ0ZlYXR1cmUnLFxyXG4gICAgZ2VvbWV0cnk6IHtcclxuICAgICAgdHlwZTogJ1BvaW50JyxcclxuICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXHJcbiAgICB9LFxyXG4gICAgcHJvcGVydGllczogcHJvcGVydGllcyA/IHByb3BlcnRpZXMgOiB7fVxyXG4gIH07XHJcbn1cclxuXHJcbnZhciBmb3JtYXQgPSB7XHJcbiAgZHVyYXRpb246IGZ1bmN0aW9uIGR1cmF0aW9uKHMpIHtcclxuICAgIHZhciBtID0gTWF0aC5mbG9vcihzIC8gNjApLFxyXG4gICAgICAgIGggPSBNYXRoLmZsb29yKG0gLyA2MCk7XHJcbiAgICBzICU9IDYwO1xyXG4gICAgbSAlPSA2MDtcclxuICAgIGlmIChoID09PSAwICYmIG0gPT09IDApIHJldHVybiBzICsgJ3MnO1xyXG4gICAgaWYgKGggPT09IDApIHJldHVybiBtICsgJ21pbic7XHJcbiAgICByZXR1cm4gaCArICdoICcgKyBtICsgJ21pbic7XHJcbiAgfSxcclxuICBpbXBlcmlhbDogZnVuY3Rpb24gaW1wZXJpYWwobSkge1xyXG4gICAgdmFyIG1pID0gbSAvIDE2MDkuMzQ0O1xyXG4gICAgaWYgKG1pID49IDEwMCkgcmV0dXJuIG1pLnRvRml4ZWQoMCkgKyAnbWknO1xyXG4gICAgaWYgKG1pID49IDEwKSByZXR1cm4gbWkudG9GaXhlZCgxKSArICdtaSc7XHJcbiAgICBpZiAobWkgPj0gMC4xKSByZXR1cm4gbWkudG9GaXhlZCgyKSArICdtaSc7XHJcbiAgICByZXR1cm4gKG1pICogNTI4MCkudG9GaXhlZCgwKSArICdmdCc7XHJcbiAgfSxcclxuICBtZXRyaWM6IGZ1bmN0aW9uIG1ldHJpYyhtKSB7XHJcbiAgICBpZiAobSA+PSAxMDAwMDApIHJldHVybiAobSAvIDEwMDApLnRvRml4ZWQoMCkgKyAna20nO1xyXG4gICAgaWYgKG0gPj0gMTAwMDApIHJldHVybiAobSAvIDEwMDApLnRvRml4ZWQoMSkgKyAna20nO1xyXG4gICAgaWYgKG0gPj0gMTAwKSByZXR1cm4gKG0gLyAxMDAwKS50b0ZpeGVkKDIpICsgJ2ttJztcclxuICAgIHJldHVybiBtLnRvRml4ZWQoMCkgKyAnbSc7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0geyBmb3JtYXQ6IGZvcm1hdCwgY29vcmRpbmF0ZU1hdGNoOiBjb29yZGluYXRlTWF0Y2gsIGNyZWF0ZVBvaW50OiBjcmVhdGVQb2ludCwgdmFsaWRDb29yZHM6IHZhbGlkQ29vcmRzLCB3cmFwOiB3cmFwIH07XHJcblxyXG59LHt9XX0se30sWzQwXSkoNDApXHJcbn0pO1xyXG4iLCIrZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBpPXtjYWxjOiExfTtlLmZuLnJyc3NiPWZ1bmN0aW9uKHQpe3ZhciBpPWUuZXh0ZW5kKHtkZXNjcmlwdGlvbjpyLGVtYWlsQWRkcmVzczpyLGVtYWlsQm9keTpyLGVtYWlsU3ViamVjdDpyLGltYWdlOnIsdGl0bGU6cix1cmw6cn0sdCk7aS5lbWFpbFN1YmplY3Q9aS5lbWFpbFN1YmplY3R8fGkudGl0bGUsaS5lbWFpbEJvZHk9aS5lbWFpbEJvZHl8fChpLmRlc2NyaXB0aW9uP2kuZGVzY3JpcHRpb246XCJcIikrKGkudXJsP1wiXFxuXFxuXCIraS51cmw6XCJcIik7Zm9yKHZhciBzIGluIGkpaS5oYXNPd25Qcm9wZXJ0eShzKSYmaVtzXSE9PXImJihpW3NdPWEoaVtzXSkpO2kudXJsIT09ciYmKGUodGhpcykuZmluZChcIi5ycnNzYi1mYWNlYm9vayBhXCIpLmF0dHIoXCJocmVmXCIsXCJodHRwczovL3d3dy5mYWNlYm9vay5jb20vc2hhcmVyL3NoYXJlci5waHA/dT1cIitpLnVybCksZSh0aGlzKS5maW5kKFwiLnJyc3NiLXR1bWJsciBhXCIpLmF0dHIoXCJocmVmXCIsXCJodHRwOi8vdHVtYmxyLmNvbS9zaGFyZS9saW5rP3VybD1cIitpLnVybCsoaS50aXRsZSE9PXI/XCImbmFtZT1cIitpLnRpdGxlOlwiXCIpKyhpLmRlc2NyaXB0aW9uIT09cj9cIiZkZXNjcmlwdGlvbj1cIitpLmRlc2NyaXB0aW9uOlwiXCIpKSxlKHRoaXMpLmZpbmQoXCIucnJzc2ItbGlua2VkaW4gYVwiKS5hdHRyKFwiaHJlZlwiLFwiaHR0cDovL3d3dy5saW5rZWRpbi5jb20vc2hhcmVBcnRpY2xlP21pbmk9dHJ1ZSZ1cmw9XCIraS51cmwrKGkudGl0bGUhPT1yP1wiJnRpdGxlPVwiK2kudGl0bGU6XCJcIikrKGkuZGVzY3JpcHRpb24hPT1yP1wiJnN1bW1hcnk9XCIraS5kZXNjcmlwdGlvbjpcIlwiKSksZSh0aGlzKS5maW5kKFwiLnJyc3NiLXR3aXR0ZXIgYVwiKS5hdHRyKFwiaHJlZlwiLFwiaHR0cHM6Ly90d2l0dGVyLmNvbS9pbnRlbnQvdHdlZXQ/dGV4dD1cIisoaS5kZXNjcmlwdGlvbiE9PXI/aS5kZXNjcmlwdGlvbjpcIlwiKStcIiUyMFwiK2kudXJsKSxlKHRoaXMpLmZpbmQoXCIucnJzc2ItaGFja2VybmV3cyBhXCIpLmF0dHIoXCJocmVmXCIsXCJodHRwczovL25ld3MueWNvbWJpbmF0b3IuY29tL3N1Ym1pdGxpbms/dT1cIitpLnVybCsoaS50aXRsZSE9PXI/XCImdGV4dD1cIitpLnRpdGxlOlwiXCIpKSxlKHRoaXMpLmZpbmQoXCIucnJzc2ItdmsgYVwiKS5hdHRyKFwiaHJlZlwiLFwiaHR0cHM6Ly92ay5jb20vc2hhcmUucGhwP3VybD1cIitpLnVybCksZSh0aGlzKS5maW5kKFwiLnJyc3NiLXJlZGRpdCBhXCIpLmF0dHIoXCJocmVmXCIsXCJodHRwOi8vd3d3LnJlZGRpdC5jb20vc3VibWl0P3VybD1cIitpLnVybCsoaS5kZXNjcmlwdGlvbiE9PXI/XCImdGV4dD1cIitpLmRlc2NyaXB0aW9uOlwiXCIpKyhpLnRpdGxlIT09cj9cIiZ0aXRsZT1cIitpLnRpdGxlOlwiXCIpKSxlKHRoaXMpLmZpbmQoXCIucnJzc2ItZ29vZ2xlcGx1cyBhXCIpLmF0dHIoXCJocmVmXCIsXCJodHRwczovL3BsdXMuZ29vZ2xlLmNvbS9zaGFyZT91cmw9XCIraS51cmwpLGUodGhpcykuZmluZChcIi5ycnNzYi1waW50ZXJlc3QgYVwiKS5hdHRyKFwiaHJlZlwiLFwiaHR0cDovL3BpbnRlcmVzdC5jb20vcGluL2NyZWF0ZS9idXR0b24vP3VybD1cIitpLnVybCsoaS5pbWFnZSE9PXI/XCImYW1wO21lZGlhPVwiK2kuaW1hZ2U6XCJcIikrKGkuZGVzY3JpcHRpb24hPT1yP1wiJmRlc2NyaXB0aW9uPVwiK2kuZGVzY3JpcHRpb246XCJcIikpLGUodGhpcykuZmluZChcIi5ycnNzYi1wb2NrZXQgYVwiKS5hdHRyKFwiaHJlZlwiLFwiaHR0cHM6Ly9nZXRwb2NrZXQuY29tL3NhdmU/dXJsPVwiK2kudXJsKSxlKHRoaXMpLmZpbmQoXCIucnJzc2ItZ2l0aHViIGFcIikuYXR0cihcImhyZWZcIixpLnVybCksZSh0aGlzKS5maW5kKFwiLnJyc3NiLXByaW50IGFcIikuYXR0cihcImhyZWZcIixcImphdmFzY3JpcHQ6d2luZG93LnByaW50KClcIiksZSh0aGlzKS5maW5kKFwiLnJyc3NiLXdoYXRzYXBwIGFcIikuYXR0cihcImhyZWZcIixcIndoYXRzYXBwOi8vc2VuZD90ZXh0PVwiKyhpLmRlc2NyaXB0aW9uIT09cj9pLmRlc2NyaXB0aW9uK1wiJTIwXCI6aS50aXRsZSE9PXI/aS50aXRsZStcIiUyMFwiOlwiXCIpK2kudXJsKSksKGkuZW1haWxBZGRyZXNzIT09cnx8aS5lbWFpbFN1YmplY3QpJiZlKHRoaXMpLmZpbmQoXCIucnJzc2ItZW1haWwgYVwiKS5hdHRyKFwiaHJlZlwiLFwibWFpbHRvOlwiKyhpLmVtYWlsQWRkcmVzcz9pLmVtYWlsQWRkcmVzczpcIlwiKStcIj9cIisoaS5lbWFpbFN1YmplY3QhPT1yP1wic3ViamVjdD1cIitpLmVtYWlsU3ViamVjdDpcIlwiKSsoaS5lbWFpbEJvZHkhPT1yP1wiJmJvZHk9XCIraS5lbWFpbEJvZHk6XCJcIikpfTt2YXIgcz1mdW5jdGlvbigpe3ZhciB0PWUoXCI8ZGl2PlwiKSxyPVtcImNhbGNcIixcIi13ZWJraXQtY2FsY1wiLFwiLW1vei1jYWxjXCJdO2UoXCJib2R5XCIpLmFwcGVuZCh0KTtmb3IodmFyIHM9MDtzPHIubGVuZ3RoO3MrKylpZih0LmNzcyhcIndpZHRoXCIscltzXStcIigxcHgpXCIpLDE9PT10LndpZHRoKCkpe2kuY2FsYz1yW3NdO2JyZWFrfXQucmVtb3ZlKCl9LGE9ZnVuY3Rpb24odCl7aWYodCE9PXImJm51bGwhPT10KXtpZihudWxsPT09dC5tYXRjaCgvJVswLTlhLWZdezJ9L2kpKXJldHVybiBlbmNvZGVVUklDb21wb25lbnQodCk7dD1kZWNvZGVVUklDb21wb25lbnQodCksYSh0KX19LG49ZnVuY3Rpb24oKXtlKFwiLnJyc3NiLWJ1dHRvbnNcIikuZWFjaChmdW5jdGlvbih0KXt2YXIgcj1lKHRoaXMpLGk9ZShcImxpOnZpc2libGVcIixyKSxzPWkubGVuZ3RoLGE9MTAwL3M7aS5jc3MoXCJ3aWR0aFwiLGErXCIlXCIpLmF0dHIoXCJkYXRhLWluaXR3aWR0aFwiLGEpfSl9LGw9ZnVuY3Rpb24oKXtlKFwiLnJyc3NiLWJ1dHRvbnNcIikuZWFjaChmdW5jdGlvbih0KXt2YXIgcj1lKHRoaXMpLGk9ci53aWR0aCgpLHM9ZShcImxpXCIscikubm90KFwiLnNtYWxsXCIpLmVxKDApLndpZHRoKCksYT1lKFwibGkuc21hbGxcIixyKS5sZW5ndGg7aWYocz4xNzAmJmE8MSl7ci5hZGRDbGFzcyhcImxhcmdlLWZvcm1hdFwiKTt2YXIgbj1zLzEyK1wicHhcIjtyLmNzcyhcImZvbnQtc2l6ZVwiLG4pfWVsc2Ugci5yZW1vdmVDbGFzcyhcImxhcmdlLWZvcm1hdFwiKSxyLmNzcyhcImZvbnQtc2l6ZVwiLFwiXCIpO2k8MjUqYT9yLnJlbW92ZUNsYXNzKFwic21hbGwtZm9ybWF0XCIpLmFkZENsYXNzKFwidGlueS1mb3JtYXRcIik6ci5yZW1vdmVDbGFzcyhcInRpbnktZm9ybWF0XCIpfSl9LG89ZnVuY3Rpb24oKXtlKFwiLnJyc3NiLWJ1dHRvbnNcIikuZWFjaChmdW5jdGlvbih0KXt2YXIgcj1lKHRoaXMpLGk9ZShcImxpXCIscikscz1pLmZpbHRlcihcIi5zbWFsbFwiKSxhPTAsbj0wLGw9cy5lcSgwKSxvPXBhcnNlRmxvYXQobC5hdHRyKFwiZGF0YS1zaXplXCIpKSs1NSxjPXMubGVuZ3RoO2lmKGM9PT1pLmxlbmd0aCl7dmFyIGQ9NDIqYyx1PXIud2lkdGgoKTtkK288dSYmKHIucmVtb3ZlQ2xhc3MoXCJzbWFsbC1mb3JtYXRcIikscy5lcSgwKS5yZW1vdmVDbGFzcyhcInNtYWxsXCIpLGgoKSl9ZWxzZXtpLm5vdChcIi5zbWFsbFwiKS5lYWNoKGZ1bmN0aW9uKHQpe3ZhciByPWUodGhpcyksaT1wYXJzZUZsb2F0KHIuYXR0cihcImRhdGEtc2l6ZVwiKSkrNTUscz1wYXJzZUZsb2F0KHIud2lkdGgoKSk7YSs9cyxuKz1pfSk7dmFyIG09YS1uO288bSYmKGwucmVtb3ZlQ2xhc3MoXCJzbWFsbFwiKSxoKCkpfX0pfSxjPWZ1bmN0aW9uKHQpe2UoXCIucnJzc2ItYnV0dG9uc1wiKS5lYWNoKGZ1bmN0aW9uKHQpe3ZhciByPWUodGhpcyksaT1lKFwibGlcIixyKTtlKGkuZ2V0KCkucmV2ZXJzZSgpKS5lYWNoKGZ1bmN0aW9uKHQscil7dmFyIHM9ZSh0aGlzKTtpZihzLmhhc0NsYXNzKFwic21hbGxcIik9PT0hMSl7dmFyIGE9cGFyc2VGbG9hdChzLmF0dHIoXCJkYXRhLXNpemVcIikpKzU1LG49cGFyc2VGbG9hdChzLndpZHRoKCkpO2lmKGE+bil7dmFyIGw9aS5ub3QoXCIuc21hbGxcIikubGFzdCgpO2UobCkuYWRkQ2xhc3MoXCJzbWFsbFwiKSxoKCl9fS0tcnx8bygpfSl9KSx0PT09ITAmJnUoaCl9LGg9ZnVuY3Rpb24oKXtlKFwiLnJyc3NiLWJ1dHRvbnNcIikuZWFjaChmdW5jdGlvbih0KXt2YXIgcixzLGEsbCxvLGM9ZSh0aGlzKSxoPWUoXCJsaVwiLGMpLGQ9aC5maWx0ZXIoXCIuc21hbGxcIiksdT1kLmxlbmd0aDt1PjAmJnUhPT1oLmxlbmd0aD8oYy5yZW1vdmVDbGFzcyhcInNtYWxsLWZvcm1hdFwiKSxkLmNzcyhcIndpZHRoXCIsXCI0MnB4XCIpLGE9NDIqdSxyPWgubm90KFwiLnNtYWxsXCIpLmxlbmd0aCxzPTEwMC9yLG89YS9yLGkuY2FsYz09PSExPyhsPShjLmlubmVyV2lkdGgoKS0xKS9yLW8sbD1NYXRoLmZsb29yKDFlMypsKS8xZTMsbCs9XCJweFwiKTpsPWkuY2FsYytcIihcIitzK1wiJSAtIFwiK28rXCJweClcIixoLm5vdChcIi5zbWFsbFwiKS5jc3MoXCJ3aWR0aFwiLGwpKTp1PT09aC5sZW5ndGg/KGMuYWRkQ2xhc3MoXCJzbWFsbC1mb3JtYXRcIiksbigpKTooYy5yZW1vdmVDbGFzcyhcInNtYWxsLWZvcm1hdFwiKSxuKCkpfSksbCgpfSxkPWZ1bmN0aW9uKCl7ZShcIi5ycnNzYi1idXR0b25zXCIpLmVhY2goZnVuY3Rpb24odCl7ZSh0aGlzKS5hZGRDbGFzcyhcInJyc3NiLVwiKyh0KzEpKX0pLHMoKSxuKCksZShcIi5ycnNzYi1idXR0b25zIGxpIC5ycnNzYi10ZXh0XCIpLmVhY2goZnVuY3Rpb24odCl7dmFyIHI9ZSh0aGlzKSxpPXIud2lkdGgoKTtyLmNsb3Nlc3QoXCJsaVwiKS5hdHRyKFwiZGF0YS1zaXplXCIsaSl9KSxjKCEwKX0sdT1mdW5jdGlvbih0KXtlKFwiLnJyc3NiLWJ1dHRvbnMgbGkuc21hbGxcIikucmVtb3ZlQ2xhc3MoXCJzbWFsbFwiKSxjKCksdCgpfSxtPWZ1bmN0aW9uKGUsaSxzLGEpe3ZhciBuPXQuc2NyZWVuTGVmdCE9PXI/dC5zY3JlZW5MZWZ0OnNjcmVlbi5sZWZ0LGw9dC5zY3JlZW5Ub3AhPT1yP3Quc2NyZWVuVG9wOnNjcmVlbi50b3Asbz10LmlubmVyV2lkdGg/dC5pbm5lcldpZHRoOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aD9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg6c2NyZWVuLndpZHRoLGM9dC5pbm5lckhlaWdodD90LmlubmVySGVpZ2h0OmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDpzY3JlZW4uaGVpZ2h0LGg9by8yLXMvMituLGQ9Yy8zLWEvMytsLHU9dC5vcGVuKGUsaSxcInNjcm9sbGJhcnM9eWVzLCB3aWR0aD1cIitzK1wiLCBoZWlnaHQ9XCIrYStcIiwgdG9wPVwiK2QrXCIsIGxlZnQ9XCIraCk7dSYmdS5mb2N1cyYmdS5mb2N1cygpfSxmPWZ1bmN0aW9uKCl7dmFyIHQ9e307cmV0dXJuIGZ1bmN0aW9uKGUscixpKXtpfHwoaT1cIkRvbid0IGNhbGwgdGhpcyB0d2ljZSB3aXRob3V0IGEgdW5pcXVlSWRcIiksdFtpXSYmY2xlYXJUaW1lb3V0KHRbaV0pLHRbaV09c2V0VGltZW91dChlLHIpfX0oKTtlKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe3RyeXtlKGRvY3VtZW50KS5vbihcImNsaWNrXCIsXCIucnJzc2ItYnV0dG9ucyBhLnBvcHVwXCIse30sZnVuY3Rpb24odCl7dmFyIHI9ZSh0aGlzKTttKHIuYXR0cihcImhyZWZcIiksci5maW5kKFwiLnJyc3NiLXRleHRcIikuaHRtbCgpLDU4MCw0NzApLHQucHJldmVudERlZmF1bHQoKX0pfWNhdGNoKHQpe31lKHQpLnJlc2l6ZShmdW5jdGlvbigpe3UoaCksZihmdW5jdGlvbigpe3UoaCl9LDIwMCxcImZpbmlzaGVkIHJlc2l6aW5nXCIpfSksZCgpfSksdC5ycnNzYkluaXQ9ZH0od2luZG93LGpRdWVyeSk7IiwiLypnbG9iYWw6ICQsIG1hcGJveGdsLCBNYXBib3hEaXJlY3Rpb25zLCB0dXJmKi9cclxuXHJcbiQod2luZG93KS5vbihcInNjcm9sbFwiLCBmdW5jdGlvbigpIHtcclxuICB2YXIgc2Nyb2xsVmFsdWUgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XHJcbiAgaWYgKHNjcm9sbFZhbHVlID4gMjIwKSB7XHJcbiAgICAkKFwiLm5hdmJhclwiKS5hZGRDbGFzcyhcImFmZml4XCIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAkKFwiLm5hdmJhclwiKS5yZW1vdmVDbGFzcyhcImFmZml4XCIpO1xyXG4gIH1cclxufSk7XHJcblxyXG4vKkxvYWQgbG9jYXRpb24gKHN0b3JlczIpKi9cclxuZnVuY3Rpb24gbG9hZExvY2F0aW9ucygpIHtcclxuICB2YXIgbG9jYXRpb25zID0gbnVsbDtcclxuICAkLmFqYXgoe1xyXG4gICAgYXN5bmM6IGZhbHNlLFxyXG4gICAgZ2xvYmFsOiBmYWxzZSxcclxuICAgIHVybDogXCJodHRwczovL2xlaXB6aWctZWlua2F1ZmVuLmRlL2xvY2F0aW9uLmpzb25cIixcclxuICAgIC8vXCJ1cmxcIjogXCJodHRwOi8vbG9jYWxob3N0L3ZlY3RvcnRpbGVzL211c2Vlbi5qc29uXCIsXHJcbiAgICBkYXRhVHlwZTogXCJqc29uXCIsXHJcbiAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgIGxvY2F0aW9ucyA9IGRhdGE7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGxvY2F0aW9ucztcclxufVxyXG5cclxudmFyIHN0b3JlczIgPSBsb2FkTG9jYXRpb25zKCk7XHJcbi8vIFNldCBib3VuZHMgdG8gTGVpcHppZywgR2VybWFueVxyXG52YXIgYm91bmRzID0gW1xyXG4gIFsxMi4xNzksIDUxLjIyN10sIC8vIFNvdXRod2VzdCBjb29yZGluYXRlc1xyXG4gIFsxMi42LCA1MS40NTldIC8vIE5vcnRoZWFzdCBjb29yZGluYXRlc1xyXG5dO1xyXG5cclxuLy8gZGVjbGFyZSBtYXBcclxudmFyIG1hcCA9IG5ldyBtYXBib3hnbC5NYXAoe1xyXG4gIGNvbnRhaW5lcjogXCJtYXBcIixcclxuICBzdHlsZTogXCJodHRwczovL2xlaXB6aWctZWlua2F1ZmVuLmRlL2pzb24vc3R5bGUtbG9jYWwuanNvblwiLFxyXG4gIC8vc3R5bGU6IFwiaHR0cDovL2xvY2FsaG9zdC92ZWN0b3J0aWxlcy9qc29uL3N0eWxlLWxvY2FsLmpzb25cIixcclxuXHJcbiAgY2VudGVyOiBbMTIuMzcyMiwgNTEuMzI3Ml0sXHJcbiAgem9vbTogMTEsXHJcbiAgYXR0cmlidXRpb25Db250cm9sOiB0cnVlLFxyXG4gIGhhc2g6IGZhbHNlLFxyXG4gIG1heFpvb206IDE0LjksXHJcbiAgbWF4Qm91bmRzOiBib3VuZHMgLy8gU2V0cyBib3VuZHMgYXMgbWF4XHJcbn0pO1xyXG5cclxuLypEZWNsYXJlIE1hcERpcmVjdGlvbnMqL1xyXG52YXIgbWFwRGlyZWN0aW9ucyA9IG5ldyBNYXBib3hEaXJlY3Rpb25zKCk7XHJcbi8qTWFwRGlyZWN0aW9ucyBTZXR0aW5ncyovXHJcbm1hcERpcmVjdGlvbnMuYWNjZXNzVG9rZW4gPVxyXG4gIFwicGsuZXlKMUlqb2ljMmhsZFdJaUxDSmhJam9pV0d0b2JUTlBOQ0o5LnYySndsTlNHQm1fS3hKVUtFX1dMaWdcIjtcclxubWFwRGlyZWN0aW9ucy51bml0ID0gXCJtZXRyaWNcIjtcclxubWFwRGlyZWN0aW9ucy5wcm94aW1pdHkgPSBmYWxzZTsgLypwcm94aW1pdHkgPz8qL1xyXG5tYXBEaXJlY3Rpb25zLmludGVyYWN0aXZlID0gZmFsc2U7XHJcbm1hcERpcmVjdGlvbnMucHJvZmlsZSA9IFwiZHJpdmluZ1wiOyAvLywgXCJ3YWxraW5nXCIsIFwiY3ljbGluZ1wiO1xyXG4vLyBVSSBjb250cm9sc1xyXG5tYXBEaXJlY3Rpb25zLmNvbnRyb2xzID0ge1xyXG4gIGlucHV0czogdHJ1ZSxcclxuICBpbnN0cnVjdGlvbnM6IGZhbHNlXHJcbn07XHJcblxyXG4vKkFkZCBtYXBEaXJlY3Rpb25zIENvbnRyb2xzKi9cclxubWFwLmFkZENvbnRyb2wobmV3IE1hcGJveERpcmVjdGlvbnMobWFwRGlyZWN0aW9ucyksIFwidG9wLWxlZnRcIik7XHJcblxyXG5tYXAuYWRkQ29udHJvbChcclxuICBuZXcgbWFwYm94Z2wuU2NhbGVDb250cm9sKHtcclxuICAgIG1heFdpZHRoOiA4MCxcclxuICAgIHVuaXQ6IFwibWV0cmljXCJcclxuICB9KVxyXG4pO1xyXG5cclxudmFyIGRpcmVjdGlvbkNvbnRyb2wgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFxyXG4gIFwibWFwYm94Z2wtY3RybC1kaXJlY3Rpb25zXCJcclxuKTtcclxuZGlyZWN0aW9uQ29udHJvbFtcIjBcIl0uaGlkZGVuID0gdHJ1ZTtcclxudmFyIHB0c1dpdGhpbiA9IG51bGw7XHJcblxyXG52YXIgZmlsdGVyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZlYXR1cmUtZmlsdGVyXCIpO1xyXG52YXIgbGlzdGluZ3NFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGlzdGluZ3NcIik7XHJcbnZhciB0eHRDYXRlZ29yaWVzRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInR4dENhdGVnb3JpZXNcIik7XHJcblxyXG4vLyBFbXB0eSBHZW9qc29uIERhdGFcclxudmFyIGJ1ZmZlcmVkTGluZXN0cmluZyA9IHtcclxuICBpZDogXCIwXCIsXHJcbiAgdHlwZTogXCJGZWF0dXJlXCIsXHJcbiAgZ2VvbWV0cnk6IHtcclxuICAgIHR5cGU6IFwiUG9pbnRcIixcclxuICAgIGNvb3JkaW5hdGVzOiBbMCwgMF1cclxuICB9LFxyXG4gIHByb3BlcnRpZXM6IHt9XHJcbn07XHJcblxyXG4vLyBGdW5jdGlvbnNcclxuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nKHN0cmluZykge1xyXG4gIHJldHVybiBzdHJpbmcudHJpbSgpLnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVBvcFVwKGN1cnJlbnRGZWF0dXJlKSB7XHJcbiAgbmV3IG1hcGJveGdsLlBvcHVwKHtcclxuICAgIGNsb3NlT25DbGljazogdHJ1ZVxyXG4gIH0pXHJcbiAgICAuc2V0TG5nTGF0KGN1cnJlbnRGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzKVxyXG4gICAgLnNldEhUTUwoXHJcbiAgICAgIFwiPGgzPlwiICtcclxuICAgICAgICBjdXJyZW50RmVhdHVyZS5wcm9wZXJ0aWVzLm5hbWUgK1xyXG4gICAgICAgIFwiPC9oMz5cIiArXHJcbiAgICAgICAgXCI8aDQ+XCIgK1xyXG4gICAgICAgIGN1cnJlbnRGZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb24gK1xyXG4gICAgICAgIFwiPC9oND5cIlxyXG4gICAgKVxyXG4gICAgLmFkZFRvKG1hcCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFVuaXF1ZUZlYXR1cmVzKGFycmF5LCBjb21wYXJhdG9yUHJvcGVydHkpIHtcclxuICB2YXIgZXhpc3RpbmdGZWF0dXJlS2V5cyA9IHt9O1xyXG4gIC8vIEJlY2F1c2UgZmVhdHVyZXMgY29tZSBmcm9tIHRpbGVkIHZlY3RvciBkYXRhLCBmZWF0dXJlIGdlb21ldHJpZXMgbWF5IGJlIHNwbGl0XHJcbiAgLy8gb3IgZHVwbGljYXRlZCBhY3Jvc3MgdGlsZSBib3VuZGFyaWVzIGFuZCwgYXMgYSByZXN1bHQsIGZlYXR1cmVzIG1heSBhcHBlYXJcclxuICAvLyBtdWx0aXBsZSB0aW1lcyBpbiBxdWVyeSByZXN1bHRzLlxyXG4gIHZhciB1bmlxdWVGZWF0dXJlcyA9IGFycmF5LmZpbHRlcihmdW5jdGlvbihlbCkge1xyXG4gICAgaWYgKGV4aXN0aW5nRmVhdHVyZUtleXNbZWwucHJvcGVydGllc1tjb21wYXJhdG9yUHJvcGVydHldXSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBleGlzdGluZ0ZlYXR1cmVLZXlzW2VsLnByb3BlcnRpZXNbY29tcGFyYXRvclByb3BlcnR5XV0gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB1bmlxdWVGZWF0dXJlcztcclxufVxyXG5cclxuZnVuY3Rpb24gY29sb3JMb2NhdGlvbkxpc3QoZGF0YSkge1xyXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiBzdG9yZXNcclxuICAvLyBXSVRISU4gVEhFIENBTENVTEFURUQgUk9VVEUgISEgYW5kIGNvbG9yIGluIGdyZWVuXHJcbiAgaWYgKGRhdGEubGVuZ3RoKSB7XHJcbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZmVhdHVyZSkge1xyXG4gICAgICAvLyBTaG9ydGVuIGRhdGEuZmVhdHVyZS5wcm9wZXJ0aWVzIHRvIGp1c3QgYHByb3BgLlxyXG4gICAgICB2YXIgcHJvcCA9IGZlYXR1cmUucHJvcGVydGllcztcclxuICAgICAgdmFyIGNhcmRIZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImhlYWRpbmdcIiArIHByb3AuaWQpO1xyXG4gICAgICBpZiAoY2FyZEhlYWRlciA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNhcmRUaXRsZSA9IGNhcmRIZWFkZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInRpdGxlXCIpO1xyXG4gICAgICBjYXJkVGl0bGVbMF0uc3R5bGUuY29sb3IgPSBcIiM2MDhCQzdcIjtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRMb2NhdGlvbkxpc3QoZGF0YSkge1xyXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiBzdG9yZXNcclxuICBsaXN0aW5nc0VsLmlubmVySFRNTCA9IFwiXCI7XHJcbiAgaWYgKGRhdGEubGVuZ3RoKSB7XHJcbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZmVhdHVyZSkge1xyXG4gICAgICAvLyBTaG9ydGVuIGZlYXR1cmUucHJvcGVydGllcyB0byBqdXN0IGBwcm9wYCBzbyB3ZSdyZSBub3Qgd3JpdGluZyB0aGlzIGxvbmcgZm9ybSBvdmVyIGFuZCBvdmVyIGFnYWluLlxyXG4gICAgICB2YXIgcHJvcCA9IGZlYXR1cmUucHJvcGVydGllcztcclxuXHJcbiAgICAgIC8vIFNlbGVjdCB0aGUgbGlzdGluZyBjb250YWluZXIgaW4gdGhlIEhUTUwgYW5kIGFwcGVuZCBhIGRpdiAgd2l0aCB0aGUgY2xhc3MgJ2l0ZW0nIGZvciBlYWNoIHN0b3JlXHJcbiAgICAgIHZhciBjYXJkID0gbGlzdGluZ3NFbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcclxuICAgICAgY2FyZC5jbGFzc05hbWUgPSBcIml0ZW0gY2FyZCBjYXJkTGlzdFwiO1xyXG4gICAgICBjYXJkLmlkID0gcHJvcC5pZDtcclxuXHJcbiAgICAgIHZhciBjYXJkSGVhZGVyID0gY2FyZC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcclxuICAgICAgY2FyZEhlYWRlci5jbGFzc05hbWUgPSBcImNhcmQtaGVhZGVyXCI7XHJcbiAgICAgIGNhcmRIZWFkZXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRhYlwiKTtcclxuXHJcbiAgICAgIGNhcmRIZWFkZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJoZWFkaW5nXCIgKyBjYXJkLmlkKTtcclxuICAgICAgY2FyZEhlYWRlci5pZCA9IFwiaGVhZGluZ1wiICsgY2FyZC5pZDtcclxuXHJcbiAgICAgIHZhciBjYXJkTWIwID0gY2FyZEhlYWRlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDVcIikpO1xyXG4gICAgICBjYXJkTWIwLmNsYXNzTmFtZSA9IFwibWItMFwiO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxpbmsgd2l0aCB0aGUgY2xhc3MgJ3RpdGxlJyBmb3IgZWFjaCBzdG9yZSBhbmQgZmlsbCBpdCB3aXRoIHRoZSBzdG9yZSBhZGRyZXNzXHJcbiAgICAgIHZhciBsaW5rID0gY2FyZE1iMC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSk7XHJcbiAgICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiZGF0YS10b2dnbGVcIiwgXCJjb2xsYXBzZVwiKTtcclxuICAgICAgbGluay5ocmVmID0gXCIjY29sbGFwc2VcIiArIGNhcmQuaWQ7XHJcbiAgICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpO1xyXG4gICAgICBsaW5rLnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIiwgXCJjb2xsYXBzZVwiICsgY2FyZC5pZCk7XHJcbiAgICAgIGxpbmsuY2xhc3NOYW1lID0gXCJ0aXRsZVwiO1xyXG4gICAgICBsaW5rLnRleHRDb250ZW50ID0gcHJvcC5uYW1lO1xyXG4gICAgICBsaW5rLmRhdGFQb3NpdGlvbiA9IGNhcmQuaWQ7XHJcblxyXG4gICAgICB2YXIgY2FyZENvbGxhcHNlID0gY2FyZC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcclxuICAgICAgY2FyZENvbGxhcHNlLmNsYXNzTmFtZSA9IFwiY29sbGFwc2VcIjtcclxuICAgICAgY2FyZENvbGxhcHNlLnNldEF0dHJpYnV0ZShcImlkXCIsIFwiY29sbGFwc2VcIiArIGNhcmQuaWQpO1xyXG4gICAgICBjYXJkQ29sbGFwc2Uuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRhYnBhbmVsXCIpO1xyXG4gICAgICBjYXJkQ29sbGFwc2Uuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbGxlZGJ5XCIsIFwiaGVhZGluZ1wiICsgY2FyZC5pZCk7XHJcbiAgICAgIGNhcmRDb2xsYXBzZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBhcmVudFwiLCBcIiNsaXN0aW5nc1wiKTtcclxuXHJcbiAgICAgIGlmIChwcm9wLmltYWdlKSB7XHJcbiAgICAgICAgdmFyIGNhcmRJbWcgPSBjYXJkQ29sbGFwc2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKSk7XHJcbiAgICAgICAgY2FyZEltZy5jbGFzc05hbWUgPSBcImltZy1yZXNwb25zaXZlIGltZy1saXN0aW5nIGxhenlsb2FkXCI7XHJcbiAgICAgICAgY2FyZEltZy5zcmMgPSBwcm9wLmltYWdlO1xyXG4gICAgICAgIGNhcmRJbWcuYWx0ID0gcHJvcC5uYW1lO1xyXG4gICAgICAgIGNhcmRJbWcudGl0bGUgPSBwcm9wLm5hbWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjYXJkQm9keSA9IGNhcmRDb2xsYXBzZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcclxuICAgICAgY2FyZEJvZHkuY2xhc3NOYW1lID0gXCJjYXJkLWJvZHlcIjtcclxuICAgICAgY2FyZEJvZHkudGV4dENvbnRlbnQgPSBwcm9wLmRlc2NyaXB0aW9uO1xyXG4gICAgICBjYXJkQm9keS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xyXG5cclxuICAgICAgaWYgKHByb3AudXJsKSB7XHJcbiAgICAgICAgdmFyIGxpbmtCb2R5ID0gY2FyZEJvZHkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIikpO1xyXG4gICAgICAgIGxpbmtCb2R5LnRleHRDb250ZW50ID0gcHJvcC5uYW1lO1xyXG4gICAgICAgIGxpbmtCb2R5LmhyZWYgPSBwcm9wLnVybDtcclxuICAgICAgICBsaW5rQm9keS50YXJnZXQgPSBcIl9ibGFua1wiO1xyXG4gICAgICAgIGxpbmtCb2R5LnRpdGxlID0gcHJvcC5uYW1lO1xyXG4gICAgICAgIGxpbmtCb2R5LnJlbCA9IFwibm9vcGVuZXJcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRkIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgbGlua3MgaW4gdGhlIHNpZGViYXIgbGlzdGluZ1xyXG4gICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnRGZWF0dXJlIHRvIHRoZSBzdG9yZSBhc3NvY2lhdGVkIHdpdGggdGhlIGNsaWNrZWQgbGlua1xyXG4gICAgICAgIHZhciBjbGlja2VkTGlzdGluZyA9IHN0b3JlczIuZmVhdHVyZXNbdGhpcy5kYXRhUG9zaXRpb25dO1xyXG5cclxuICAgICAgICB2YXIgcG9wVXBzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm1hcGJveGdsLXBvcHVwXCIpO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBwb3B1cCBvbiB0aGUgbWFwIGFuZCBpZiBzbywgcmVtb3ZlIGl0XHJcbiAgICAgICAgaWYgKHBvcFVwc1swXSkge1xyXG4gICAgICAgICAgcG9wVXBzWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9wVXBzWzBdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDEuIENsb3NlIGFsbCBvdGhlciBwb3B1cHMgYW5kIGRpc3BsYXkgcG9wdXAgZm9yIGNsaWNrZWQgc3RvcmVcclxuICAgICAgICBjcmVhdGVQb3BVcChjbGlja2VkTGlzdGluZyk7XHJcblxyXG4gICAgICAgIC8vIDIuIEhpZ2hsaWdodCBsaXN0aW5nIGluIHNpZGViYXIgKGFuZCByZW1vdmUgaGlnaGxpZ2h0IGZvciBhbGwgb3RoZXIgbGlzdGluZ3MpXHJcbiAgICAgICAgdmFyIGFjdGl2ZUl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaXMtYWN0aXZlXCIpO1xyXG4gICAgICAgIGlmIChhY3RpdmVJdGVtWzBdKSB7XHJcbiAgICAgICAgICBhY3RpdmVJdGVtWzBdLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1hY3RpdmVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChcImlzLWFjdGl2ZVwiKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGVtcHR5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XHJcbiAgICBlbXB0eS50ZXh0Q29udGVudCA9IFwiWmllaGVuIFNpZSBkaWUgS2FydGUsIHVtIGRpZSBFcmdlYm5pc3NlIHp1IGbDvGxsZW5cIjtcclxuICAgIGxpc3RpbmdzRWwuYXBwZW5kQ2hpbGQoZW1wdHkpO1xyXG5cclxuICAgIC8vIHJlbW92ZSBmZWF0dXJlcyBmaWx0ZXJcclxuICAgIG1hcC5zZXRGaWx0ZXIoXCJsb2NhdGlvbnNcIiwgW1wiaGFzXCIsIFwiQ2F0ZWdvcmllc1wiXSk7XHJcbiAgfVxyXG5cclxuICAvLyBQb3B1bGF0ZSBmZWF0dXJlcyBmb3IgdGhlIGxpc3Rpbmcgb3ZlcmxheS5cclxuICBpZiAocHRzV2l0aGluKSB7XHJcbiAgICBjb2xvckxvY2F0aW9uTGlzdChwdHNXaXRoaW4uZmVhdHVyZXMpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyT25Sb3V0ZSgpIHtcclxuICB2YXIgbWFwRGlyZWN0aW9uc1NvdXJjZSA9IG1hcC5nZXRTb3VyY2UoXCJkaXJlY3Rpb25zXCIpO1xyXG4gIHZhciByYWRpdXMgPSAwLjY7XHJcbiAgdmFyIHVuaXQgPSBcImtpbG9tZXRlcnNcIjtcclxuXHJcbiAgLy92YXIgZGlzdER1cmF0aW9uID0gbWFwRGlyZWN0aW9ucy5nZXREaXN0YW5jZUFuZER1cmF0aW9uKCk7XHJcblxyXG4gIC8vIGJ1ZmZlciB0aGUgcm91dGUgd2l0aCBhIGFyZWEgb2YgcmFkaXVzICdyYWRpdXMnXHJcbiAgaWYgKG1hcERpcmVjdGlvbnNTb3VyY2UuX2RhdGEuZmVhdHVyZXMubGVuZ3RoIDwgMikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgYnVmZmVyZWRMaW5lc3RyaW5nID0gdHVyZi5idWZmZXIoXHJcbiAgICBtYXBEaXJlY3Rpb25zU291cmNlLl9kYXRhLmZlYXR1cmVzWzJdLmdlb21ldHJ5LFxyXG4gICAgcmFkaXVzLFxyXG4gICAge1xyXG4gICAgICB1bml0czogdW5pdFxyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIC8vIHVwZGF0ZSBidWZmZXJlZFRyYWNlU291cmNlXHJcbiAgbWFwLmdldFNvdXJjZShcImJ1ZmZlcmVkVHJhY2VTb3VyY2VcIikuc2V0RGF0YShidWZmZXJlZExpbmVzdHJpbmcpO1xyXG5cclxuICAvLyBHZXQgbG9jYXRpb25zIHJlbmRlcmVkIG9uIHRoZSBtYXBcclxuICB2YXIgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKHtcclxuICAgIGxheWVyczogW1wibG9jYXRpb25zXCJdXHJcbiAgfSk7XHJcblxyXG4gIC8vIHVzZSBmZWF0dXJlQ29sbGVjdGlvbiB0byBjb252ZXJ0IGZlYXR1cmVzIChhcnJheSBvZiBmZWF0dXJlcykgaW50byBhIGNvbGxlY3Rpb24gb2YgZmVhdHVyZXMgKE9iamVjdCB0eXBlIEZlYXR1cmVDb2xsZWN0aW9uKTtcclxuICB2YXIgY29sbGVjdGlvbiA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZXMpO1xyXG5cclxuICAvLyBGaWx0ZXIgdGhlIHBvaW50cyB0byB0aGUgYXJlYSBhcm91bmQgdGhlIGRpcmVjdGlvblxyXG4gIHB0c1dpdGhpbiA9IHR1cmYucG9pbnRzV2l0aGluUG9seWdvbihjb2xsZWN0aW9uLCBidWZmZXJlZExpbmVzdHJpbmcpO1xyXG5cclxuICAvLyBQb3B1bGF0ZSBmZWF0dXJlcyBmb3IgdGhlIGxpc3Rpbmcgb3ZlcmxheS5cclxuICBpZiAocHRzV2l0aGluKSB7XHJcbiAgICBidWlsZExvY2F0aW9uTGlzdChmZWF0dXJlcyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkaXNwbGF5RGlyZWN0aW9uQ29udHJvbHMoKSB7XHJcbiAgdmFyIGRpcmVjdGlvbkNvbnRyb2wgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFxyXG4gICAgXCJtYXBib3hnbC1jdHJsLWRpcmVjdGlvbnNcIlxyXG4gICk7XHJcbiAgaWYgKGRpcmVjdGlvbkNvbnRyb2xbXCIwXCJdLmhpZGRlbikge1xyXG4gICAgZGlyZWN0aW9uQ29udHJvbFtcIjBcIl0uaGlkZGVuID0gZmFsc2U7XHJcbiAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJidWZmZXJlZFRyYWNlTGF5ZXJcIiwgXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcclxuXHJcbiAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJkaXJlY3Rpb25zLW9yaWdpbi1wb2ludFwiLCBcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xyXG4gICAgbWFwLnNldExheW91dFByb3BlcnR5KFxyXG4gICAgICBcImRpcmVjdGlvbnMtZGVzdGluYXRpb24tcG9pbnRcIixcclxuICAgICAgXCJ2aXNpYmlsaXR5XCIsXHJcbiAgICAgIFwidmlzaWJsZVwiXHJcbiAgICApO1xyXG4gICAgbWFwLnNldExheW91dFByb3BlcnR5KFwiZGlyZWN0aW9ucy1vcmlnaW4tbGFiZWxcIiwgXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcclxuICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShcclxuICAgICAgXCJkaXJlY3Rpb25zLWRlc3RpbmF0aW9uLWxhYmVsXCIsXHJcbiAgICAgIFwidmlzaWJpbGl0eVwiLFxyXG4gICAgICBcInZpc2libGVcIlxyXG4gICAgKTtcclxuXHJcbiAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJkaXJlY3Rpb25zLWhvdmVyLXBvaW50XCIsIFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcbiAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJkaXJlY3Rpb25zLXdheXBvaW50LXBvaW50XCIsIFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcbiAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJkaXJlY3Rpb25zLXJvdXRlLWxpbmVcIiwgXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcclxuICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShcImRpcmVjdGlvbnMtcm91dGUtbGluZS1hbHRcIiwgXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcclxuICAgIGZpbHRlck9uUm91dGUoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZGlyZWN0aW9uQ29udHJvbFtcIjBcIl0uaGlkZGVuID0gdHJ1ZTtcclxuICAgIC8vIHJlaW5pdGlhbGl6ZSBwdHNXaXRoaW5cclxuICAgIHB0c1dpdGhpbiA9IG51bGw7XHJcblxyXG4gICAgbWFwLnNldExheW91dFByb3BlcnR5KFwiYnVmZmVyZWRUcmFjZUxheWVyXCIsIFwidmlzaWJpbGl0eVwiLCBcIm5vbmVcIik7XHJcbiAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJkaXJlY3Rpb25zLW9yaWdpbi1wb2ludFwiLCBcInZpc2liaWxpdHlcIiwgXCJub25lXCIpO1xyXG4gICAgbWFwLnNldExheW91dFByb3BlcnR5KFwiZGlyZWN0aW9ucy1kZXN0aW5hdGlvbi1wb2ludFwiLCBcInZpc2liaWxpdHlcIiwgXCJub25lXCIpO1xyXG4gICAgbWFwLnNldExheW91dFByb3BlcnR5KFwiZGlyZWN0aW9ucy1vcmlnaW4tbGFiZWxcIiwgXCJ2aXNpYmlsaXR5XCIsIFwibm9uZVwiKTtcclxuICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShcImRpcmVjdGlvbnMtZGVzdGluYXRpb24tbGFiZWxcIiwgXCJ2aXNpYmlsaXR5XCIsIFwibm9uZVwiKTtcclxuXHJcbiAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJkaXJlY3Rpb25zLWhvdmVyLXBvaW50XCIsIFwidmlzaWJpbGl0eVwiLCBcIm5vbmVcIik7XHJcbiAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJkaXJlY3Rpb25zLXdheXBvaW50LXBvaW50XCIsIFwidmlzaWJpbGl0eVwiLCBcIm5vbmVcIik7XHJcbiAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJkaXJlY3Rpb25zLXJvdXRlLWxpbmVcIiwgXCJ2aXNpYmlsaXR5XCIsIFwibm9uZVwiKTtcclxuICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShcImRpcmVjdGlvbnMtcm91dGUtbGluZS1hbHRcIiwgXCJ2aXNpYmlsaXR5XCIsIFwibm9uZVwiKTtcclxuXHJcbiAgICB2YXIgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKHtcclxuICAgICAgbGF5ZXJzOiBbXCJsb2NhdGlvbnNcIl1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChmZWF0dXJlcykge1xyXG4gICAgICAvLyBQb3B1bGF0ZSBmZWF0dXJlcyBmb3IgdGhlIGxpc3Rpbmcgb3ZlcmxheS5cclxuICAgICAgYnVpbGRMb2NhdGlvbkxpc3QoZmVhdHVyZXMpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ2FsbCBidWlsZGxpc3QgZnVuY3Rpb24gb24gaW5pdGlhbGl6YXRpb25cclxuYnVpbGRMb2NhdGlvbkxpc3Qoc3RvcmVzMi5mZWF0dXJlcyk7XHJcblxyXG4vLyBMb2FkIG1hcFxyXG5tYXAub24oXCJsb2FkXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAvL21hcC5sb2FkSW1hZ2UoJ2h0dHA6Ly9sb2NhbGhvc3QvdmVjdG9ydGlsZXMvbWVkaWEvZGlhZ29uYWwtbm9pc2UucG5nJywgZnVuY3Rpb24oZXJyb3IsIGltYWdlKSB7XHJcblxyXG4gIG1hcC5sb2FkSW1hZ2UoXHJcbiAgICBcImh0dHBzOi8vbGVpcHppZy1laW5rYXVmZW4uZGUvbWVkaWEvZGlhZ29uYWwtbm9pc2UucG5nXCIsXHJcbiAgICBmdW5jdGlvbihlcnJvciwgaW1hZ2UpIHtcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgIH1cclxuICAgICAgbWFwLmFkZEltYWdlKFwiYmFja2dyb3VuZF9wYXR0ZXJuXCIsIGltYWdlKTtcclxuICAgIH1cclxuICApO1xyXG5cclxuICAvL21hcC5sb2FkSW1hZ2UoJ2h0dHA6Ly9sb2NhbGhvc3QvdmVjdG9ydGlsZXMvbWVkaWEvTWFya2VyX3dpdGhfU2hhZG93LnBuZycsIGZ1bmN0aW9uKGVycm9yLCBpbWFnZSkge1xyXG4gIG1hcC5sb2FkSW1hZ2UoXHJcbiAgICBcImh0dHBzOi8vbGVpcHppZy1laW5rYXVmZW4uZGUvbWVkaWEvTWFya2VyX3dpdGhfU2hhZG93LnBuZ1wiLFxyXG4gICAgZnVuY3Rpb24oZXJyb3IsIGltYWdlKSB7XHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICB9XHJcbiAgICAgIG1hcC5hZGRJbWFnZShcIm1hcmtlcl96XCIsIGltYWdlKTtcclxuXHJcbiAgICAgIC8vIEFkZCB0aGUgc3RvcmVzMiAobG9jYXRpb25zX3NvdXJjZSkgdG8gdGhlIG1hcFxyXG4gICAgICBtYXAuYWRkU291cmNlKFwibG9jYXRpb25zX3NvdXJjZVwiLCB7XHJcbiAgICAgICAgdHlwZTogXCJnZW9qc29uXCIsXHJcbiAgICAgICAgZGF0YTogc3RvcmVzMlxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEFkZCB0aGUgbG9jYXRpb25zX3NvdXJjZSB0byB0aGUgbWFwIGFzIGEgbGF5ZXJcclxuICAgICAgbWFwLmFkZExheWVyKHtcclxuICAgICAgICBpZDogXCJsb2NhdGlvbnNcIixcclxuICAgICAgICB0eXBlOiBcInN5bWJvbFwiLFxyXG4gICAgICAgIC8vIEFkZCBhIEdlb0pTT04gc291cmNlIGNvbnRhaW5pbmcgcGxhY2UgY29vcmRpbmF0ZXMgYW5kIGluZm9ybWF0aW9uLlxyXG4gICAgICAgIHNvdXJjZTogXCJsb2NhdGlvbnNfc291cmNlXCIsXHJcbiAgICAgICAgbGF5b3V0OiB7XHJcbiAgICAgICAgICB2aXNpYmlsaXR5OiBcInZpc2libGVcIixcclxuICAgICAgICAgIFwiaWNvbi1pbWFnZVwiOiBcIm1hcmtlcl96XCIsXHJcbiAgICAgICAgICBcImljb24tc2l6ZVwiOiAwLjksXHJcbiAgICAgICAgICBcImljb24tYWxsb3ctb3ZlcmxhcFwiOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEFkZCB0aGUgYnVmZmVyZWRMaW5lc3RyaW5nIHRvIHRoZSBtYXAgYXMgYSBsYXllclxyXG4gICAgICBtYXAuYWRkU291cmNlKFwiYnVmZmVyZWRUcmFjZVNvdXJjZVwiLCB7XHJcbiAgICAgICAgdHlwZTogXCJnZW9qc29uXCIsXHJcbiAgICAgICAgZGF0YTogYnVmZmVyZWRMaW5lc3RyaW5nLFxyXG4gICAgICAgIG1heHpvb206IDEzXHJcbiAgICAgIH0pO1xyXG4gICAgICBtYXAuYWRkTGF5ZXIoe1xyXG4gICAgICAgIGlkOiBcImJ1ZmZlcmVkVHJhY2VMYXllclwiLFxyXG4gICAgICAgIHR5cGU6IFwiZmlsbFwiLFxyXG4gICAgICAgIHNvdXJjZTogXCJidWZmZXJlZFRyYWNlU291cmNlXCIsXHJcbiAgICAgICAgbGF5b3V0OiB7XHJcbiAgICAgICAgICB2aXNpYmlsaXR5OiBcInZpc2libGVcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFpbnQ6IHtcclxuICAgICAgICAgIFwiZmlsbC1jb2xvclwiOiBcInJnYigwLDAsMClcIixcclxuICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IDEsXHJcbiAgICAgICAgICBcImZpbGwtdHJhbnNsYXRlXCI6IFswLCAyLjVdLFxyXG4gICAgICAgICAgXCJmaWxsLXBhdHRlcm5cIjogXCJiYWNrZ3JvdW5kX3BhdHRlcm5cIlxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBBZGQgRnVsbHNjcmVlbiBjb250cm9sIHRvIHRoZSBtYXAuXHJcbiAgICAgIG1hcC5hZGRDb250cm9sKG5ldyBtYXBib3hnbC5GdWxsc2NyZWVuQ29udHJvbCgpKTtcclxuXHJcbiAgICAgIC8vIEFkZCBnZW9sb2NhdGUgY29udHJvbCB0byB0aGUgbWFwLlxyXG4gICAgICBtYXAuYWRkQ29udHJvbChcclxuICAgICAgICBuZXcgbWFwYm94Z2wuR2VvbG9jYXRlQ29udHJvbCh7XHJcbiAgICAgICAgICBwb3NpdGlvbk9wdGlvbnM6IHtcclxuICAgICAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdHJhY2tVc2VyTG9jYXRpb246IHRydWVcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gV2hlbiBhIGNsaWNrIGV2ZW50IG9jY3VycyBvbiBhIGZlYXR1cmUgaW4gdGhlIHBsYWNlcyBsYXllciwgb3BlbiBhIHBvcHVwIGF0IHRoZVxyXG4gICAgICAvLyBsb2NhdGlvbiBvZiB0aGUgZmVhdHVyZSwgd2l0aCBkZXNjcmlwdGlvbiBIVE1MIGZyb20gaXRzIHByb3BlcnRpZXMuXHJcbiAgICAgIG1hcC5vbihcImNsaWNrXCIsIFwibG9jYXRpb25zXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICB2YXIgY3VycmVudEZlYXR1cmUgPSBlLmZlYXR1cmVzWzBdO1xyXG4gICAgICAgIC8vIDEuIENyZWF0ZSBQb3B1cFxyXG4gICAgICAgIGNyZWF0ZVBvcFVwKGN1cnJlbnRGZWF0dXJlKTtcclxuXHJcbiAgICAgICAgLy8gMi4gSGlnaGxpZ2h0IGxpc3RpbmcgaW4gc2lkZWJhciAoYW5kIHJlbW92ZSBoaWdobGlnaHQgZm9yIG90aGVyIGxpc3RpbmcpXHJcbiAgICAgICAgdmFyIGFjdGl2ZUl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaXMtYWN0aXZlXCIpO1xyXG4gICAgICAgIGlmIChhY3RpdmVJdGVtWzBdKSB7XHJcbiAgICAgICAgICBhY3RpdmVJdGVtWzBdLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1hY3RpdmVcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaGVhZGluZ0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcclxuICAgICAgICAgIFwiaGVhZGluZ1wiICsgY3VycmVudEZlYXR1cmUucHJvcGVydGllcy5pZFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKGhlYWRpbmdFbGVtZW50KSB7XHJcbiAgICAgICAgICBoZWFkaW5nRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaXMtYWN0aXZlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29sbGFwc2VFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXHJcbiAgICAgICAgICBcImNvbGxhcHNlXCIgKyBjdXJyZW50RmVhdHVyZS5wcm9wZXJ0aWVzLmlkXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAoY29sbGFwc2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAkKGNvbGxhcHNlRWxlbWVudCkuY29sbGFwc2UoXCJzaG93XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBtYXAub24oXCJtb3ZlZW5kXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIFF1ZXJ5IGFsbCB0aGUgcmVuZGVyZWQgcG9pbnRzIGluIHRoZSB2aWV3XHJcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gbWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyh7XHJcbiAgICAgICAgICBsYXllcnM6IFtcImxvY2F0aW9uc1wiXVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoZmVhdHVyZXMpIHtcclxuICAgICAgICAgIC8vdmFyIHVuaXF1ZUZlYXR1cmVzID0gZ2V0VW5pcXVlRmVhdHVyZXMoZmVhdHVyZXMsIFwiQ2F0ZWdvcmllc1wiKTtcclxuXHJcbiAgICAgICAgICAvLyBQb3B1bGF0ZSBmZWF0dXJlcyBmb3IgdGhlIGxpc3Rpbmcgb3ZlcmxheS5cclxuICAgICAgICAgIGJ1aWxkTG9jYXRpb25MaXN0KGZlYXR1cmVzKTtcclxuXHJcbiAgICAgICAgICAvLyBDbGVhciB0aGUgaW5wdXQgY29udGFpbmVyXHJcbiAgICAgICAgICBmaWx0ZXJFbC52YWx1ZSA9IFwiXCI7XHJcblxyXG4gICAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgZmVhdHVyZXMgaW4gc24gYGxvY2F0aW9uc19vbl9tYXBgIHZhcmlhYmxlIHRvIGxhdGVyIHVzZSBmb3IgZmlsdGVyaW5nIG9uIGBrZXl1cGAuXHJcbiAgICAgICAgICAvL2xvY2F0aW9ucyA9IGZlYXR1cmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBtYXAub24oXCJtb3VzZW1vdmVcIiwgXCJsb2NhdGlvbnNcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gQ2hhbmdlIHRoZSBjdXJzb3Igc3R5bGUgYXMgYSBVSSBpbmRpY2F0b3IuXHJcbiAgICAgICAgbWFwLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIG1hcC5vbihcIm1vdXNlbGVhdmVcIiwgXCJsb2NhdGlvbnNcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgbWFwLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9IFwiXCI7XHJcbiAgICAgICAgLy9wb3B1cC5yZW1vdmUoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAkKFwiLmRyb3Bkb3duLWl0ZW1cIikuY2xpY2soZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplU3RyaW5nKCQodGhpcykudGV4dCgpKTtcclxuXHJcbiAgICAgICAgdmFyIGZpbHRlcmVkID0gbWFwLnF1ZXJ5U291cmNlRmVhdHVyZXMoXCJsb2NhdGlvbnNfc291cmNlXCIpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gXCJhbGxlXCIpIHtcclxuICAgICAgICAgIC8vIEZpbHRlciB2aXNpYmxlIGZlYXR1cmVzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIGlucHV0IHZhbHVlLlxyXG4gICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoZnVuY3Rpb24oZmVhdHVyZSkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5vcm1hbGl6ZVN0cmluZyhmZWF0dXJlLnByb3BlcnRpZXMubmFtZSk7XHJcbiAgICAgICAgICAgIHZhciBDYXRlZ29yaWVzID0gbm9ybWFsaXplU3RyaW5nKGZlYXR1cmUucHJvcGVydGllcy5DYXRlZ29yaWVzKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWUuaW5kZXhPZih2YWx1ZSkgPiAtMSB8fCBDYXRlZ29yaWVzLmluZGV4T2YodmFsdWUpID4gLTE7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmaWx0ZXJlZCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHVuaXF1ZUZlYXR1cmVzID0gZ2V0VW5pcXVlRmVhdHVyZXMoZmlsdGVyZWQsIFwiQ2F0ZWdvcmllc1wiKTtcclxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgc2lkZWJhciB3aXRoIGZpbHRlcmVkIHJlc3VsdHNcclxuICAgICAgICBidWlsZExvY2F0aW9uTGlzdCh1bmlxdWVGZWF0dXJlcyk7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgZmlsdGVyIHRvIHBvcHVsYXRlIGZlYXR1cmVzIGludG8gdGhlIGxheWVyLlxyXG4gICAgICAgIG1hcC5zZXRGaWx0ZXIoXHJcbiAgICAgICAgICBcImxvY2F0aW9uc1wiLFxyXG4gICAgICAgICAgW1wiaW5cIiwgXCJuYW1lXCJdLmNvbmNhdChcclxuICAgICAgICAgICAgdW5pcXVlRmVhdHVyZXMubWFwKGZ1bmN0aW9uKGZlYXR1cmUpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLm5hbWU7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdHh0Q2F0ZWdvcmllc0VsLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICk7XHJcbn0pO1xyXG5cclxuLy8gRGlyZWN0aW9uIGV2ZW50IGxpc3RlbmVyXHJcbm1hcERpcmVjdGlvbnMub24oXCJyb3V0ZVwiLCBmdW5jdGlvbigpIHtcclxuICBmaWx0ZXJPblJvdXRlKCk7XHJcbn0pO1xyXG5cclxuLy8gRGlzcGxheSBEaXJlY3Rpb25cclxuJChcIiNidG5EaXNwbGF5Q29udHJvbHNcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcclxuICBkaXNwbGF5RGlyZWN0aW9uQ29udHJvbHMoKTtcclxufSk7XHJcbiJdfQ==
