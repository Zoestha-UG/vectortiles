(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.MapboxDirections = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError("n must be a positive number");
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error("(node) warning: possible EventEmitter memory " +
                    "leak detected. %d listeners added. " +
					"Use emitter.setMaxListeners() to increase limit.",
                    this._events[type].length);
      if (typeof console.trace === "function") {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
    try {
        cachedSetTimeout = setTimeout;
    } catch (e) {
        cachedSetTimeout = function () {
            throw new Error('setTimeout is not defined');
        }
    }
    try {
        cachedClearTimeout = clearTimeout;
    } catch (e) {
        cachedClearTimeout = function () {
            throw new Error('clearTimeout is not defined');
        }
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
'use strict';
var isObj = require('is-obj');
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Sources cannot be null or undefined');
	}

	return Object(val);
}

function assignKey(to, from, key) {
	var val = from[key];

	if (val === undefined || val === null) {
		return;
	}

	if (hasOwnProperty.call(to, key)) {
		if (to[key] === undefined || to[key] === null) {
			throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
		}
	}

	if (!hasOwnProperty.call(to, key) || !isObj(val)) {
		to[key] = val;
	} else {
		to[key] = assign(Object(to[key]), from[key]);
	}
}

function assign(to, from) {
	if (to === from) {
		return to;
	}

	from = Object(from);

	for (var key in from) {
		if (hasOwnProperty.call(from, key)) {
			assignKey(to, from, key);
		}
	}

	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(from);

		for (var i = 0; i < symbols.length; i++) {
			if (propIsEnumerable.call(from, symbols[i])) {
				assignKey(to, from, symbols[i]);
			}
		}
	}

	return to;
}

module.exports = function deepAssign(target) {
	target = toObject(target);

	for (var s = 1; s < arguments.length; s++) {
		assign(target, arguments[s]);
	}

	return target;
};

},{"is-obj":4}],4:[function(require,module,exports){
'use strict';
module.exports = function (x) {
	var type = typeof x;
	return x !== null && (type === 'object' || type === 'function');
};

},{}],5:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],6:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = isEqual;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],7:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var reInterpolate = require('lodash._reinterpolate'),
    templateSettings = require('lodash.templatesettings');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to ensure capturing order of template delimiters. */
var reNoMatch = /($^)/;

/** Used to match unescaped characters in compiled string literals. */
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol,
    propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Used by `_.defaults` to customize its `_.assignIn` use.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function assignInDefaults(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  return (objectToString.call(value) == errorTag) ||
    (typeof value.message == 'string' && typeof value.name == 'string');
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES delimiter as an alternative to the default "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */
function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }
  string = toString(string);
  options = assignInWith({}, options, settings, assignInDefaults);

  var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);

  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '";

  // Compile the regexp to match each delimiter.
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + '|' +
    interpolate.source + '|' +
    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
    (options.evaluate || reNoMatch).source + '|$'
  , 'g');

  // Use a sourceURL for easier debugging.
  var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';

  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);

    // Escape characters that can't be included in string literals.
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

    // Replace delimiters with snippets.
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;

    // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.
    return match;
  });

  source += "';\n";

  // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable = options.variable;
  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  }
  // Cleanup code by stripping empty strings.
  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
    .replace(reEmptyStringMiddle, '$1')
    .replace(reEmptyStringTrailing, '$1;');

  // Frame code as the function body.
  source = 'function(' + (variable || 'obj') + ') {\n' +
    (variable
      ? ''
      : 'obj || (obj = {});\n'
    ) +
    "var __t, __p = ''" +
    (isEscaping
       ? ', __e = _.escape'
       : ''
    ) +
    (isEvaluating
      ? ', __j = Array.prototype.join;\n' +
        "function print() { __p += __j.call(arguments, '') }\n"
      : ';\n'
    ) +
    source +
    'return __p\n}';

  var result = attempt(function() {
    return Function(importsKeys, sourceURL + 'return ' + source)
      .apply(undefined, importsValues);
  });

  // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = baseRest(function(func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

module.exports = template;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"lodash._reinterpolate":8,"lodash.templatesettings":9}],8:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

module.exports = reInterpolate;

},{}],9:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var reInterpolate = require('lodash._reinterpolate');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"'`]/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g,
    reEvaluate = /<%([\s\S]+?)%>/g;

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '`': '&#96;'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB). Change the following template settings to use
 * alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {

  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {

    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': { 'escape': escape }
  }
};

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
 * their corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * Backticks are escaped because in IE < 9, they can break out of
 * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
 * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
 * [#133](https://html5sec.org/#133) of the
 * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = templateSettings;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"lodash._reinterpolate":8}],10:[function(require,module,exports){
'use strict';

/**
 * Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
 *
 * Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)
 * by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)
 *
 * @module polyline
 */

var polyline = {};

function encode(coordinate, factor) {
    coordinate = Math.round(coordinate * factor);
    coordinate <<= 1;
    if (coordinate < 0) {
        coordinate = ~coordinate;
    }
    var output = '';
    while (coordinate >= 0x20) {
        output += String.fromCharCode((0x20 | (coordinate & 0x1f)) + 63);
        coordinate >>= 5;
    }
    output += String.fromCharCode(coordinate + 63);
    return output;
}

/**
 * Decodes to a [latitude, longitude] coordinates array.
 *
 * This is adapted from the implementation in Project-OSRM.
 *
 * @param {String} str
 * @param {Number} precision
 * @returns {Array}
 *
 * @see https://github.com/Project-OSRM/osrm-frontend/blob/master/WebContent/routing/OSRM.RoutingGeometry.js
 */
polyline.decode = function(str, precision) {
    var index = 0,
        lat = 0,
        lng = 0,
        coordinates = [],
        shift = 0,
        result = 0,
        byte = null,
        latitude_change,
        longitude_change,
        factor = Math.pow(10, precision || 5);

    // Coordinates have variable length when encoded, so just keep
    // track of whether we've hit the end of the string. In each
    // loop iteration, a single coordinate is decoded.
    while (index < str.length) {

        // Reset shift, result, and byte
        byte = null;
        shift = 0;
        result = 0;

        do {
            byte = str.charCodeAt(index++) - 63;
            result |= (byte & 0x1f) << shift;
            shift += 5;
        } while (byte >= 0x20);

        latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

        shift = result = 0;

        do {
            byte = str.charCodeAt(index++) - 63;
            result |= (byte & 0x1f) << shift;
            shift += 5;
        } while (byte >= 0x20);

        longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

        lat += latitude_change;
        lng += longitude_change;

        coordinates.push([lat / factor, lng / factor]);
    }

    return coordinates;
};

/**
 * Encodes the given [latitude, longitude] coordinates array.
 *
 * @param {Array.<Array.<Number>>} coordinates
 * @param {Number} precision
 * @returns {String}
 */
polyline.encode = function(coordinates, precision) {
    if (!coordinates.length) { return ''; }

    var factor = Math.pow(10, precision || 5),
        output = encode(coordinates[0][0], factor) + encode(coordinates[0][1], factor);

    for (var i = 1; i < coordinates.length; i++) {
        var a = coordinates[i], b = coordinates[i - 1];
        output += encode(a[0] - b[0], factor);
        output += encode(a[1] - b[1], factor);
    }

    return output;
};

function flipped(coords) {
    var flipped = [];
    for (var i = 0; i < coords.length; i++) {
        flipped.push(coords[i].slice().reverse());
    }
    return flipped;
}

/**
 * Encodes a GeoJSON LineString feature/geometry.
 *
 * @param {Object} geojson
 * @param {Number} precision
 * @returns {String}
 */
polyline.fromGeoJSON = function(geojson, precision) {
    if (geojson && geojson.type === 'Feature') {
        geojson = geojson.geometry;
    }
    if (!geojson || geojson.type !== 'LineString') {
        throw new Error('Input must be a GeoJSON LineString');
    }
    return polyline.encode(flipped(geojson.coordinates), precision);
};

/**
 * Decodes to a GeoJSON LineString geometry.
 *
 * @param {String} str
 * @param {Number} precision
 * @returns {Object}
 */
polyline.toGeoJSON = function(str, precision) {
    var coords = polyline.decode(str, precision);
    return {
        type: 'LineString',
        coordinates: flipped(coords)
    };
};

if (typeof module === 'object' && module.exports) {
    module.exports = polyline;
}

},{}],11:[function(require,module,exports){
'use strict';

exports.__esModule = true;
function createThunkMiddleware(extraArgument) {
  return function (_ref) {
    var dispatch = _ref.dispatch;
    var getState = _ref.getState;
    return function (next) {
      return function (action) {
        if (typeof action === 'function') {
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    };
  };
}

var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

exports['default'] = thunk;
},{}],12:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports["default"] = applyMiddleware;

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, initialState, enhancer) {
      var store = createStore(reducer, initialState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}
},{"./compose":15}],13:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports["default"] = bindActionCreators;
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
},{}],14:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;
exports["default"] = combineReducers;

var _createStore = require('./createStore');

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _warning = require('./utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!(0, _isPlainObject2["default"])(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key);
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerSanity(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];
    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  var sanityError;
  try {
    assertReducerSanity(finalReducers);
  } catch (e) {
    sanityError = e;
  }

  return function combination() {
    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var action = arguments[1];

    if (sanityError) {
      throw sanityError;
    }

    if (process.env.NODE_ENV !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
      if (warningMessage) {
        (0, _warning2["default"])(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var i = 0; i < finalReducerKeys.length; i++) {
      var key = finalReducerKeys[i];
      var reducer = finalReducers[key];
      var previousStateForKey = state[key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(key, action);
        throw new Error(errorMessage);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}
}).call(this,require('_process'))
},{"./createStore":16,"./utils/warning":18,"_process":2,"lodash/isPlainObject":23}],15:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = compose;
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  } else {
    var _ret = function () {
      var last = funcs[funcs.length - 1];
      var rest = funcs.slice(0, -1);
      return {
        v: function v() {
          return rest.reduceRight(function (composed, f) {
            return f(composed);
          }, last.apply(undefined, arguments));
        }
      };
    }();

    if (typeof _ret === "object") return _ret.v;
  }
}
},{}],16:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.ActionTypes = undefined;
exports["default"] = createStore;

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _symbolObservable = require('symbol-observable');

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = exports.ActionTypes = {
  INIT: '@@redux/INIT'
};

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [initialState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} enhancer The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */
function createStore(reducer, initialState, enhancer) {
  var _ref2;

  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
    enhancer = initialState;
    initialState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, initialState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = initialState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!(0, _isPlainObject2["default"])(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      listeners[i]();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/zenparsing/es-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */

      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[_symbolObservable2["default"]] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
}
},{"lodash/isPlainObject":23,"symbol-observable":24}],17:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;
exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

var _createStore = require('./createStore');

var _createStore2 = _interopRequireDefault(_createStore);

var _combineReducers = require('./combineReducers');

var _combineReducers2 = _interopRequireDefault(_combineReducers);

var _bindActionCreators = require('./bindActionCreators');

var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

var _applyMiddleware = require('./applyMiddleware');

var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

var _warning = require('./utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}

exports.createStore = _createStore2["default"];
exports.combineReducers = _combineReducers2["default"];
exports.bindActionCreators = _bindActionCreators2["default"];
exports.applyMiddleware = _applyMiddleware2["default"];
exports.compose = _compose2["default"];
}).call(this,require('_process'))
},{"./applyMiddleware":12,"./bindActionCreators":13,"./combineReducers":14,"./compose":15,"./createStore":16,"./utils/warning":18,"_process":2}],18:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports["default"] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}
},{}],19:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":21}],20:[function(require,module,exports){
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

module.exports = isHostObject;

},{}],21:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],22:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],23:[function(require,module,exports){
var getPrototype = require('./_getPrototype'),
    isHostObject = require('./_isHostObject'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) ||
      objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return (typeof Ctor == 'function' &&
    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
}

module.exports = isPlainObject;

},{"./_getPrototype":19,"./_isHostObject":20,"./isObjectLike":22}],24:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

module.exports = require('./ponyfill')(global || window || this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./ponyfill":25}],25:[function(require,module,exports){
'use strict';

module.exports = function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

},{}],26:[function(require,module,exports){
'use strict';

/**
 * A typeahead component for inputs
 * @class Suggestions
 *
 * @param {HTMLInputElement} el A valid HTML input element
 * @param {Array} data An array of data used for results
 * @param {Object} options
 * @param {Number} [options.limit=5] Max number of results to display in the auto suggest list.
 * @param {Number} [options.minLength=2] Number of characters typed into an input to trigger suggestions.
 * @return {Suggestions} `this`
 * @example
 * // in the browser
 * var input = document.querySelector('input');
 * var data = [
 *   'Roy Eldridge',
 *   'Roy Hargrove',
 *   'Rex Stewart'
 * ];
 *
 * new Suggestions(input, data);
 *
 * // with options
 * var input = document.querySelector('input');
 * var data = [{
 *   name: 'Roy Eldridge',
 *   year: 1911
 * }, {
 *   name: 'Roy Hargrove',
 *   year: 1969
 * }, {
 *   name: 'Rex Stewart',
 *   year: 1907
 * }];
 *
 * var typeahead = new Suggestions(input, data, {
 *   filter: false, // Disable filtering
 *   minLength: 3, // Number of characters typed into an input to trigger suggestions.
 *   limit: 3 //  Max number of results to display.
 * });
 *
 * // As we're passing an object of an arrays as data, override
 * // `getItemValue` by specifying the specific property to search on.
 * typeahead.getItemValue = function(item) { return item.name };
 *
 * input.addEventListener('change', function() {
 *   console.log(typeahead.selected); // Current selected item.
 * });
 *
 * // With browserify
 * var Suggestions = require('suggestions');
 *
 * new Suggestions(input, data);
 */
var Suggestions = require('./src/suggestions');
window.Suggestions = module.exports = Suggestions;

},{"./src/suggestions":29}],27:[function(require,module,exports){
/*
 * Fuzzy
 * https://github.com/myork/fuzzy
 *
 * Copyright (c) 2012 Matt York
 * Licensed under the MIT license.
 */

(function() {

var root = this;

var fuzzy = {};

// Use in node or in browser
if (typeof exports !== 'undefined') {
  module.exports = fuzzy;
} else {
  root.fuzzy = fuzzy;
}

// Return all elements of `array` that have a fuzzy
// match against `pattern`.
fuzzy.simpleFilter = function(pattern, array) {
  return array.filter(function(string) {
    return fuzzy.test(pattern, string);
  });
};

// Does `pattern` fuzzy match `string`?
fuzzy.test = function(pattern, string) {
  return fuzzy.match(pattern, string) !== null;
};

// If `pattern` matches `string`, wrap each matching character
// in `opts.pre` and `opts.post`. If no match, return null
fuzzy.match = function(pattern, string, opts) {
  opts = opts || {};
  var patternIdx = 0
    , result = []
    , len = string.length
    , totalScore = 0
    , currScore = 0
    // prefix
    , pre = opts.pre || ''
    // suffix
    , post = opts.post || ''
    // String to compare against. This might be a lowercase version of the
    // raw string
    , compareString =  opts.caseSensitive && string || string.toLowerCase()
    , ch, compareChar;

  pattern = opts.caseSensitive && pattern || pattern.toLowerCase();

  // For each character in the string, either add it to the result
  // or wrap in template if it's the next string in the pattern
  for(var idx = 0; idx < len; idx++) {
    ch = string[idx];
    if(compareString[idx] === pattern[patternIdx]) {
      ch = pre + ch + post;
      patternIdx += 1;

      // consecutive characters should increase the score more than linearly
      currScore += 1 + currScore;
    } else {
      currScore = 0;
    }
    totalScore += currScore;
    result[result.length] = ch;
  }

  // return rendered string if we have a match for every char
  if(patternIdx === pattern.length) {
    return {rendered: result.join(''), score: totalScore};
  }

  return null;
};

// The normal entry point. Filters `arr` for matches against `pattern`.
// It returns an array with matching values of the type:
//
//     [{
//         string:   '<b>lah' // The rendered string
//       , index:    2        // The index of the element in `arr`
//       , original: 'blah'   // The original element in `arr`
//     }]
//
// `opts` is an optional argument bag. Details:
//
//    opts = {
//        // string to put before a matching character
//        pre:     '<b>'
//
//        // string to put after matching character
//      , post:    '</b>'
//
//        // Optional function. Input is an entry in the given arr`,
//        // output should be the string to test `pattern` against.
//        // In this example, if `arr = [{crying: 'koala'}]` we would return
//        // 'koala'.
//      , extract: function(arg) { return arg.crying; }
//    }
fuzzy.filter = function(pattern, arr, opts) {
  opts = opts || {};
  return arr
    .reduce(function(prev, element, idx, arr) {
      var str = element;
      if(opts.extract) {
        str = opts.extract(element);
      }
      var rendered = fuzzy.match(pattern, str, opts);
      if(rendered != null) {
        prev[prev.length] = {
            string: rendered.rendered
          , score: rendered.score
          , index: idx
          , original: element
        };
      }
      return prev;
    }, [])

    // Sort by score. Browsers are inconsistent wrt stable/unstable
    // sorting, so force stable by using the index in the case of tie.
    // See http://ofb.net/~sethml/is-sort-stable.html
    .sort(function(a,b) {
      var compare = b.score - a.score;
      if(compare) return compare;
      return a.index - b.index;
    });
};


}());


},{}],28:[function(require,module,exports){
'Use strict';

var List = function(component) {
  this.component = component;
  this.items = [];
  this.active = 0;
  this.element = document.createElement('ul');
  this.element.className = 'suggestions';

  component.el.parentNode.insertBefore(this.element, component.el.nextSibling);
  return this;
};

List.prototype.show = function() {
  this.element.style.display = 'block';
};

List.prototype.hide = function() {
  this.element.style.display = 'none';
};

List.prototype.add = function(item) {
  this.items.push(item);
};

List.prototype.clear = function() {
  this.items = [];
  this.active = 0;
};

List.prototype.isEmpty = function() {
  return !this.items.length;
};

List.prototype.draw = function() {
  this.element.innerHTML = '';

  if (this.items.length === 0) {
    this.hide();
    return;
  }

  for (var i = 0; i < this.items.length; i++) {
    this.drawItem(this.items[i], this.active === i);
  }

  this.show();
};

List.prototype.drawItem = function(item, active) {
  var li = document.createElement('li'),
    a = document.createElement('a');

  if (active) li.className += ' active';

  a.innerHTML = item.string;

  li.appendChild(a);
  this.element.appendChild(li);

  li.addEventListener('mousedown', function() {
    this.handleMouseDown.call(this, item);
  }.bind(this));
};

List.prototype.handleMouseDown = function(item) {
  this.component.value(item.original);
  this.clear();
  this.draw();
};

List.prototype.move = function(index) {
  this.active = index;
  this.draw();
};

List.prototype.previous = function() {
  this.move(this.active === 0 ? this.items.length - 1 : this.active - 1);
};

List.prototype.next = function() {
  this.move(this.active === this.items.length - 1 ? 0 : this.active + 1);
};

module.exports = List;

},{}],29:[function(require,module,exports){
'use strict';

var extend = require('xtend');
var fuzzy = require('fuzzy');
var List = require('./list');

var Suggestions = function(el, data, options) {
  options = options || {};

  this.options = extend({
    minLength: 2,
    limit: 5,
    filter: true
  }, options);

  this.el = el;
  this.data = data || [];
  this.list = new List(this);

  this.query = '';
  this.selected = null;

  this.list.draw();

  this.el.addEventListener('keyup', function(e) {
    this.handleKeyUp(e.keyCode);
  }.bind(this), false);

  this.el.addEventListener('keydown', function(e) {
    this.handleKeyDown(e);
  }.bind(this));

  this.el.addEventListener('focus', function() {
    this.handleFocus();
  }.bind(this));

  this.el.addEventListener('blur', function() {
    this.handleBlur();
  }.bind(this));

  return this;
};

Suggestions.prototype.handleKeyUp = function(keyCode) {
  // 40 - DOWN
  // 38 - UP
  // 27 - ESC
  // 13 - ENTER
  // 9 - TAB

  if (keyCode === 40 ||
      keyCode === 38 ||
      keyCode === 27 ||
      keyCode === 13 ||
      keyCode === 9) return;

  this.query = this.normalize(this.el.value);

  this.list.clear();

  if (this.query.length < this.options.minLength) {
    this.list.draw();
    return;
  }

  this.getCandidates(function(data) {
    for (var i = 0; i < data.length; i++) {
      this.list.add(data[i]);
      if (i === (this.options.limit - 1)) break;
    }
    this.list.draw();
  }.bind(this));
};

Suggestions.prototype.handleKeyDown = function(e) {
  switch (e.keyCode) {
    case 13: // ENTER
    case 9:  // TAB
      if (!this.list.isEmpty()) {
        this.value(this.list.items[this.list.active].original);
        this.list.hide();
      }
    break;
    case 27: // ESC
      if (!this.list.isEmpty()) this.list.hide();
    break;
    case 38: // UP
      this.list.previous();
    break;
    case 40: // DOWN
      this.list.next();
    break;
  }
};

Suggestions.prototype.handleBlur = function() {
  this.list.hide();
};

Suggestions.prototype.handleFocus = function() {
  if (!this.list.isEmpty()) this.list.show();
};

/**
 * Update data previously passed
 *
 * @param {Array} revisedData
 */
Suggestions.prototype.update = function(revisedData) {
  this.data = revisedData;
  this.list.draw();
};

/**
 * Clears data
 */
Suggestions.prototype.clear = function() {
  this.data = [];
  this.list.clear();
};

/**
 * Normalize the results list and input value for matching
 *
 * @param {String} value
 * @return {String}
 */
Suggestions.prototype.normalize = function(value) {
  value = value.toLowerCase();
  return value;
};

/**
 * Evaluates whether an array item qualifies as a match with the current query
 *
 * @param {String} candidate a possible item from the array passed
 * @param {String} query the current query
 * @return {Boolean}
 */
Suggestions.prototype.match = function(candidate, query) {
  return candidate.indexOf(query) > -1;
};

Suggestions.prototype.value = function(value) {
  this.selected = value;
  this.el.value = this.getItemValue(value);

  if (document.createEvent) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent('change', true, false);
    this.el.dispatchEvent(e);
  } else {
    this.el.fireEvent('onchange');
  }
};

Suggestions.prototype.getCandidates = function(callback) {
  var options = {
    pre: '<strong>',
    post: '</strong>',
    extract: function(d) { return this.getItemValue(d); }.bind(this)
  };

  var results = this.options.filter ?
    fuzzy.filter(this.query, this.data, options) :
    this.data.map(function(d) {
      return {
        original: d,
        string: this.getItemValue(d).replace(new RegExp('(' + this.query + ')', 'ig'), function($1, match) {
          return '<strong>' + match + '</strong>';
        })
      };
    }.bind(this));

  callback(results);
};

/**
 * For a given item in the data array, return what should be used as the candidate string
 *
 * @param {Object|String} item an item from the data array
 * @return {String} item
 */
Suggestions.prototype.getItemValue = function(item) {
  return item;
};

module.exports = Suggestions;

},{"./list":28,"fuzzy":27,"xtend":32}],30:[function(require,module,exports){
var each = require('turf-meta').coordEach;

/**
 * Takes any {@link GeoJSON} object, calculates the extent of all input features, and returns a bounding box.
 *
 * @module turf/extent
 * @category measurement
 * @param {GeoJSON} input any valid GeoJSON Object
 * @return {Array<number>} the bounding box of `input` given
 * as an array in WSEN order (west, south, east, north)
 * @example
 * var input = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.175329, 22.2524]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.170007, 22.267969]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.200649, 22.274641]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.186744, 22.265745]
 *       }
 *     }
 *   ]
 * };
 *
 * var bbox = turf.extent(input);
 *
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * var resultFeatures = input.features.concat(bboxPolygon);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function(layer) {
    var extent = [Infinity, Infinity, -Infinity, -Infinity];
    each(layer, function(coord) {
      if (extent[0] > coord[0]) extent[0] = coord[0];
      if (extent[1] > coord[1]) extent[1] = coord[1];
      if (extent[2] < coord[0]) extent[2] = coord[0];
      if (extent[3] < coord[1]) extent[3] = coord[1];
    });
    return extent;
};

},{"turf-meta":31}],31:[function(require,module,exports){
/**
 * Lazily iterate over coordinates in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @param {boolean=} excludeWrapCoord whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var point = { type: 'Point', coordinates: [0, 0] };
 * coordEach(point, function(coords) {
 *   // coords is equal to [0, 0]
 * });
 */
function coordEach(layer, callback, excludeWrapCoord) {
  var i, j, k, g, geometry, stopG, coords,
    geometryMaybeCollection,
    wrapShrink = 0,
    isGeometryCollection,
    isFeatureCollection = layer.type === 'FeatureCollection',
    isFeature = layer.type === 'Feature',
    stop = isFeatureCollection ? layer.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
  for (i = 0; i < stop; i++) {

    geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
        (isFeature ? layer.geometry : layer));
    isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

    for (g = 0; g < stopG; g++) {

      geometry = isGeometryCollection ?
          geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
      coords = geometry.coordinates;

      wrapShrink = (excludeWrapCoord &&
        (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?
        1 : 0;

      if (geometry.type === 'Point') {
        callback(coords);
      } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
        for (j = 0; j < coords.length; j++) callback(coords[j]);
      } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
        for (j = 0; j < coords.length; j++)
          for (k = 0; k < coords[j].length - wrapShrink; k++)
            callback(coords[j][k]);
      } else if (geometry.type === 'MultiPolygon') {
        for (j = 0; j < coords.length; j++)
          for (k = 0; k < coords[j].length; k++)
            for (l = 0; l < coords[j][k].length - wrapShrink; l++)
              callback(coords[j][k][l]);
      } else {
        throw new Error('Unknown Geometry Type');
      }
    }
  }
}
module.exports.coordEach = coordEach;

/**
 * Lazily reduce coordinates in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all coordinates is unnecessary.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (memo, value) and returns
 * a new memo
 * @param {boolean=} excludeWrapCoord whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @param {*} memo the starting value of memo: can be any type.
 */
function coordReduce(layer, callback, memo, excludeWrapCoord) {
  coordEach(layer, function(coord) {
    memo = callback(memo, coord);
  }, excludeWrapCoord);
  return memo;
}
module.exports.coordReduce = coordReduce;

/**
 * Lazily iterate over property objects in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @example
 * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };
 * propEach(point, function(props) {
 *   // props is equal to { foo: 1}
 * });
 */
function propEach(layer, callback) {
  var i;
  switch (layer.type) {
      case 'FeatureCollection':
        features = layer.features;
        for (i = 0; i < layer.features.length; i++) {
            callback(layer.features[i].properties);
        }
        break;
      case 'Feature':
        callback(layer.properties);
        break;
  }
}
module.exports.propEach = propEach;

/**
 * Lazily reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (memo, coord) and returns
 * a new memo
 * @param {*} memo the starting value of memo: can be any type.
 */
function propReduce(layer, callback, memo) {
  propEach(layer, function(prop) {
    memo = callback(memo, prop);
  });
  return memo;
}
module.exports.propReduce = propReduce;

},{}],32:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.queryOrigin = queryOrigin;
exports.queryDestination = queryDestination;
exports.queryOriginCoordinates = queryOriginCoordinates;
exports.queryDestinationCoordinates = queryDestinationCoordinates;
exports.clearOrigin = clearOrigin;
exports.clearDestination = clearDestination;
exports.setOptions = setOptions;
exports.hoverMarker = hoverMarker;
exports.setRouteIndex = setRouteIndex;
exports.createOrigin = createOrigin;
exports.createDestination = createDestination;
exports.setProfile = setProfile;
exports.reverse = reverse;
exports.setOriginFromCoordinates = setOriginFromCoordinates;
exports.setDestinationFromCoordinates = setDestinationFromCoordinates;
exports.addWaypoint = addWaypoint;
exports.setWaypoint = setWaypoint;
exports.removeWaypoint = removeWaypoint;
exports.eventSubscribe = eventSubscribe;
exports.eventEmit = eventEmit;

var _action_types = require('../constants/action_types');

var types = _interopRequireWildcard(_action_types);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var request = new XMLHttpRequest();

function originPoint(coordinates) {
  return function (dispatch) {
    var origin = _utils2.default.createPoint(coordinates, {
      id: 'origin',
      'marker-symbol': 'A'
    });

    dispatch({ type: types.ORIGIN, origin: origin });
    dispatch(eventEmit('origin', { feature: origin }));
  };
}

function destinationPoint(coordinates) {
  return function (dispatch) {
    var destination = _utils2.default.createPoint(coordinates, {
      id: 'destination',
      'marker-symbol': 'B'
    });

    dispatch({ type: types.DESTINATION, destination: destination });
    dispatch(eventEmit('destination', { feature: destination }));
  };
}

function setDirections(directions) {
  return function (dispatch) {
    dispatch({
      type: types.DIRECTIONS,
      directions: directions
    });
    dispatch(eventEmit('route', { route: directions }));
  };
}

function updateWaypoints(waypoints) {
  return {
    type: types.WAYPOINTS,
    waypoints: waypoints
  };
}

function setHoverMarker(feature) {
  return {
    type: types.HOVER_MARKER,
    hoverMarker: feature
  };
}

function fetchDirections() {
  return function (dispatch, getState) {
    var _getState = getState();

    var api = _getState.api;
    var accessToken = _getState.accessToken;
    var routeIndex = _getState.routeIndex;
    var profile = _getState.profile;

    var query = buildDirectionsQuery(getState);

    // Request params
    var options = [];
    options.push('geometries=polyline');
    options.push('alternatives=true');
    options.push('steps=true');
    options.push('overview=full');
    options.push('access_token=' + accessToken);
    request.abort();
    request.open('GET', api + 'mapbox/' + profile + '/' + query + '.json?' + options.join('&'), true);

    request.onload = function () {
      if (request.status >= 200 && request.status < 400) {
        var data = JSON.parse(request.responseText);
        if (data.error) {
          dispatch(setDirections([]));
          return dispatch(setError(data.error));
        }

        dispatch(setError(null));
        if (!data.routes[routeIndex]) dispatch(setRouteIndex(0));
        dispatch(setDirections(data.routes));

        // Revise origin / destination points
        dispatch(originPoint(data.waypoints[0].location));
        dispatch(destinationPoint(data.waypoints[data.waypoints.length - 1].location));
      } else {
        dispatch(setDirections([]));
        return dispatch(setError(JSON.parse(request.responseText).message));
      }
    };

    request.onerror = function () {
      dispatch(setDirections([]));
      return dispatch(setError(JSON.parse(request.responseText).message));
    };

    request.send();
  };
}

/*
 * Build query used to fetch directions
 *
 * @param {Function} state
 */
function buildDirectionsQuery(state) {
  var _state = state();

  var origin = _state.origin;
  var destination = _state.destination;
  var waypoints = _state.waypoints;


  var query = [];
  query.push(origin.geometry.coordinates.join(','));
  query.push(';');

  // Add any waypoints.
  if (waypoints.length) {
    waypoints.forEach(function (waypoint) {
      query.push(waypoint.geometry.coordinates.join(','));
      query.push(';');
    });
  }

  query.push(destination.geometry.coordinates.join(','));
  return encodeURIComponent(query.join(''));
}

function normalizeWaypoint(waypoint) {
  var properties = { id: 'waypoint' };
  return Object.assign(waypoint, {
    properties: waypoint.properties ? Object.assign(waypoint.properties, properties) : properties
  });
}

function setError(error) {
  return function (dispatch) {
    dispatch({
      type: 'ERROR',
      error: error
    });
    if (error) dispatch(eventEmit('error', { error: error }));
  };
}

function queryOrigin(query) {
  return {
    type: types.ORIGIN_QUERY,
    query: query
  };
}

function queryDestination(query) {
  return {
    type: types.DESTINATION_QUERY,
    query: query
  };
}

function queryOriginCoordinates(coords) {
  return {
    type: types.ORIGIN_FROM_COORDINATES,
    coordinates: coords
  };
}

function queryDestinationCoordinates(coords) {
  return {
    type: types.DESTINATION_FROM_COORDINATES,
    coordinates: coords
  };
}

function clearOrigin() {
  return function (dispatch) {
    dispatch({
      type: types.ORIGIN_CLEAR
    });
    dispatch(eventEmit('clear', { type: 'origin' }));
    dispatch(setError(null));
  };
}

function clearDestination() {
  return function (dispatch) {
    dispatch({
      type: types.DESTINATION_CLEAR
    });
    dispatch(eventEmit('clear', { type: 'destination' }));
    dispatch(setError(null));
  };
}

function setOptions(options) {
  return {
    type: types.SET_OPTIONS,
    options: options
  };
}

function hoverMarker(coordinates) {
  return function (dispatch) {
    var feature = coordinates ? _utils2.default.createPoint(coordinates, { id: 'hover' }) : {};
    dispatch(setHoverMarker(feature));
  };
}

function setRouteIndex(routeIndex) {
  return {
    type: types.ROUTE_INDEX,
    routeIndex: routeIndex
  };
}

function createOrigin(coordinates) {
  return function (dispatch, getState) {
    var _getState2 = getState();

    var destination = _getState2.destination;

    dispatch(originPoint(coordinates));
    if (destination.geometry) dispatch(fetchDirections());
  };
}

function createDestination(coordinates) {
  return function (dispatch, getState) {
    var _getState3 = getState();

    var origin = _getState3.origin;

    dispatch(destinationPoint(coordinates));
    if (origin.geometry) dispatch(fetchDirections());
  };
}

function setProfile(profile) {
  return function (dispatch, getState) {
    var _getState4 = getState();

    var origin = _getState4.origin;
    var destination = _getState4.destination;

    dispatch({ type: types.DIRECTIONS_PROFILE, profile: profile });
    dispatch(eventEmit('profile', { profile: profile }));
    if (origin.geometry && destination.geometry) dispatch(fetchDirections());
  };
}

function reverse() {
  return function (dispatch, getState) {
    var state = getState();
    if (state.destination.geometry) dispatch(originPoint(state.destination.geometry.coordinates));
    if (state.origin.geometry) dispatch(destinationPoint(state.origin.geometry.coordinates));
    if (state.origin.geometry && state.destination.geometry) dispatch(fetchDirections());
  };
}

/*
 * Set origin from coordinates
 *
 * @param {Array<number>} coordinates [lng, lat] array.
 */
function setOriginFromCoordinates(coords) {
  return function (dispatch) {
    if (!_utils2.default.validCoords(coords)) coords = [_utils2.default.wrap(coords[0]), _utils2.default.wrap(coords[1])];
    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));
    dispatch(queryOriginCoordinates(coords));
    dispatch(createOrigin(coords));
  };
}

/*
 * Set destination from coordinates
 *
 * @param {Array<number>} coords [lng, lat] array.
 */
function setDestinationFromCoordinates(coords) {
  return function (dispatch) {
    if (!_utils2.default.validCoords(coords)) coords = [_utils2.default.wrap(coords[0]), _utils2.default.wrap(coords[1])];
    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));
    dispatch(createDestination(coords));
    dispatch(queryDestinationCoordinates(coords));
  };
}

function addWaypoint(index, waypoint) {
  return function (dispatch, getState) {
    var _getState5 = getState();

    var destination = _getState5.destination;
    var waypoints = _getState5.waypoints;

    waypoints.splice(index, 0, normalizeWaypoint(waypoint));
    dispatch(updateWaypoints(waypoints));
    if (destination.geometry) dispatch(fetchDirections());
  };
}

function setWaypoint(index, waypoint) {
  return function (dispatch, getState) {
    var _getState6 = getState();

    var destination = _getState6.destination;
    var waypoints = _getState6.waypoints;

    waypoints[index] = normalizeWaypoint(waypoint);
    dispatch(updateWaypoints(waypoints));
    if (destination.geometry) dispatch(fetchDirections());
  };
}

function removeWaypoint(waypoint) {
  return function (dispatch, getState) {
    var _getState7 = getState();

    var destination = _getState7.destination;
    var waypoints = _getState7.waypoints;

    waypoints = waypoints.filter(function (way) {
      return !_utils2.default.coordinateMatch(way, waypoint);
    });

    dispatch(updateWaypoints(waypoints));
    if (destination.geometry) dispatch(fetchDirections());
  };
}

function eventSubscribe(type, fn) {
  return function (dispatch, getState) {
    var _getState8 = getState();

    var events = _getState8.events;

    events[type] = events[type] || [];
    events[type].push(fn);
    return {
      type: types.EVENTS,
      events: events
    };
  };
}

function eventEmit(type, data) {
  var _this = this;

  return function (dispatch, getState) {
    var _getState9 = getState();

    var events = _getState9.events;


    if (!events[type]) {
      return {
        type: types.EVENTS,
        events: events
      };
    }

    var listeners = events[type].slice();

    for (var i = 0; i < listeners.length; i++) {
      listeners[i].call(_this, data);
    }
  };
}

},{"../constants/action_types":34,"../utils":42}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var DESTINATION = exports.DESTINATION = 'DESTINATION';
var DESTINATION_CLEAR = exports.DESTINATION_CLEAR = 'DESTINATION_CLEAR';
var DESTINATION_QUERY = exports.DESTINATION_QUERY = 'DESTINATION_QUERY';
var DESTINATION_FROM_COORDINATES = exports.DESTINATION_FROM_COORDINATES = 'DESTINATION_FROM_COORDINATES';
var DIRECTIONS = exports.DIRECTIONS = 'DIRECTIONS';
var DIRECTIONS_PROFILE = exports.DIRECTIONS_PROFILE = 'DIRECTIONS_PROFILE';
var EVENTS = exports.EVENTS = 'EVENTS';
var ERROR = exports.ERROR = 'ERROR';
var HOVER_MARKER = exports.HOVER_MARKER = 'HOVER_MARKER';
var ORIGIN = exports.ORIGIN = 'ORIGIN';
var ORIGIN_CLEAR = exports.ORIGIN_CLEAR = 'ORIGIN_CLEAR';
var ORIGIN_QUERY = exports.ORIGIN_QUERY = 'ORIGIN_QUERY';
var ORIGIN_FROM_COORDINATES = exports.ORIGIN_FROM_COORDINATES = 'ORIGIN_FROM_COORDINATES';
var ROUTE_INDEX = exports.ROUTE_INDEX = 'ROUTE_INDEX';
var SET_OPTIONS = exports.SET_OPTIONS = 'SET_OPTIONS';
var WAYPOINTS = exports.WAYPOINTS = 'WAYPOINTS';

},{}],35:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _suggestions = require('suggestions');

var _suggestions2 = _interopRequireDefault(_suggestions);

var _lodash = require('lodash.debounce');

var _lodash2 = _interopRequireDefault(_lodash);

var _xtend = require('xtend');

var _xtend2 = _interopRequireDefault(_xtend);

var _events = require('events');

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Mapbox Geocoder version
var API = 'https://api.mapbox.com/geocoding/v5/mapbox.places/';

// Geocoder - this slightly mimicks the mapboxl-gl-geocoder but isn't an exact replica.
// Once gl-js plugins can be added to custom divs, we should be able to require mapbox-gl-geocoder
// instead of including it here
function Geocoder(options) {
  this._ev = new _events.EventEmitter();
  this.options = (0, _xtend2.default)({}, this.options, options);
}

Geocoder.prototype = {

  options: {
    placeholder: 'Search',
    zoom: 16,
    flyTo: true
  },

  onAdd: function onAdd(map) {
    this._map = map;

    this.request = new XMLHttpRequest();

    // Template
    var el = document.createElement('div');
    el.className = 'mapboxgl-ctrl-geocoder';

    var icon = document.createElement('span');
    icon.className = 'geocoder-icon geocoder-icon-search';

    var input = this._inputEl = document.createElement('input');
    input.type = 'text';
    input.placeholder = this.options.placeholder;

    input.addEventListener('keydown', (0, _lodash2.default)(function (e) {
      if (!e.target.value) return this._clearEl.classList.remove('active');

      // TAB, ESC, LEFT, RIGHT, ENTER, UP, DOWN
      if (e.metaKey || [9, 27, 37, 39, 13, 38, 40].indexOf(e.keyCode) !== -1) return;
      this._queryFromInput(e.target.value);
    }.bind(this)), 200);

    input.addEventListener('change', function (e) {
      if (e.target.value) this._clearEl.classList.add('active');

      var selected = this._typeahead.selected;
      if (selected) {
        if (this.options.flyTo) {
          if (selected.bbox && selected.context && selected.context.length <= 3 || selected.bbox && !selected.context) {
            var bbox = selected.bbox;
            map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]]);
          } else {
            map.flyTo({
              center: selected.center,
              zoom: this.options.zoom
            });
          }
        }
        this._input = selected;
        this.fire('result', { result: selected });
      }
    }.bind(this));

    var actions = document.createElement('div');
    actions.classList.add('geocoder-pin-right');

    var clear = this._clearEl = document.createElement('button');
    clear.className = 'geocoder-icon geocoder-icon-close';
    clear.addEventListener('click', this._clear.bind(this));

    var loading = this._loadingEl = document.createElement('span');
    loading.className = 'geocoder-icon geocoder-icon-loading';

    actions.appendChild(clear);
    actions.appendChild(loading);

    el.appendChild(icon);
    el.appendChild(input);
    el.appendChild(actions);

    // Override the control being added to control containers
    if (this.options.container) this.options.position = false;

    this._typeahead = new _suggestions2.default(input, [], { filter: false });
    this._typeahead.getItemValue = function (item) {
      return item.place_name;
    };

    return el;
  },

  _geocode: function _geocode(q, callback) {
    this._loadingEl.classList.add('active');
    this.fire('loading');

    var options = [];
    if (this.options.proximity) options.push('proximity=' + this.options.proximity.join());
    if (this.options.bbox) options.push('bbox=' + this.options.bbox.join());
    if (this.options.country) options.push('country=' + this.options.country);
    if (this.options.types) options.push('types=' + this.options.types);

    var accessToken = this.options.accessToken ? this.options.accessToken : mapboxgl.accessToken;
    options.push('access_token=' + accessToken);

    this.request.abort();
    this.request.open('GET', API + encodeURIComponent(q.trim()) + '.json?' + options.join('&'), true);
    this.request.onload = function () {
      this._loadingEl.classList.remove('active');
      if (this.request.status >= 200 && this.request.status < 400) {
        var data = JSON.parse(this.request.responseText);
        if (data.features.length) {
          this._clearEl.classList.add('active');
        } else {
          this._clearEl.classList.remove('active');
          this._typeahead.selected = null;
        }

        this.fire('results', { results: data.features });
        this._typeahead.update(data.features);
        return callback(data.features);
      } else {
        this.fire('error', { error: JSON.parse(this.request.responseText).message });
      }
    }.bind(this);

    this.request.onerror = function () {
      this._loadingEl.classList.remove('active');
      this.fire('error', { error: JSON.parse(this.request.responseText).message });
    }.bind(this);

    this.request.send();
  },

  _queryFromInput: function _queryFromInput(q) {
    q = q.trim();
    if (!q) this._clear();
    if (q.length > 2) {
      this._geocode(q, function (results) {
        this._results = results;
      }.bind(this));
    }
  },

  _change: function _change() {
    var onChange = document.createEvent('HTMLEvents');
    onChange.initEvent('change', true, false);
    this._inputEl.dispatchEvent(onChange);
  },

  _query: function _query(input) {
    if (!input) return;
    if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && input.length) {
      input = [_utils2.default.wrap(input[0]), _utils2.default.wrap(input[1])].join();
    }

    this._geocode(input, function (results) {
      if (!results.length) return;
      var result = results[0];
      this._results = results;
      this._typeahead.selected = result;
      this._inputEl.value = result.place_name;
      this._change();
    }.bind(this));
  },

  _setInput: function _setInput(input) {
    if (!input) return;
    if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && input.length) {
      input = [_utils2.default.wrap(input[0]), _utils2.default.wrap(input[1])].join();
    }

    // Set input value to passed value and clear everything else.
    this._inputEl.value = input;
    this._input = null;
    this._typeahead.selected = null;
    this._typeahead.clear();
    this._change();
  },

  _clear: function _clear() {
    this._input = null;
    this._inputEl.value = '';
    this._typeahead.selected = null;
    this._typeahead.clear();
    this._change();
    this._inputEl.focus();
    this._clearEl.classList.remove('active');
    this.fire('clear');
  },

  getResult: function getResult() {
    return this._input;
  },

  /**
   * Set & query the input
   * @param {Array|String} query An array of coordinates [lng, lat] or location name as a string.
   * @returns {Geocoder} this
   */
  query: function query(_query2) {
    this._query(_query2);
    return this;
  },

  /**
   * Set input
   * @param {Array|String} value An array of coordinates [lng, lat] or location name as a string. Calling this function just sets the input and does not trigger an API request.
   * @returns {Geocoder} this
   */
  setInput: function setInput(value) {
    this._setInput(value);
    return this;
  },

  /**
   * Subscribe to events that happen within the plugin.
   * @param {String} type name of event. Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string
   * @param {Function} fn function that's called when the event is emitted.
   * @returns {Geocoder} this;
   */
  on: function on(type, fn) {
    this._ev.on(type, fn);
    return this;
  },

  /**
   * Fire an event
   * @param {String} type event name.
   * @param {Object} data event data to pass to the function subscribed.
   * @returns {Geocoder} this
   */
  fire: function fire(type, data) {
    this._ev.emit(type, data);
    return this;
  },

  /**
   * Remove an event
   * @returns {Geocoder} this
   * @param {String} type Event name.
   * @param {Function} fn Function that should unsubscribe to the event emitted.
   */
  off: function off(type, fn) {
    this._ev.removeListener(type, fn);
    return this;
  }
};

module.exports = Geocoder;

},{"../utils":42,"events":1,"lodash.debounce":5,"suggestions":26,"xtend":32}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _geocoder = require('./geocoder');

var _geocoder2 = _interopRequireDefault(_geocoder);

var _lodash = require('lodash.template');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.isequal');

var _lodash4 = _interopRequireDefault(_lodash3);

var _turfExtent = require('turf-extent');

var _turfExtent2 = _interopRequireDefault(_turfExtent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

 // substack/brfs#39
var tmpl = (0, _lodash2.default)("<div class='mapbox-directions-component mapbox-directions-inputs'>\n  <div class='mapbox-directions-component-keyline'>\n    <div class='mapbox-directions-origin'>\n      <label class='mapbox-form-label'>\n        <span class='directions-icon directions-icon-depart' style='background-color:#93AFD7;' ></span>\n      </label>\n      <div id='mapbox-directions-origin-input'></div>\n    </div>\n\n    <button\n      class='directions-icon directions-icon-reverse directions-reverse js-reverse-inputs'\n      title='Reverse origin &amp; destination'>\n    </button>\n\n    <div class='mapbox-directions-destination'>\n      <label class='mapbox-form-label'>\n        <span class='directions-icon directions-icon-arrive' style='background-color:#608BC7;'></span>\n      </label>\n      <div id='mapbox-directions-destination-input'></div>\n    </div>\n  </div>\n\n  <div class='mapbox-directions-profile mapbox-directions-component-keyline mapbox-directions-clearfix'> <input\n      id='mapbox-directions-profile-driving'\n      type='radio'\n      name='profile'\n      <% if (profile === 'driving') { %>checked<% } %>\n    />\n    <label for='mapbox-directions-profile-driving'>Driving</label>\n    <input\n      id='mapbox-directions-profile-walking'\n      type='radio'\n      name='profile'\n      <% if (profile === 'walking') { %>checked<% } %>\n    />\n    <label for='mapbox-directions-profile-walking'>Walking</label>\n    <input\n      id='mapbox-directions-profile-cycling'\n      type='radio'\n      name='profile'\n      <% if (profile === 'cycling') { %>checked<% } %>\n    />\n    <label for='mapbox-directions-profile-cycling'>Cycling</label>\n  </div>\n</div>\n");

/**
 * Inputs controller
 *
 * @param {HTMLElement} el Summary parent container
 * @param {Object} store A redux store
 * @param {Object} actions Actions an element can dispatch
 * @param {Object} map The mapboxgl instance
 * @private
 */

var Inputs = function () {
  function Inputs(el, store, actions, map) {
    _classCallCheck(this, Inputs);

    var _store$getState = store.getState();

    var originQuery = _store$getState.originQuery;
    var destinationQuery = _store$getState.destinationQuery;
    var profile = _store$getState.profile;


    el.innerHTML = tmpl({
      originQuery: originQuery,
      destinationQuery: destinationQuery,
      profile: profile
    });

    this.container = el;
    this.actions = actions;
    this.store = store;
    this._map = map;

    this.onAdd();
    this.render();
  }

  _createClass(Inputs, [{
    key: 'animateToCoordinates',
    value: function animateToCoordinates(mode, coords) {
      var _store$getState2 = this.store.getState();

      var origin = _store$getState2.origin;
      var destination = _store$getState2.destination;


      if (origin.geometry && destination.geometry && !(0, _lodash4.default)(origin.geometry, destination.geometry)) {

        // Animate map to fit bounds.
        var bb = (0, _turfExtent2.default)({
          type: 'FeatureCollection',
          features: [origin, destination]
        });

        this._map.fitBounds([[bb[0], bb[1]], [bb[2], bb[3]]], { padding: 80 });
      } else {
        this._map.flyTo({ center: coords });
      }
    }
  }, {
    key: 'onAdd',
    value: function onAdd() {
      var _this = this;

      var _actions = this.actions;
      var clearOrigin = _actions.clearOrigin;
      var clearDestination = _actions.clearDestination;
      var createOrigin = _actions.createOrigin;
      var createDestination = _actions.createDestination;
      var setProfile = _actions.setProfile;
      var reverse = _actions.reverse;

      var _store$getState3 = this.store.getState();

      var geocoder = _store$getState3.geocoder;
      var accessToken = _store$getState3.accessToken;


      this.originInput = new _geocoder2.default(Object.assign({}, {
        flyTo: false,
        placeholder: 'Startort',
        accessToken: accessToken
      }, geocoder));

      var originEl = this.originInput.onAdd();
      var originContainerEl = this.container.querySelector('#mapbox-directions-origin-input');
      originContainerEl.appendChild(originEl);

      this.destinationInput = new _geocoder2.default(Object.assign({}, {
        flyTo: false,
        placeholder: 'Zielort',
        accessToken: accessToken
      }, geocoder));

      var destinationEl = this.destinationInput.onAdd();
      this.container.querySelector('#mapbox-directions-destination-input').appendChild(destinationEl);

      this.originInput.on('result', function (e) {
        var coords = e.result.center;
        createOrigin(coords);
        _this.animateToCoordinates('origin', coords);
      });

      this.originInput.on('clear', clearOrigin);

      this.destinationInput.on('result', function (e) {
        var coords = e.result.center;
        createDestination(coords);
        _this.animateToCoordinates('destination', coords);
      });

      this.destinationInput.on('clear', clearDestination);

      // Driving / Walking / Cycling profiles
      var profiles = this.container.querySelectorAll('input[type="radio"]');
      Array.prototype.forEach.call(profiles, function (el) {
        el.addEventListener('change', function () {
          setProfile(el.id.replace('mapbox-directions-profile-', ''));
        });
      });

      // Reversing Origin / Destination
      this.container.querySelector('.js-reverse-inputs').addEventListener('click', function () {
        var _store$getState4 = _this.store.getState();

        var origin = _store$getState4.origin;
        var destination = _store$getState4.destination;

        if (origin) _this.actions.queryDestination(origin.geometry.coordinates);
        if (destination) _this.actions.queryOrigin(destination.geometry.coordinates);
        reverse();
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      this.store.subscribe(function () {
        var _store$getState5 = _this2.store.getState();

        var originQuery = _store$getState5.originQuery;
        var destinationQuery = _store$getState5.destinationQuery;
        var originQueryCoordinates = _store$getState5.originQueryCoordinates;
        var destinationQueryCoordinates = _store$getState5.destinationQueryCoordinates;


        if (originQuery) {
          _this2.originInput.query(originQuery);
          _this2.actions.queryOrigin(null);
        }

        if (destinationQuery) {
          _this2.destinationInput.query(destinationQuery);
          _this2.actions.queryDestination(null);
        }

        if (originQueryCoordinates) {
          _this2.originInput.setInput(originQueryCoordinates);
          _this2.animateToCoordinates('origin', originQueryCoordinates);
          _this2.actions.queryOriginCoordinates(null);
        }

        if (destinationQueryCoordinates) {
          _this2.destinationInput.setInput(destinationQueryCoordinates);
          _this2.animateToCoordinates('destination', destinationQueryCoordinates);
          _this2.actions.queryDestinationCoordinates(null);
        }
      });
    }
  }]);

  return Inputs;
}();

exports.default = Inputs;

},{"./geocoder":35,"lodash.isequal":6,"lodash.template":7,"turf-extent":30}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

var _lodash = require('lodash.template');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.isequal');

var _lodash4 = _interopRequireDefault(_lodash3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

 // substack/brfs#39
var instructionsTemplate = (0, _lodash2.default)("<div class='directions-control directions-control-directions'>\n  <div class='mapbox-directions-component mapbox-directions-route-summary<% if (routes > 1) { %> mapbox-directions-multiple<% } %>'>\n    <% if (routes > 1) { %>\n    <div class='mapbox-directions-routes mapbox-directions-clearfix'>\n      <% for (var i = 0; i < routes; i++) { %>\n        <input type='radio' name='routes' id='<%= i %>' <% if (i === routeIndex) { %>checked<% } %>>\n        <label for='<%= i %>' class='mapbox-directions-route'><%= i + 1 %></label>\n      <% } %>\n    </div>\n    <% } %>\n    <h1><%- duration %></h1>\n    <span><%- distance %></span>\n  </div>\n\n  <div class='mapbox-directions-instructions'>\n    <div class='mapbox-directions-instructions-wrapper'>\n      <ol class='mapbox-directions-steps'>\n        <% steps.forEach(function(step) { %>\n          <%\n            var distance = step.distance ? format(step.distance) : false;\n            var icon = step.maneuver.modifier ? step.maneuver.modifier.replace(/\\s+/g, '-').toLowerCase() : step.maneuver.type.replace(/\\s+/g, '-').toLowerCase();\n\n            if (step.maneuver.type === 'arrive' || step.maneuver.type === 'depart') {\n              icon = step.maneuver.type;\n            }\n\n            if (step.maneuver.type === 'roundabout' || step.maneuver.type === 'rotary') {\n              icon= 'roundabout';\n            }\n\n            var lng = step.maneuver.location[0];\n            var lat = step.maneuver.location[1];\n          %>\n          <li\n            data-lat='<%= lat %>'\n            data-lng='<%= lng %>'\n            class='mapbox-directions-step'>\n            <span class='directions-icon directions-icon-<%= icon %>'></span>\n            <div class='mapbox-directions-step-maneuver'>\n              <%= step.maneuver.instruction %>\n            </div>\n            <% if (distance) { %>\n              <div class='mapbox-directions-step-distance'>\n                <%= distance %>\n              </div>\n            <% } %>\n          </li>\n        <% }); %>\n      </ol>\n    </div>\n  </div>\n</div>\n");
var errorTemplate = (0, _lodash2.default)("<div class='directions-control directions-control-directions'>\n  <div class='mapbox-directions-error'>\n    <%= error %>\n  </div>\n</div>\n");


/**
 * Summary/Instructions controller
 *
 * @param {HTMLElement} el Summary parent container
 * @param {Object} store A redux store
 * @param {Object} actions Actions an element can dispatch
 * @param {Object} map The mapboxgl instance
 * @private
 */

var Instructions = function () {
  function Instructions(el, store, actions, map) {
    _classCallCheck(this, Instructions);

    this.container = el;
    this.actions = actions;
    this.store = store;
    this._map = map;
    this.directions = {};
    this.render();
  }

  _createClass(Instructions, [{
    key: 'render',
    value: function render() {
      var _this = this;

      this.store.subscribe(function () {
        var _actions = _this.actions;
        var hoverMarker = _actions.hoverMarker;
        var setRouteIndex = _actions.setRouteIndex;

        var _store$getState = _this.store.getState();

        var routeIndex = _store$getState.routeIndex;
        var unit = _store$getState.unit;
        var directions = _store$getState.directions;
        var error = _store$getState.error;

        var shouldRender = !(0, _lodash4.default)(directions[routeIndex], _this.directions);

        if (error) {
          _this.container.innerHTML = errorTemplate({ error: error });
          return;
        }

        if (directions.length && shouldRender) {
          var direction = _this.directions = directions[routeIndex];
          _this.container.innerHTML = instructionsTemplate({
            routeIndex: routeIndex,
            routes: directions.length,
            steps: direction.legs[0].steps, // Todo: Respect all legs,
            format: _utils2.default.format[unit],
            duration: _utils2.default.format[unit](direction.distance),
            distance: _utils2.default.format.duration(direction.duration)
          });

          var steps = _this.container.querySelectorAll('.mapbox-directions-step');

          Array.prototype.forEach.call(steps, function (el) {
            var lng = el.getAttribute('data-lng');
            var lat = el.getAttribute('data-lat');

            el.addEventListener('mouseover', function () {
              hoverMarker([lng, lat]);
            });

            el.addEventListener('mouseout', function () {
              hoverMarker(null);
            });

            el.addEventListener('click', function () {
              _this._map.flyTo({
                center: [lng, lat],
                zoom: 16
              });
            });
          });

          var routes = _this.container.querySelectorAll('input[type="radio"]');
          Array.prototype.forEach.call(routes, function (el) {
            el.addEventListener('change', function (e) {
              setRouteIndex(parseInt(e.target.id, 10));
            });
          });
        } else if (_this.container.innerHTML && shouldRender) {
          _this.container.innerHTML = '';
        }
      });
    }
  }]);

  return Instructions;
}();

exports.default = Instructions;

},{"../utils":42,"lodash.isequal":6,"lodash.template":7}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _redux = require('redux');

var _reduxThunk = require('redux-thunk');

var _reduxThunk2 = _interopRequireDefault(_reduxThunk);

var _polyline = require('polyline');

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var _reducers = require('./reducers');

var _reducers2 = _interopRequireDefault(_reducers);

var _actions = require('./actions');

var actions = _interopRequireWildcard(_actions);

var _directions_style = require('./directions_style');

var _directions_style2 = _interopRequireDefault(_directions_style);

var _inputs = require('./controls/inputs');

var _inputs2 = _interopRequireDefault(_inputs);

var _instructions = require('./controls/instructions');

var _instructions2 = _interopRequireDefault(_instructions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var storeWithMiddleware = (0, _redux.applyMiddleware)(_reduxThunk2.default)(_redux.createStore);
var store = storeWithMiddleware(_reducers2.default);

// State object management via redux


// Controls

/**
 * The Directions control
 * @class MapboxDirections
 *
 * @param {Object} options
 * @param {Array} [options.styles] Override default layer properties of the [directions source](https://github.com/mapbox/mapbox-gl-directions/blob/master/src/directions_style.js). Documentation for each property are specified in the [Mapbox GL Style Reference](https://www.mapbox.com/mapbox-gl-style-spec/).
 * @param {String} [options.accessToken=null] Required unless `mapboxgl.accessToken` is set globally
 * @param {Boolean} [options.interactive=true] Enable/Disable mouse or touch interactivity from the plugin
 * @param {String} [options.profile="driving-traffic"] Routing profile to use. Options: `driving-traffic`, `driving`, `walking`, `cycling`
 * @param {String} [options.unit="imperial"] Measurement system to be used in navigation instructions. Options: `imperial`, `metric`
 * @param {Object} [options.geocoder] Pass options available to mapbox-gl-geocoder as [documented here](https://github.com/mapbox/mapbox-gl-geocoder/blob/master/API.md#mapboxglgeocoder).
 * @param {Object} [options.controls]
 * @param {Boolean} [options.controls.inputs=true] Hide or display the inputs control.
 * @param {Boolean} [options.controls.instructions=true] Hide or display the instructions control.
 * @example
 * var MapboxDirections = require('../src/index');
 * var directions = new MapboxDirections({
 *   accessToken: 'YOUR-MAPBOX-ACCESS-TOKEN',
 *   unit: 'metric',
 *   profile: 'cycling'
 * });
 * // add to your mapboxgl map
 * map.addControl(directions);
 *
 * @return {MapboxDirections} `this`
 */
var MapboxDirections = function () {
  function MapboxDirections(options) {
    _classCallCheck(this, MapboxDirections);

    this.actions = (0, _redux.bindActionCreators)(actions, store.dispatch);
    this.actions.setOptions(options || {});
    this.options = options || {};

    this.onDragDown = this._onDragDown.bind(this);
    this.onDragMove = this._onDragMove.bind(this);
    this.onDragUp = this._onDragUp.bind(this);
    this.move = this._move.bind(this);
    this.onClick = this._onClick.bind(this);
  }

  _createClass(MapboxDirections, [{
    key: 'onAdd',
    value: function onAdd(map) {
      var _this = this;

      this._map = map;

      var _store$getState = store.getState();

      var controls = _store$getState.controls;


      var el = this.container = document.createElement('div');
      el.className = 'mapboxgl-ctrl-directions mapboxgl-ctrl';

      // Add controls to the page
      var inputEl = document.createElement('div');
      inputEl.className = 'directions-control directions-control-inputs';
      new _inputs2.default(inputEl, store, this.actions, this._map);

      var directionsEl = document.createElement('div');
      directionsEl.className = 'directions-control directions-control-instructions';

      new _instructions2.default(directionsEl, store, {
        hoverMarker: this.actions.hoverMarker,
        setRouteIndex: this.actions.setRouteIndex
      }, this._map);

      if (controls.inputs) el.appendChild(inputEl);
      if (controls.instructions) el.appendChild(directionsEl);

      this.subscribedActions();
      if (this._map.loaded()) this.mapState();else this._map.on('load', function () {
        return _this.mapState();
      });

      return el;
    }

    /**
     * Removes the control from the map it has been added to. This is called by `map.removeControl`,
     * which is the recommended method to remove controls.
     *
     * @returns {Control} `this`
     */

  }, {
    key: 'onRemove',
    value: function onRemove(map) {
      this.container.parentNode.removeChild(this.container);
      this.removeRoutes();
      map.off('mousedown', this.onDragDown);
      map.off('mousemove', this.move);
      map.off('touchstart', this.onDragDown);
      map.off('touchstart', this.move);
      map.off('click', this.onClick);
      if (this.storeUnsubscribe) {
        this.storeUnsubscribe();
        delete this.storeUnsubscribe;
      }
      this._map = null;
      return this;
    }
  }, {
    key: 'mapState',
    value: function mapState() {
      var _this2 = this;

      var _store$getState2 = store.getState();

      var profile = _store$getState2.profile;
      var styles = _store$getState2.styles;
      var interactive = _store$getState2.interactive;

      // Emit any default or option set config

      this.actions.eventEmit('profile', { profile: profile });

      var geojson = {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: []
        }
      };

      // Add and set data theme layer/style
      this._map.addSource('directions', geojson);

      // Add direction specific styles to the map
      _directions_style2.default.forEach(function (style) {
        return _this2._map.addLayer(style);
      });

      if (styles && styles.length) styles.forEach(function (style) {
        return _this2._map.addLayer(style);
      });

      if (interactive) {
        this._map.on('mousedown', this.onDragDown);
        this._map.on('mousemove', this.move);
        this._map.on('click', this.onClick);

        this._map.on('touchstart', this.move);
        this._map.on('touchstart', this.onDragDown);
      }
    }
  }, {
    key: 'subscribedActions',
    value: function subscribedActions() {
      var _this3 = this;

      this.storeUnsubscribe = store.subscribe(function () {
        var _store$getState3 = store.getState();

        var origin = _store$getState3.origin;
        var destination = _store$getState3.destination;
        var hoverMarker = _store$getState3.hoverMarker;
        var directions = _store$getState3.directions;
        var routeIndex = _store$getState3.routeIndex;


        var geojson = {
          type: 'FeatureCollection',
          features: [origin, destination, hoverMarker].filter(function (d) {
            return d.geometry;
          })
        };

        if (directions.length) {
          directions.forEach(function (feature, index) {

            var lineString = {
              geometry: {
                type: 'LineString',
                coordinates: (0, _polyline.decode)(feature.geometry, 5).map(function (c) {
                  return c.reverse();
                })
              },
              properties: {
                'route-index': index,
                route: index === routeIndex ? 'selected' : 'alternate'
              }
            };

            geojson.features.push(lineString);
            if (index === routeIndex) {
              // Collect any possible waypoints from steps
              feature.legs[0].steps.forEach(function (d) {
                if (d.maneuver.type === 'waypoint') {
                  geojson.features.push({
                    type: 'Feature',
                    geometry: d.maneuver.location,
                    properties: {
                      id: 'waypoint'
                    }
                  });
                }
              });
            }
          });
        }

        if (_this3._map.style && _this3._map.getSource('directions')) {
          _this3._map.getSource('directions').setData(geojson);
        }
      });
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      var _this4 = this;

      var _store$getState4 = store.getState();

      var origin = _store$getState4.origin;

      var coords = [e.lngLat.lng, e.lngLat.lat];

      if (!origin.geometry) {
        this.actions.setOriginFromCoordinates(coords);
      } else {

        var features = this._map.queryRenderedFeatures(e.point, {
          layers: ['directions-origin-point', 'directions-destination-point', 'directions-waypoint-point', 'directions-route-line-alt']
        });

        if (features.length) {

          // Remove any waypoints
          features.forEach(function (f) {
            if (f.layer.id === 'directions-waypoint-point') {
              _this4.actions.removeWaypoint(f);
            }
          });

          if (features[0].properties.route === 'alternate') {
            var index = features[0].properties['route-index'];
            this.actions.setRouteIndex(index);
          }
        } else {
          this.actions.setDestinationFromCoordinates(coords);
          this._map.flyTo({ center: coords });
        }
      }
    }
  }, {
    key: '_move',
    value: function _move(e) {
      var _this5 = this;

      var _store$getState5 = store.getState();

      var hoverMarker = _store$getState5.hoverMarker;


      var features = this._map.queryRenderedFeatures(e.point, {
        layers: ['directions-route-line-alt', 'directions-route-line', 'directions-origin-point', 'directions-destination-point', 'directions-hover-point']
      });

      this._map.getCanvas().style.cursor = features.length ? 'pointer' : '';

      if (features.length) {
        this.isCursorOverPoint = features[0];
        this._map.dragPan.disable();

        // Add a possible waypoint marker when hovering over the active route line
        features.forEach(function (feature) {
          if (feature.layer.id === 'directions-route-line') {
            _this5.actions.hoverMarker([e.lngLat.lng, e.lngLat.lat]);
          } else if (hoverMarker.geometry) {
            _this5.actions.hoverMarker(null);
          }
        });
      } else if (this.isCursorOverPoint) {
        this.isCursorOverPoint = false;
        this._map.dragPan.enable();
      }
    }
  }, {
    key: '_onDragDown',
    value: function _onDragDown() {
      if (!this.isCursorOverPoint) return;
      this.isDragging = this.isCursorOverPoint;
      this._map.getCanvas().style.cursor = 'grab';

      this._map.on('mousemove', this.onDragMove);
      this._map.on('mouseup', this.onDragUp);

      this._map.on('touchmove', this.onDragMove);
      this._map.on('touchend', this.onDragUp);
    }
  }, {
    key: '_onDragMove',
    value: function _onDragMove(e) {
      if (!this.isDragging) return;

      var coords = [e.lngLat.lng, e.lngLat.lat];
      switch (this.isDragging.layer.id) {
        case 'directions-origin-point':
          this.actions.createOrigin(coords);
          break;
        case 'directions-destination-point':
          this.actions.createDestination(coords);
          break;
        case 'directions-hover-point':
          this.actions.hoverMarker(coords);
          break;
      }
    }
  }, {
    key: '_onDragUp',
    value: function _onDragUp() {
      if (!this.isDragging) return;

      var _store$getState6 = store.getState();

      var hoverMarker = _store$getState6.hoverMarker;
      var origin = _store$getState6.origin;
      var destination = _store$getState6.destination;


      switch (this.isDragging.layer.id) {
        case 'directions-origin-point':
          this.actions.setOriginFromCoordinates(origin.geometry.coordinates);
          break;
        case 'directions-destination-point':
          this.actions.setDestinationFromCoordinates(destination.geometry.coordinates);
          break;
        case 'directions-hover-point':
          // Add waypoint if a sufficent amount of dragging has occurred.
          if (hoverMarker.geometry && !_utils2.default.coordinateMatch(this.isDragging, hoverMarker)) {
            this.actions.addWaypoint(0, hoverMarker);
          }
          break;
      }

      this.isDragging = false;
      this._map.getCanvas().style.cursor = '';

      this._map.off('touchmove', this.onDragMove);
      this._map.off('touchend', this.onDragUp);

      this._map.off('mousemove', this.onDragMove);
      this._map.off('mouseup', this.onDragUp);
    }

    // API Methods
    // ============================

    /**
     * Turn on or off interactivity
     * @param {Boolean} state sets interactivity based on a state of `true` or `false`.
     * @returns {MapboxDirections} this
     */

  }, {
    key: 'interactive',
    value: function interactive(state) {
      if (state) {
        this._map.on('touchstart', this.move);
        this._map.on('touchstart', this.onDragDown);

        this._map.on('mousedown', this.onDragDown);
        this._map.on('mousemove', this.move);
        this._map.on('click', this.onClick);
      } else {
        this._map.off('touchstart', this.move);
        this._map.off('touchstart', this.onDragDown);

        this._map.off('mousedown', this.onDragDown);
        this._map.off('mousemove', this.move);
        this._map.off('click', this.onClick);
      }

      return this;
    }

    /**
     * Returns the origin of the current route.
     * @returns {Object} origin
     */

  }, {
    key: 'getOrigin',
    value: function getOrigin() {
      return store.getState().origin;
    }

    /**
     * Sets origin. _Note:_ calling this method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)
     * to have run.
     * @param {Array<number>|String} query An array of coordinates [lng, lat] or location name as a string.
     * @returns {MapboxDirections} this
     */

  }, {
    key: 'setOrigin',
    value: function setOrigin(query) {
      if (typeof query === 'string') {
        this.actions.queryOrigin(query);
      } else {
        this.actions.setOriginFromCoordinates(query);
      }

      return this;
    }

    /**
     * Returns the destination of the current route.
     * @returns {Object} destination
     */

  }, {
    key: 'getDestination',
    value: function getDestination() {
      return store.getState().destination;
    }

    /**
     * Sets destination. _Note:_ calling this method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)
     * to have run.
     * @param {Array<number>|String} query An array of coordinates [lng, lat] or location name as a string.
     * @returns {MapboxDirections} this
     */

  }, {
    key: 'setDestination',
    value: function setDestination(query) {
      if (typeof query === 'string') {
        this.actions.queryDestination(query);
      } else {
        this.actions.setDestinationFromCoordinates(query);
      }

      return this;
    }

    /**
     * Swap the origin and destination.
     * @returns {MapboxDirections} this
     */

  }, {
    key: 'reverse',
    value: function reverse() {
      this.actions.reverse();
      return this;
    }

    /**
     * Add a waypoint to the route. _Note:_ calling this method requires the
     * [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load) to have run.
     * @param {Number} index position waypoint should be placed in the waypoint array
     * @param {Array<number>|Point} waypoint can be a GeoJSON Point Feature or [lng, lat] coordinates.
     * @returns {MapboxDirections} this;
     */

  }, {
    key: 'addWaypoint',
    value: function addWaypoint(index, waypoint) {
      if (!waypoint.type) waypoint = _utils2.default.createPoint(waypoint, { id: 'waypoint' });
      this.actions.addWaypoint(index, waypoint);
      return this;
    }

    /**
     * Change the waypoint at a given index in the route. _Note:_ calling this
     * method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)
     * to have run.
     * @param {Number} index indexed position of the waypoint to update
     * @param {Array<number>|Point} waypoint can be a GeoJSON Point Feature or [lng, lat] coordinates.
     * @returns {MapboxDirections} this;
     */

  }, {
    key: 'setWaypoint',
    value: function setWaypoint(index, waypoint) {
      if (!waypoint.type) waypoint = _utils2.default.createPoint(waypoint, { id: 'waypoint' });
      this.actions.setWaypoint(index, waypoint);
      return this;
    }

    /**
     * Remove a waypoint from the route.
     * @param {Number} index position in the waypoints array.
     * @returns {MapboxDirections} this;
     */

  }, {
    key: 'removeWaypoint',
    value: function removeWaypoint(index) {
      var _store$getState7 = store.getState();

      var waypoints = _store$getState7.waypoints;

      this.actions.removeWaypoint(waypoints[index]);
      return this;
    }

    /**
     * Fetch all current waypoints in a route.
     * @returns {Array} waypoints
     */

  },{
    key: 'getDistanceAndDuration',
    value: function getDistanceAndDuration() {
      var _store$getState8 = store.getState();
      if(_store$getState8 === null){
          return null;
      }

      var directions = _store$getState8.directions;
      var routeIndex = _store$getState8.routeIndex;
      var unit = _store$getState8.unit;

      if(directions[routeIndex] === null){
        return null;
      }


      var duration = _utils2.default.format.duration(directions[routeIndex].duration);
      var distance = _utils2.default.format[unit](directions[routeIndex].distance);

      return {duration, distance};
    }

    /**
     * Removes all routes and waypoints from the map.
     *
     * @returns {MapboxDirections} this;
     */

  }, {
    key: 'getWaypoints',
    value: function getWaypoints() {
      return store.getState().waypoints;
    }

    /**
     * Removes all routes and waypoints from the map.
     *
     * @returns {MapboxDirections} this;
     */

  }, {
    key: 'removeRoutes',
    value: function removeRoutes() {
      this.actions.clearOrigin();
      this.actions.clearDestination();
      return this;
    }

    /**
     * Subscribe to events that happen within the plugin.
     * @param {String} type name of event. Available events and the data passed into their respective event objects are:
     *
     * - __clear__ `{ type: } Type is one of 'origin' or 'destination'`
     * - __loading__ `{ type: } Type is one of 'origin' or 'destination'`
     * - __profile__ `{ profile } Profile is one of 'driving', 'walking', or 'cycling'`
     * - __origin__ `{ feature } Fired when origin is set`
     * - __destination__ `{ feature } Fired when destination is set`
     * - __route__ `{ route } Fired when a route is updated`
     * - __error__ `{ error } Error as string
     * @param {Function} fn function that's called when the event is emitted.
     * @returns {MapboxDirections} this;
     */

  }, {
    key: 'on',
    value: function on(type, fn) {
      this.actions.eventSubscribe(type, fn);
      return this;
    }
  }]);

  return MapboxDirections;
}();

exports.default = MapboxDirections;

},{"./actions":33,"./controls/inputs":36,"./controls/instructions":37,"./directions_style":39,"./reducers":41,"./utils":42,"polyline":10,"redux":17,"redux-thunk":11}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var style = [{
  'id': 'directions-route-line-alt',
  'type': 'line',
  'source': 'directions',
  'layout': {
    'line-cap': 'round',
    'line-join': 'round'
  },
  'paint': {
    'line-color': '#bbb',
    'line-width': 4
  },
  'filter': ['all', ['in', '$type', 'LineString'], ['in', 'route', 'alternate']]
}, {
  'id': 'directions-route-line',
  'type': 'line',
  'source': 'directions',
  'layout': {
    'line-cap': 'round',
    'line-join': 'round'
  },
  'paint': {
    'line-color': '#608BC7',
    'line-width': 4
  },
  'filter': ['all', ['in', '$type', 'LineString'], ['in', 'route', 'selected']]
}, {
  'id': 'directions-hover-point-casing',
  'type': 'circle',
  'source': 'directions',
  'paint': {
    'circle-radius': 8,
    'circle-color': '#fff'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'id', 'hover']]
}, {
  'id': 'directions-hover-point',
  'type': 'circle',
  'source': 'directions',
  'paint': {
    'circle-radius': 6,
    'circle-color': '#3bb2d0'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'id', 'hover']]
}, {
  'id': 'directions-waypoint-point-casing',
  'type': 'circle',
  'source': 'directions',
  'paint': {
    'circle-radius': 8,
    'circle-color': '#fff'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'id', 'waypoint']]
}, {
  'id': 'directions-waypoint-point',
  'type': 'circle',
  'source': 'directions',
  'paint': {
    'circle-radius': 6,
    'circle-color': '#608BC7'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'id', 'waypoint']]
}, {
  'id': 'directions-origin-point',
  'type': 'circle',
  'source': 'directions',
  'paint': {
    'circle-radius': 18,
    'circle-color': '#93AFD7'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'marker-symbol', 'A']]
}, {
  'id': 'directions-origin-label',
  'type': 'symbol',
  'source': 'directions',
  'layout': {
    'text-field': 'A',
    'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
    'text-size': 12
  },
  'paint': {
    'text-color': '#fff'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'marker-symbol', 'A']]
}, {
  'id': 'directions-destination-point',
  'type': 'circle',
  'source': 'directions',
  'paint': {
    'circle-radius': 18,
    'circle-color': '#608BC7'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'marker-symbol', 'B']]
}, {
  'id': 'directions-destination-label',
  'type': 'symbol',
  'source': 'directions',
  'layout': {
    'text-field': 'B',
    'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
    'text-size': 12
  },
  'paint': {
    'text-color': '#fff'
  },
  'filter': ['all', ['in', '$type', 'Point'], ['in', 'marker-symbol', 'B']]
}];

exports.default = style;

},{}],40:[function(require,module,exports){
'use strict';

var _directions = require('./directions');

var _directions2 = _interopRequireDefault(_directions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = _directions2.default;

},{"./directions":38}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _action_types = require('../constants/action_types.js');

var types = _interopRequireWildcard(_action_types);

var _deepAssign = require('deep-assign');

var _deepAssign2 = _interopRequireDefault(_deepAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var initialState = {
  // Options set on initialization
  api: 'https://api.mapbox.com/directions/v5/',
  profile: 'driving-traffic',
  unit: 'imperial',
  proximity: false,
  styles: [],

  // UI controls
  controls: {
    inputs: true,
    instructions: true
  },

  // Optional setting to pass options available to mapbox-gl-geocoder
  geocoder: {},

  interactive: true,

  // Container for client registered events
  events: {},

  // Marker feature drawn on the map at any point.
  origin: {},
  destination: {},
  hoverMarker: {},
  waypoints: [],

  // User input strings or result returned from geocoder
  originQuery: null,
  destinationQuery: null,
  originQueryCoordinates: null,
  destinationQueryCoordinates: null,

  // Directions data
  directions: [],
  routeIndex: 0
};

function data() {
  var state = arguments.length <= 0 || arguments[0] === undefined ? initialState : arguments[0];
  var action = arguments[1];

  switch (action.type) {
    case types.SET_OPTIONS:
      return (0, _deepAssign2.default)({}, state, action.options);

    case types.DIRECTIONS_PROFILE:
      return Object.assign({}, state, {
        profile: action.profile
      });

    case types.ORIGIN:
      return Object.assign({}, state, {
        origin: action.origin,
        hoverMarker: {}
      });

    case types.DESTINATION:
      return Object.assign({}, state, {
        destination: action.destination,
        hoverMarker: {}
      });

    case types.HOVER_MARKER:
      return Object.assign({}, state, {
        hoverMarker: action.hoverMarker
      });

    case types.WAYPOINTS:
      return Object.assign({}, state, {
        waypoints: action.waypoints
      });

    case types.ORIGIN_QUERY:
      return Object.assign({}, state, {
        originQuery: action.query
      });

    case types.DESTINATION_QUERY:
      return Object.assign({}, state, {
        destinationQuery: action.query
      });

    case types.ORIGIN_FROM_COORDINATES:
      return Object.assign({}, state, {
        originQueryCoordinates: action.coordinates
      });

    case types.DESTINATION_FROM_COORDINATES:
      return Object.assign({}, state, {
        destinationQueryCoordinates: action.coordinates
      });

    case types.ORIGIN_CLEAR:
      return Object.assign({}, state, {
        origin: {},
        originQuery: '',
        waypoints: [],
        directions: []
      });

    case types.DESTINATION_CLEAR:
      return Object.assign({}, state, {
        destination: {},
        destinationQuery: '',
        waypoints: [],
        directions: []
      });

    case types.DIRECTIONS:
      return Object.assign({}, state, {
        directions: action.directions
      });

    case types.ROUTE_INDEX:
      return Object.assign({}, state, {
        routeIndex: action.routeIndex
      });

    case types.ERROR:
      return Object.assign({}, state, {
        error: action.error
      });

    default:
      return state;
  }
}

exports.default = data;

},{"../constants/action_types.js":34,"deep-assign":3}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
function validCoords(coords) {
  return coords[0] >= -180 && coords[0] <= 180 && coords[1] >= -90 && coords[1] <= 90;
}

function coordinateMatch(a, b) {
  a = a.geometry.coordinates;
  b = b.geometry.coordinates;
  return a.join() === b.join() || a[0].toFixed(3) === b[0].toFixed(3) && a[1].toFixed(3) === b[1].toFixed(3);
}

function wrap(n) {
  var d = 180 - -180;
  var w = ((n - -180) % d + d) % d + -180;
  return w === -180 ? 180 : w;
}

function createPoint(coordinates, properties) {
  return {
    type: 'Feature',
    geometry: {
      type: 'Point',
      coordinates: coordinates
    },
    properties: properties ? properties : {}
  };
}

var format = {
  duration: function duration(s) {
    var m = Math.floor(s / 60),
        h = Math.floor(m / 60);
    s %= 60;
    m %= 60;
    if (h === 0 && m === 0) return s + 's';
    if (h === 0) return m + 'min';
    return h + 'h ' + m + 'min';
  },
  imperial: function imperial(m) {
    var mi = m / 1609.344;
    if (mi >= 100) return mi.toFixed(0) + 'mi';
    if (mi >= 10) return mi.toFixed(1) + 'mi';
    if (mi >= 0.1) return mi.toFixed(2) + 'mi';
    return (mi * 5280).toFixed(0) + 'ft';
  },
  metric: function metric(m) {
    if (m >= 100000) return (m / 1000).toFixed(0) + 'km';
    if (m >= 10000) return (m / 1000).toFixed(1) + 'km';
    if (m >= 100) return (m / 1000).toFixed(2) + 'km';
    return m.toFixed(0) + 'm';
  }
};

exports.default = { format: format, coordinateMatch: coordinateMatch, createPoint: createPoint, validCoords: validCoords, wrap: wrap };

},{}]},{},[40])(40)
});

/*global $ */
$(window).on("scroll", function (event) {
	var scrollValue = $(window).scrollTop();
	if (scrollValue > 220) {
		$(".navbar").addClass("affix");
	} else {
		$(".navbar").removeClass("affix");
	}
});



/*Load location (stores2)*/
var stores2 = (function () {
	stores2 = null;
	$.ajax({
		"async": false,
		"global": false,
		"url": "https://leipzig-einkaufen.de/location.json",
		//"url": "http://localhost/vectortiles/museen.json",
		"dataType": "json",
		"success": function (data) {
			stores2 = data;
		}
	});
	return stores2;
})();

// declare map
var map = new mapboxgl.Map({

	container: "map",
	style: "https://leipzig-einkaufen.de/json/style-local.json",
	//style: "http://localhost/vectortiles/json/style-local.json",

	center: [12.3722, 51.3272],
	zoom: 11,
	attributionControl: true,
	hash: false,
	maxZoom: 14.9
});

/*Declare MapDirections*/

var mapDirections = new MapboxDirections();
/*MapDirections Settings*/
mapDirections.accessToken = "pk.eyJ1Ijoic2hldWIiLCJhIjoiWGtobTNPNCJ9.v2JwlNSGBm_KxJUKE_WLig";
mapDirections.unit = "metric";
mapDirections.proximity = false; /*proximity ??*/
mapDirections.interactive = false;
mapDirections.profile = "driving"; //, "walking", "cycling";
// UI controls
mapDirections.controls = {
	inputs: true,
	instructions: false
};

/*Add mapDirections Controls*/
map.addControl(new MapboxDirections(mapDirections), "top-left");

map.addControl(new mapboxgl.ScaleControl({
	maxWidth: 80,
	unit: "metric"
}));

var directionControl = document.getElementsByClassName("mapboxgl-ctrl-directions");
directionControl["0"].hidden = true;
var ptsWithin = null;

// Create a popup (but don't add it to the map yet)
var popup = new mapboxgl.Popup({
	closeButton: false
});

var filterEl = document.getElementById("feature-filter");
var listings = document.getElementById("listings");
var txtCategories = document.getElementById("txtCategories");

// Empty Geojson Data
var bufferedLinestring = {
	"id": "0",
	"type": "Feature",
	"geometry": {
		"type": "Point",
		"coordinates": [0, 0]
	},
	"properties": {}
};

// Functions
function normalize(string) {
	return string.trim().toLowerCase();
}

function createPopUp(currentFeature) {

	var popup = new mapboxgl.Popup({
			closeOnClick: true
		})
		.setLngLat(currentFeature.geometry.coordinates)
		.setHTML("<h3>" + currentFeature.properties.name + "</h3>" +
			"<h4>" + currentFeature.properties.description + "</h4>")
		.addTo(map);
}

function getUniqueFeatures(array, comparatorProperty) {

	var existingFeatureKeys = {};
	// Because features come from tiled vector data, feature geometries may be split
	// or duplicated across tile boundaries and, as a result, features may appear
	// multiple times in query results.
	var uniqueFeatures = array.filter(function (el) {
		if (existingFeatureKeys[el.properties[comparatorProperty]]) {
			return false;
		} else {
			existingFeatureKeys[el.properties[comparatorProperty]] = true;
			return true;
		}
	});

	return uniqueFeatures;
}

function colorLocationList(data) {

	// Iterate through the list of stores
	// WITHIN THE CALCULATED ROUTE !! and color in green
	if (data.length) {
		data.forEach(function (feature) {

			// Shorten data.feature.properties to just `prop`.
			var prop = feature.properties;
			var cardHeader = document.getElementById("heading" + prop.id);
			if (cardHeader === null) {
				return;
			}

			var cardTitle = cardHeader.getElementsByClassName("title");
			cardTitle[0].style.color = "#608BC7";

		})
	}
}

function buildLocationList(data) {
	// Iterate through the list of stores
	listings.innerHTML = "";
	if (data.length) {
		data.forEach(function (feature) {

			// Shorten data.feature.properties to just `prop` so we're not writing this long form over and over again.
			var prop = feature.properties;

			// Select the listing container in the HTML and append a div  with the class 'item' for each store
			var card = listings.appendChild(document.createElement("div"));
			card.className = "item card cardList";
			card.id = prop.id;

			var cardHeader = card.appendChild(document.createElement("div"));
			cardHeader.className = "card-header";
			cardHeader.setAttribute("role", "tab");

			cardHeader.setAttribute("id", "heading" + card.id);
			cardHeader.id = "heading" + card.id;

			var cardMb0 = cardHeader.appendChild(document.createElement("h5"));
			cardMb0.className = "mb-0";

			// Create a new link with the class 'title' for each store and fill it with the store address
			var link = cardMb0.appendChild(document.createElement("a"));
			link.setAttribute("data-toggle", "collapse");
			link.href = "#collapse" + card.id;
			link.setAttribute("aria-expanded", "false");
			link.setAttribute("aria-controls", "collapse" + card.id);
			link.className = "title";
			link.textContent = prop.name;
			link.dataPosition = card.id;

			var cardCollapse = card.appendChild(document.createElement("div"));
			cardCollapse.className = "collapse";
			cardCollapse.setAttribute("id", "collapse" + card.id);
			cardCollapse.setAttribute("role", "tabpanel");
			cardCollapse.setAttribute("aria-labelledby", "heading" + card.id);
			cardCollapse.setAttribute("data-parent", "#listings");

			if (prop.image) {
				var cardImg = cardCollapse.appendChild(document.createElement("img"));
				cardImg.className = "img-responsive img-listing";
				cardImg.src = prop.image;
				cardImg.alt = prop.name;
				cardImg.title = prop.name;
			}

			var cardBody = cardCollapse.appendChild(document.createElement("div"));
			cardBody.className = "card-body";
			cardBody.textContent = prop.description;
			cardBody.appendChild(document.createElement("br"));
			
			if (prop.url) {
				var linkBody = cardBody.appendChild(document.createElement("a"));
				linkBody.textContent = prop.name;
				linkBody.href = prop.url;
				linkBody.target = "_blank";
				linkBody.title = prop.name;
			}

			// Add an event listener for the links in the sidebar listing
			link.addEventListener("click", function (e) {
				// Update the currentFeature to the store associated with the clicked link
				var clickedListing = stores2.features[this.dataPosition];

				var popUps = document.getElementsByClassName("mapboxgl-popup");
				// Check if there is already a popup on the map and if so, remove it
				if (popUps[0]) {
					popUps[0].parentNode.removeChild(popUps[0]);
				}

				// 1. Close all other popups and display popup for clicked store
				createPopUp(clickedListing);

				// 2. Highlight listing in sidebar (and remove highlight for all other listings)
				var activeItem = document.getElementsByClassName("is-active");
				if (activeItem[0]) {
					activeItem[0].classList.remove("is-active");
				}
				this.classList.add("is-active");

			});

		});

	} else {
		var empty = document.createElement("p");
		empty.textContent = "Ziehen Sie die Karte, um die Ergebnisse zu füllen";
		listings.appendChild(empty);

		// remove features filter
		map.setFilter("locations", ["has", "Categories"]);
	}


	// Populate features for the listing overlay.
	if (ptsWithin) {
		colorLocationList(ptsWithin["features"]);
	}
}

function filterOnRoute() {

	var mapDirectionsSource = map.getSource("directions");
	var radius = 0.6;
	var unit = "kilometers";

	//var distDuration = mapDirections.getDistanceAndDuration();

	// buffer the route with a area of radius 'radius'
	if (mapDirectionsSource._data.features.length < 2) {
		return;
	}
	var bufferedLinestring = turf.buffer(mapDirectionsSource._data.features[2].geometry, radius, {
		units: unit
	});

	// update bufferedTraceSource
	map.getSource("bufferedTraceSource").setData(bufferedLinestring);

	// Get locations rendered on the map
	var features = map.queryRenderedFeatures({
		layers: ["locations"]
	});

	// use featureCollection to convert features (array of features) into a collection of features (Object type FeatureCollection);
	var collection = turf.featureCollection(features);

	// Filter the points to the area around the direction
	ptsWithin = turf.pointsWithinPolygon(collection, bufferedLinestring);

	// Populate features for the listing overlay.
	if (ptsWithin) {
		buildLocationList(features);
	}
}

function displayDirectionControls() {

	var directionControl = document.getElementsByClassName("mapboxgl-ctrl-directions");
	if (directionControl["0"].hidden) {
		directionControl["0"].hidden = false;
		map.setLayoutProperty("bufferedTraceLayer", "visibility", "visible");

		map.setLayoutProperty("directions-origin-point", "visibility", "visible");
		map.setLayoutProperty("directions-destination-point", "visibility", "visible");
		map.setLayoutProperty("directions-origin-label", "visibility", "visible");
		map.setLayoutProperty("directions-destination-label", "visibility", "visible");

		map.setLayoutProperty("directions-hover-point", "visibility", "visible");
		map.setLayoutProperty("directions-waypoint-point", "visibility", "visible");
		map.setLayoutProperty("directions-route-line", "visibility", "visible");
		map.setLayoutProperty("directions-route-line-alt", "visibility", "visible");
		filterOnRoute();
	} else {
		directionControl["0"].hidden = true;
		// reinitialize ptsWithin
		ptsWithin = null;

		map.setLayoutProperty("bufferedTraceLayer", "visibility", "none");
		map.setLayoutProperty("directions-origin-point", "visibility", "none");
		map.setLayoutProperty("directions-destination-point", "visibility", "none");
		map.setLayoutProperty("directions-origin-label", "visibility", "none");
		map.setLayoutProperty("directions-destination-label", "visibility", "none");

		map.setLayoutProperty("directions-hover-point", "visibility", "none");
		map.setLayoutProperty("directions-waypoint-point", "visibility", "none");
		map.setLayoutProperty("directions-route-line", "visibility", "none");
		map.setLayoutProperty("directions-route-line-alt", "visibility", "none");

		var features = map.queryRenderedFeatures({
			layers: ["locations"]
		});

		if (features) {
			// Populate features for the listing overlay.
			buildLocationList(features);
		}
	}
}


// Call buildlist function on initialization
buildLocationList(stores2["features"]);

// Load map
map.on("load", function (e) {

	map.loadImage("https://leipzig-einkaufen.de/media/diagonal-noise.png", function (error, image) {

		if (error) throw error;
		map.addImage("background_pattern", image);
	});

	//map.loadImage('http://localhost/vectortiles/media/Marker_with_Shadow.png', function(error, image) {
	map.loadImage("https://leipzig-einkaufen.de/media/Marker_with_Shadow.png", function (error, image) {

		if (error) throw error;
		map.addImage("marker_z", image);

		// Add the stores2 (locations_source) to the map
		map.addSource("locations_source", {
			"type": "geojson",
			"data": stores2
		});

		// Add the locations_source to the map as a layer
		map.addLayer({
			"id": "locations",
			"type": "symbol",
			// Add a GeoJSON source containing place coordinates and information.
			"source": "locations_source",
			"layout": {
				"visibility": "visible",
				"icon-image": "marker_z",
				"icon-size": 0.9,
				"icon-allow-overlap": true
			}
		});

		// Add the bufferedLinestring to the map as a layer
		map.addSource("bufferedTraceSource", {
			"type": "geojson",
			"data": bufferedLinestring,
			"maxzoom": 13
		});
		map.addLayer({
			"id": "bufferedTraceLayer",
			"type": "fill",
			"source": "bufferedTraceSource",
			"layout": {
				"visibility": "visible"
			},
			"paint": {
				"fill-color": "rgb(0,0,0)",
				"fill-opacity": 1,
				"fill-translate": [
          0,
          2.5
        ],
				"fill-pattern": "background_pattern"
			}

		});

		// Add Fullscreen control to the map.
		map.addControl(new mapboxgl.FullscreenControl());

		// Add geolocate control to the map.
		map.addControl(new mapboxgl.GeolocateControl({
			positionOptions: {
				enableHighAccuracy: true
			},
			trackUserLocation: true
		}));

		// When a click event occurs on a feature in the places layer, open a popup at the
		// location of the feature, with description HTML from its properties.
		map.on("click", "locations", function (e) {
			var currentFeature = e.features[0];
			// 1. Create Popup
			createPopUp(currentFeature);

			// 2. Highlight listing in sidebar (and remove highlight for other listing)
			var activeItem = document.getElementsByClassName("is-active");
			if (activeItem[0]) {
				activeItem[0].classList.remove("is-active");
			}

			var headingElement = document.getElementById("heading" + currentFeature.properties.id);
			if (headingElement) {
				headingElement.classList.add("is-active");
			}
			var collapseElement = document.getElementById("collapse" + currentFeature.properties.id);
			if (collapseElement) {
				$(collapseElement).collapse("show");
			}

		});

		map.on("moveend", function () {
			// Query all the rendered points in the view
			var features = map.queryRenderedFeatures({
				layers: ["locations"]
			});

			if (features) {

				//var uniqueFeatures = getUniqueFeatures(features, "Categories");

				// Populate features for the listing overlay.
				buildLocationList(features);

				// Clear the input container
				filterEl.value = "";

				// Store the current features in sn `locations_on_map` variable to later use for filtering on `keyup`.
				locations = features;
			}
		});

		map.on("mousemove", "locations", function (e) {
			// Change the cursor style as a UI indicator.
			map.getCanvas().style.cursor = "pointer";

		});

		map.on("mouseleave", "locations", function () {
			map.getCanvas().style.cursor = "";
			popup.remove();
		});

		$(".dropdown-item").click(function () {

			var value = normalize($(this).text());

			var filtered = map.querySourceFeatures("locations_source");
			if (value !== "alle") {
				// Filter visible features that don't match the input value.
				filtered = filtered.filter(function (feature) {
					var name = normalize(feature.properties.name);
					var Categories = normalize(feature.properties.Categories);
					return name.indexOf(value) > -1 || Categories.indexOf(value) > -1;
				});
			}
			if (!filtered) {
				return;
			}


			var uniqueFeatures = getUniqueFeatures(filtered, "Categories");
			// Populate the sidebar with filtered results
			buildLocationList(uniqueFeatures);

			// Set the filter to populate features into the layer.
			map.setFilter("locations", ["in", "name"].concat(uniqueFeatures.map(function (feature) {
				return feature.properties.name;
			})));


			txtCategories.value = value;

		});

		/*    filterEl.addEventListener("keyup", function(e) {

		      var value = normalize(e.target.value);

		      // Filter visible features that don't match the input value.
		      var filtered = locations.filter(function(feature) {

		        var name = normalize(feature.properties.name);
		        var Categories = normalize(feature.properties.Categories);
		        return name.indexOf(value) > -1 || Categories.indexOf(value) > -1;
		      });

		      // Populate the sidebar with filtered results
		      buildLocationList(filtered);

		      // Set the filter to populate features into the layer.
		      map.setFilter("locations", ["in", "name"].concat(filtered.map(function(feature) {
		        return feature.properties.name;
		      })));

		    });*/

	});
});

// Direction event listener
mapDirections.on("route", function (e) {
	filterOnRoute();
});

// Display Direction
$("#btnDisplayControls").on("click", function (e) {
	displayDirectionControls();
})

+function(t,e,r){"use strict";var i={calc:!1};e.fn.rrssb=function(t){var i=e.extend({description:r,emailAddress:r,emailBody:r,emailSubject:r,image:r,title:r,url:r},t);i.emailSubject=i.emailSubject||i.title,i.emailBody=i.emailBody||(i.description?i.description:"")+(i.url?"\n\n"+i.url:"");for(var s in i)i.hasOwnProperty(s)&&i[s]!==r&&(i[s]=a(i[s]));i.url!==r&&(e(this).find(".rrssb-facebook a").attr("href","https://www.facebook.com/sharer/sharer.php?u="+i.url),e(this).find(".rrssb-tumblr a").attr("href","http://tumblr.com/share/link?url="+i.url+(i.title!==r?"&name="+i.title:"")+(i.description!==r?"&description="+i.description:"")),e(this).find(".rrssb-linkedin a").attr("href","http://www.linkedin.com/shareArticle?mini=true&url="+i.url+(i.title!==r?"&title="+i.title:"")+(i.description!==r?"&summary="+i.description:"")),e(this).find(".rrssb-twitter a").attr("href","https://twitter.com/intent/tweet?text="+(i.description!==r?i.description:"")+"%20"+i.url),e(this).find(".rrssb-hackernews a").attr("href","https://news.ycombinator.com/submitlink?u="+i.url+(i.title!==r?"&text="+i.title:"")),e(this).find(".rrssb-vk a").attr("href","https://vk.com/share.php?url="+i.url),e(this).find(".rrssb-reddit a").attr("href","http://www.reddit.com/submit?url="+i.url+(i.description!==r?"&text="+i.description:"")+(i.title!==r?"&title="+i.title:"")),e(this).find(".rrssb-googleplus a").attr("href","https://plus.google.com/share?url="+i.url),e(this).find(".rrssb-pinterest a").attr("href","http://pinterest.com/pin/create/button/?url="+i.url+(i.image!==r?"&amp;media="+i.image:"")+(i.description!==r?"&description="+i.description:"")),e(this).find(".rrssb-pocket a").attr("href","https://getpocket.com/save?url="+i.url),e(this).find(".rrssb-github a").attr("href",i.url),e(this).find(".rrssb-print a").attr("href","javascript:window.print()"),e(this).find(".rrssb-whatsapp a").attr("href","whatsapp://send?text="+(i.description!==r?i.description+"%20":i.title!==r?i.title+"%20":"")+i.url)),(i.emailAddress!==r||i.emailSubject)&&e(this).find(".rrssb-email a").attr("href","mailto:"+(i.emailAddress?i.emailAddress:"")+"?"+(i.emailSubject!==r?"subject="+i.emailSubject:"")+(i.emailBody!==r?"&body="+i.emailBody:""))};var s=function(){var t=e("<div>"),r=["calc","-webkit-calc","-moz-calc"];e("body").append(t);for(var s=0;s<r.length;s++)if(t.css("width",r[s]+"(1px)"),1===t.width()){i.calc=r[s];break}t.remove()},a=function(t){if(t!==r&&null!==t){if(null===t.match(/%[0-9a-f]{2}/i))return encodeURIComponent(t);t=decodeURIComponent(t),a(t)}},n=function(){e(".rrssb-buttons").each(function(t){var r=e(this),i=e("li:visible",r),s=i.length,a=100/s;i.css("width",a+"%").attr("data-initwidth",a)})},l=function(){e(".rrssb-buttons").each(function(t){var r=e(this),i=r.width(),s=e("li",r).not(".small").eq(0).width(),a=e("li.small",r).length;if(s>170&&a<1){r.addClass("large-format");var n=s/12+"px";r.css("font-size",n)}else r.removeClass("large-format"),r.css("font-size","");i<25*a?r.removeClass("small-format").addClass("tiny-format"):r.removeClass("tiny-format")})},o=function(){e(".rrssb-buttons").each(function(t){var r=e(this),i=e("li",r),s=i.filter(".small"),a=0,n=0,l=s.eq(0),o=parseFloat(l.attr("data-size"))+55,c=s.length;if(c===i.length){var d=42*c,u=r.width();d+o<u&&(r.removeClass("small-format"),s.eq(0).removeClass("small"),h())}else{i.not(".small").each(function(t){var r=e(this),i=parseFloat(r.attr("data-size"))+55,s=parseFloat(r.width());a+=s,n+=i});var m=a-n;o<m&&(l.removeClass("small"),h())}})},c=function(t){e(".rrssb-buttons").each(function(t){var r=e(this),i=e("li",r);e(i.get().reverse()).each(function(t,r){var s=e(this);if(s.hasClass("small")===!1){var a=parseFloat(s.attr("data-size"))+55,n=parseFloat(s.width());if(a>n){var l=i.not(".small").last();e(l).addClass("small"),h()}}--r||o()})}),t===!0&&u(h)},h=function(){e(".rrssb-buttons").each(function(t){var r,s,a,l,o,c=e(this),h=e("li",c),d=h.filter(".small"),u=d.length;u>0&&u!==h.length?(c.removeClass("small-format"),d.css("width","42px"),a=42*u,r=h.not(".small").length,s=100/r,o=a/r,i.calc===!1?(l=(c.innerWidth()-1)/r-o,l=Math.floor(1e3*l)/1e3,l+="px"):l=i.calc+"("+s+"% - "+o+"px)",h.not(".small").css("width",l)):u===h.length?(c.addClass("small-format"),n()):(c.removeClass("small-format"),n())}),l()},d=function(){e(".rrssb-buttons").each(function(t){e(this).addClass("rrssb-"+(t+1))}),s(),n(),e(".rrssb-buttons li .rrssb-text").each(function(t){var r=e(this),i=r.width();r.closest("li").attr("data-size",i)}),c(!0)},u=function(t){e(".rrssb-buttons li.small").removeClass("small"),c(),t()},m=function(e,i,s,a){var n=t.screenLeft!==r?t.screenLeft:screen.left,l=t.screenTop!==r?t.screenTop:screen.top,o=t.innerWidth?t.innerWidth:document.documentElement.clientWidth?document.documentElement.clientWidth:screen.width,c=t.innerHeight?t.innerHeight:document.documentElement.clientHeight?document.documentElement.clientHeight:screen.height,h=o/2-s/2+n,d=c/3-a/3+l,u=t.open(e,i,"scrollbars=yes, width="+s+", height="+a+", top="+d+", left="+h);u&&u.focus&&u.focus()},f=function(){var t={};return function(e,r,i){i||(i="Don't call this twice without a uniqueId"),t[i]&&clearTimeout(t[i]),t[i]=setTimeout(e,r)}}();e(document).ready(function(){try{e(document).on("click",".rrssb-buttons a.popup",{},function(t){var r=e(this);m(r.attr("href"),r.find(".rrssb-text").html(),580,470),t.preventDefault()})}catch(t){}e(t).resize(function(){u(h),f(function(){u(h)},200,"finished resizing")}),d()}),t.rrssbInit=d}(window,jQuery);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1hcGJveC1nbC1kaXJlY3Rpb25zLmpzIiwiYXBwLmpzIiwicnJzc2IubWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ppUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNWdCQSIsImZpbGUiOiJhcHAubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuTWFwYm94RGlyZWN0aW9ucyA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXHJcbi8vXHJcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXHJcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxyXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcclxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbi8vXHJcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXHJcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4vL1xyXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXHJcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxyXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcclxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXHJcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcclxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcclxuXHJcbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxyXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xyXG5cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XHJcblxyXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcclxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cclxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcclxuXHJcbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xyXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XHJcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcclxuICAgIHRocm93IFR5cGVFcnJvcihcIm4gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcclxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xyXG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XHJcblxyXG4gIGlmICghdGhpcy5fZXZlbnRzKVxyXG4gICAgdGhpcy5fZXZlbnRzID0ge307XHJcblxyXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cclxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcclxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcclxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XHJcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xyXG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgLy8gZmFzdCBjYXNlc1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzpcclxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAvLyBzbG93ZXJcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcclxuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xyXG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcclxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcclxuICB2YXIgbTtcclxuXHJcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcclxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcblxyXG4gIGlmICghdGhpcy5fZXZlbnRzKVxyXG4gICAgdGhpcy5fZXZlbnRzID0ge307XHJcblxyXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXHJcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxyXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXHJcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcclxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XHJcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XHJcblxyXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxyXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXHJcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcclxuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxyXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxyXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xyXG4gIGVsc2VcclxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxyXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xyXG5cclxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xyXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XHJcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcclxuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcclxuICAgIH1cclxuXHJcbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xyXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcclxuICAgICAgY29uc29sZS5lcnJvcihcIihub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcImxlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gXCIgK1xyXG5cdFx0XHRcdFx0XCJVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC5cIixcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcclxuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXHJcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xyXG5cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcclxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxyXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcclxuXHJcbiAgdmFyIGZpcmVkID0gZmFsc2U7XHJcblxyXG4gIGZ1bmN0aW9uIGcoKSB7XHJcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xyXG5cclxuICAgIGlmICghZmlyZWQpIHtcclxuICAgICAgZmlyZWQgPSB0cnVlO1xyXG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gIHRoaXMub24odHlwZSwgZyk7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XHJcblxyXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXHJcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG5cclxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XHJcbiAgcG9zaXRpb24gPSAtMTtcclxuXHJcbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XHJcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXHJcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XHJcblxyXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcclxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcclxuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XHJcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcclxuICAgICAgICBwb3NpdGlvbiA9IGk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocG9zaXRpb24gPCAwKVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgbGlzdC5sZW5ndGggPSAwO1xyXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXHJcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xyXG4gIHZhciBrZXksIGxpc3RlbmVycztcclxuXHJcbiAgaWYgKCF0aGlzLl9ldmVudHMpXHJcbiAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxyXG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XHJcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXHJcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcclxuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XHJcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcclxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcclxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcclxuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xyXG4gICAgLy8gTElGTyBvcmRlclxyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXHJcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XHJcbiAgfVxyXG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgdmFyIHJldDtcclxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxyXG4gICAgcmV0ID0gW107XHJcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxyXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XHJcbiAgZWxzZVxyXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XHJcbiAgcmV0dXJuIHJldDtcclxufTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICBpZiAodGhpcy5fZXZlbnRzKSB7XHJcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxyXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XHJcbiAgfVxyXG4gIHJldHVybiAwO1xyXG59O1xyXG5cclxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XHJcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xyXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XHJcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xyXG59XHJcblxyXG59LHt9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXHJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcclxuXHJcbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxyXG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcclxuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxyXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxyXG5cclxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XHJcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59ICgpKVxyXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xyXG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcclxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcclxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcclxuICAgIH0gY2F0Y2goZSl7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcclxuICAgICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xyXG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XHJcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXHJcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xyXG4gICAgfSBjYXRjaCAoZSl7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcclxuICAgICAgICB9IGNhdGNoIChlKXtcclxuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXHJcbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG59XHJcbnZhciBxdWV1ZSA9IFtdO1xyXG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcclxudmFyIGN1cnJlbnRRdWV1ZTtcclxudmFyIHF1ZXVlSW5kZXggPSAtMTtcclxuXHJcbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcclxuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGRyYWluaW5nID0gZmFsc2U7XHJcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcclxuICAgIH1cclxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICBkcmFpblF1ZXVlKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XHJcbiAgICBpZiAoZHJhaW5pbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcclxuICAgIGRyYWluaW5nID0gdHJ1ZTtcclxuXHJcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xyXG4gICAgd2hpbGUobGVuKSB7XHJcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XHJcbiAgICAgICAgcXVldWUgPSBbXTtcclxuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XHJcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcclxuICAgIGRyYWluaW5nID0gZmFsc2U7XHJcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XHJcbn1cclxuXHJcbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XHJcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xyXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcclxuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xyXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcclxuICAgIHRoaXMuZnVuID0gZnVuO1xyXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xyXG59XHJcbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xyXG59O1xyXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xyXG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xyXG5wcm9jZXNzLmVudiA9IHt9O1xyXG5wcm9jZXNzLmFyZ3YgPSBbXTtcclxucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXHJcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIG5vb3AoKSB7fVxyXG5cclxucHJvY2Vzcy5vbiA9IG5vb3A7XHJcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xyXG5wcm9jZXNzLm9uY2UgPSBub29wO1xyXG5wcm9jZXNzLm9mZiA9IG5vb3A7XHJcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xyXG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XHJcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XHJcblxyXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG59O1xyXG5cclxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcclxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XHJcbn07XHJcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XHJcblxyXG59LHt9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgaXNPYmogPSByZXF1aXJlKCdpcy1vYmonKTtcclxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xyXG5cclxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XHJcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignU291cmNlcyBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBPYmplY3QodmFsKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXNzaWduS2V5KHRvLCBmcm9tLCBrZXkpIHtcclxuXHR2YXIgdmFsID0gZnJvbVtrZXldO1xyXG5cclxuXHRpZiAodmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0bywga2V5KSkge1xyXG5cdFx0aWYgKHRvW2tleV0gPT09IHVuZGVmaW5lZCB8fCB0b1trZXldID09PSBudWxsKSB7XHJcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCAoJyArIGtleSArICcpJyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodG8sIGtleSkgfHwgIWlzT2JqKHZhbCkpIHtcclxuXHRcdHRvW2tleV0gPSB2YWw7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRvW2tleV0gPSBhc3NpZ24oT2JqZWN0KHRvW2tleV0pLCBmcm9tW2tleV0pO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXNzaWduKHRvLCBmcm9tKSB7XHJcblx0aWYgKHRvID09PSBmcm9tKSB7XHJcblx0XHRyZXR1cm4gdG87XHJcblx0fVxyXG5cclxuXHRmcm9tID0gT2JqZWN0KGZyb20pO1xyXG5cclxuXHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xyXG5cdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xyXG5cdFx0XHRhc3NpZ25LZXkodG8sIGZyb20sIGtleSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xyXG5cdFx0dmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XHJcblx0XHRcdFx0YXNzaWduS2V5KHRvLCBmcm9tLCBzeW1ib2xzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRvO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZXBBc3NpZ24odGFyZ2V0KSB7XHJcblx0dGFyZ2V0ID0gdG9PYmplY3QodGFyZ2V0KTtcclxuXHJcblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcclxuXHRcdGFzc2lnbih0YXJnZXQsIGFyZ3VtZW50c1tzXSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxufSx7XCJpcy1vYmpcIjo0fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeCkge1xyXG5cdHZhciB0eXBlID0gdHlwZW9mIHg7XHJcblx0cmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xyXG59O1xyXG5cclxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAoZ2xvYmFsKXtcclxuLyoqXHJcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cclxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXHJcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XHJcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XHJcbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xyXG4gKi9cclxuXHJcbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXHJcbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XHJcblxyXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cclxudmFyIE5BTiA9IDAgLyAwO1xyXG5cclxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xyXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XHJcblxyXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xyXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XHJcblxyXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xyXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xyXG5cclxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xyXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcclxuXHJcbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xyXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcclxuXHJcbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXHJcbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcclxuXHJcbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXHJcbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcclxuXHJcbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXHJcbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xyXG5cclxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXHJcbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG5cclxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xyXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcclxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXHJcbiAqIG9mIHZhbHVlcy5cclxuICovXHJcbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xyXG5cclxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xyXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXHJcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcclxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDIuNC4wXHJcbiAqIEBjYXRlZ29yeSBEYXRlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xyXG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XHJcbiAqIH0sIF8ubm93KCkpO1xyXG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxyXG4gKi9cclxudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiByb290LkRhdGUubm93KCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXHJcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xyXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXHJcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxyXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcclxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxyXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XHJcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXHJcbiAqIGludm9jYXRpb24uXHJcbiAqXHJcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcclxuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cclxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxyXG4gKlxyXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcclxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxyXG4gKlxyXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcclxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgMC4xLjBcclxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXHJcbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxyXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cclxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cclxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcclxuICpcclxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXHJcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcclxuICogICAnbGVhZGluZyc6IHRydWUsXHJcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcclxuICogfSkpO1xyXG4gKlxyXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxyXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcclxuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xyXG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XHJcbiAqXHJcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXHJcbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xyXG4gKi9cclxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xyXG4gIHZhciBsYXN0QXJncyxcclxuICAgICAgbGFzdFRoaXMsXHJcbiAgICAgIG1heFdhaXQsXHJcbiAgICAgIHJlc3VsdCxcclxuICAgICAgdGltZXJJZCxcclxuICAgICAgbGFzdENhbGxUaW1lLFxyXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXHJcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcclxuICAgICAgbWF4aW5nID0gZmFsc2UsXHJcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcclxuXHJcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcclxuICB9XHJcbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XHJcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XHJcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XHJcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcclxuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XHJcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XHJcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxyXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcclxuXHJcbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xyXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xyXG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XHJcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxyXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xyXG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cclxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XHJcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cclxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xyXG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcclxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxyXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcclxuXHJcbiAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcclxuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXHJcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcclxuXHJcbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxyXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcclxuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cclxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XHJcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XHJcbiAgICB2YXIgdGltZSA9IG5vdygpO1xyXG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xyXG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xyXG4gICAgfVxyXG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXHJcbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcclxuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxyXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXHJcbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcclxuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XHJcbiAgICB9XHJcbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcclxuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xyXG4gICAgfVxyXG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xyXG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmbHVzaCgpIHtcclxuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xyXG4gICAgdmFyIHRpbWUgPSBub3coKSxcclxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xyXG5cclxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xyXG4gICAgbGFzdFRoaXMgPSB0aGlzO1xyXG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcclxuXHJcbiAgICBpZiAoaXNJbnZva2luZykge1xyXG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG1heGluZykge1xyXG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXHJcbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcclxuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xyXG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xyXG4gIHJldHVybiBkZWJvdW5jZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcclxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxyXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc09iamVjdCh7fSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcclxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXHJcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XHJcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc1N5bWJvbCgnYWJjJyk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcclxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8udG9OdW1iZXIoMy4yKTtcclxuICogLy8gPT4gMy4yXHJcbiAqXHJcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XHJcbiAqIC8vID0+IDVlLTMyNFxyXG4gKlxyXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcclxuICogLy8gPT4gSW5maW5pdHlcclxuICpcclxuICogXy50b051bWJlcignMy4yJyk7XHJcbiAqIC8vID0+IDMuMlxyXG4gKi9cclxuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcclxuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcclxuICAgIHJldHVybiBOQU47XHJcbiAgfVxyXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcclxuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xyXG4gIH1cclxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XHJcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcclxuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcclxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxyXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAoZ2xvYmFsKXtcclxuLyoqXHJcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cclxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXHJcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XHJcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XHJcbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xyXG4gKi9cclxuXHJcbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xyXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcclxuXHJcbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cclxudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xyXG5cclxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY29tcGFyaXNvbiBzdHlsZXMuICovXHJcbnZhciBVTk9SREVSRURfQ09NUEFSRV9GTEFHID0gMSxcclxuICAgIFBBUlRJQUxfQ09NUEFSRV9GTEFHID0gMjtcclxuXHJcbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xyXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XHJcblxyXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXHJcbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXHJcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXHJcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxyXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcclxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcclxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxyXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcclxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxyXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXHJcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcclxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXHJcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcclxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxyXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXHJcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcclxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XHJcblxyXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxyXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxyXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxyXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxyXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxyXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXHJcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcclxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxyXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcclxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXHJcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcclxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXHJcbiAqL1xyXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xyXG5cclxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xyXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcclxuXHJcbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cclxudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcclxuXHJcbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cclxudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XHJcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxyXG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XHJcbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XHJcbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cclxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XHJcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cclxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxyXG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XHJcbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cclxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxyXG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XHJcbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cclxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcclxuXHJcbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXHJcbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcclxuXHJcbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXHJcbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xyXG5cclxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXHJcbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG5cclxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cclxudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xyXG5cclxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xyXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xyXG5cclxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cclxudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XHJcblxyXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cclxudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XHJcblxyXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cclxudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xyXG4gIH0gY2F0Y2ggKGUpIHt9XHJcbn0oKSk7XHJcblxyXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xyXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcclxuXHJcbi8qKlxyXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXHJcbiAqIHNob3J0aGFuZHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcclxuICogIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XHJcbiAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcclxuXHJcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXHJcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcclxuICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XHJcblxyXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xyXG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xyXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xyXG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcclxuICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xyXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXHJcbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xyXG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcclxuICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cclxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xyXG4gIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XHJcblxyXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcclxuICB9KTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xyXG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cclxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xyXG4gIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XHJcblxyXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcclxuICB9KTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXHJcbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxyXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxyXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xyXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xyXG5cclxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cclxudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XHJcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcclxuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XHJcbn0oKSk7XHJcblxyXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXHJcbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XHJcblxyXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cclxudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XHJcblxyXG4vKipcclxuICogVXNlZCB0byByZXNvbHZlIHRoZVxyXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcclxuICogb2YgdmFsdWVzLlxyXG4gKi9cclxudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XHJcblxyXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xyXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xyXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXHJcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXHJcbik7XHJcblxyXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cclxudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxyXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcclxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXHJcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcclxuXHJcbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cclxudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xyXG5cclxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xyXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXHJcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxyXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxyXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcclxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcclxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcclxuXHJcbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXHJcbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXHJcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcclxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXHJcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcclxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XHJcblxyXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cclxudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcclxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcclxuICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcclxuXHJcbiAgdGhpcy5jbGVhcigpO1xyXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcclxuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgY2xlYXJcclxuICogQG1lbWJlck9mIEhhc2hcclxuICovXHJcbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcclxuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgZGVsZXRlXHJcbiAqIEBtZW1iZXJPZiBIYXNoXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XHJcbiAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBnZXRcclxuICogQG1lbWJlck9mIEhhc2hcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXHJcbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XHJcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xyXG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcclxuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XHJcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcclxuICB9XHJcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgaGFzXHJcbiAqIEBtZW1iZXJPZiBIYXNoXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xyXG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcclxuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIHNldFxyXG4gKiBAbWVtYmVyT2YgSGFzaFxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XHJcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xyXG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXHJcbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xyXG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xyXG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xyXG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xyXG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cclxuICovXHJcbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XHJcbiAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XHJcblxyXG4gIHRoaXMuY2xlYXIoKTtcclxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XHJcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGNsZWFyXHJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcclxuICovXHJcbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xyXG4gIHRoaXMuX19kYXRhX18gPSBbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBkZWxldGVcclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xyXG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcclxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcclxuXHJcbiAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xyXG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcclxuICAgIGRhdGEucG9wKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgZ2V0XHJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXHJcbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcclxuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXHJcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XHJcblxyXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgaGFzXHJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcclxuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgc2V0XHJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cclxuICovXHJcbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XHJcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxyXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xyXG5cclxuICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxyXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XHJcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xyXG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcclxuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XHJcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxyXG4gKi9cclxuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xyXG4gIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xyXG5cclxuICB0aGlzLmNsZWFyKCk7XHJcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xyXG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGNsZWFyXHJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxyXG4gKi9cclxuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcclxuICB0aGlzLl9fZGF0YV9fID0ge1xyXG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcclxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxyXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGRlbGV0ZVxyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xyXG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBnZXRcclxuICogQG1lbWJlck9mIE1hcENhY2hlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcclxuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGhhc1xyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xyXG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgc2V0XHJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XHJcbiAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cclxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcclxuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xyXG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XHJcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcclxuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxyXG4gKi9cclxuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XHJcbiAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xyXG5cclxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xyXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBhZGRcclxuICogQG1lbWJlck9mIFNldENhY2hlXHJcbiAqIEBhbGlhcyBwdXNoXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cclxuICovXHJcbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XHJcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgaGFzXHJcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xyXG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XHJcbn1cclxuXHJcbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXHJcblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xyXG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cclxuICovXHJcbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcclxuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBjbGVhclxyXG4gKiBAbWVtYmVyT2YgU3RhY2tcclxuICovXHJcbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XHJcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGRlbGV0ZVxyXG4gKiBAbWVtYmVyT2YgU3RhY2tcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xyXG4gIHJldHVybiB0aGlzLl9fZGF0YV9fWydkZWxldGUnXShrZXkpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbmFtZSBnZXRcclxuICogQG1lbWJlck9mIFN0YWNrXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcclxuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBuYW1lIGhhc1xyXG4gKiBAbWVtYmVyT2YgU3RhY2tcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xyXG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xyXG59XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG5hbWUgc2V0XHJcbiAqIEBtZW1iZXJPZiBTdGFja1xyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cclxuICovXHJcbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcclxuICB2YXIgY2FjaGUgPSB0aGlzLl9fZGF0YV9fO1xyXG4gIGlmIChjYWNoZSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xyXG4gICAgdmFyIHBhaXJzID0gY2FjaGUuX19kYXRhX187XHJcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XHJcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBjYWNoZSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xyXG4gIH1cclxuICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXHJcblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XHJcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcclxuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xyXG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XHJcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcclxuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxyXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxyXG4gIHZhciByZXN1bHQgPSAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKVxyXG4gICAgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpXHJcbiAgICA6IFtdO1xyXG5cclxuICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCxcclxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcclxuXHJcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxyXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAnbGVuZ3RoJyB8fCBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxyXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xyXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xyXG4gICAgICByZXR1cm4gbGVuZ3RoO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XHJcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xyXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cclxuICogQHBhcmFtIHtib29sZWFufSBbYml0bWFza10gVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy5cclxuICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxyXG4gKiAgICAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXHJcbiAqICAgICAyIC0gUGFydGlhbCBjb21wYXJpc29uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xyXG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3QodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XHJcbiAgfVxyXG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiYXNlSXNFcXVhbCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xyXG59XHJcblxyXG4vKipcclxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xyXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXHJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2JpdG1hc2tdIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXHJcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcclxuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXHJcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXHJcbiAgICAgIG9ialRhZyA9IGFycmF5VGFnLFxyXG4gICAgICBvdGhUYWcgPSBhcnJheVRhZztcclxuXHJcbiAgaWYgKCFvYmpJc0Fycikge1xyXG4gICAgb2JqVGFnID0gZ2V0VGFnKG9iamVjdCk7XHJcbiAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcclxuICB9XHJcbiAgaWYgKCFvdGhJc0Fycikge1xyXG4gICAgb3RoVGFnID0gZ2V0VGFnKG90aGVyKTtcclxuICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xyXG4gIH1cclxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob2JqZWN0KSxcclxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob3RoZXIpLFxyXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xyXG5cclxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xyXG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcclxuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXHJcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcclxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XHJcbiAgfVxyXG4gIGlmICghKGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRykpIHtcclxuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXHJcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XHJcblxyXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcclxuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxyXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xyXG5cclxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcclxuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIWlzU2FtZVRhZykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xyXG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcclxuICogIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xyXG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XHJcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcclxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxyXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW29iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XHJcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XHJcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xyXG4gIH1cclxuICB2YXIgcmVzdWx0ID0gW107XHJcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XHJcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcclxuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxyXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cclxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XHJcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRyxcclxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxyXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XHJcblxyXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxyXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcclxuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XHJcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcclxuICB9XHJcbiAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgIHJlc3VsdCA9IHRydWUsXHJcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xyXG5cclxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcclxuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcclxuXHJcbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxyXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XHJcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXHJcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XHJcblxyXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcclxuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXHJcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXHJcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKGNvbXBhcmVkKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cclxuICAgIGlmIChzZWVuKSB7XHJcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhvdGhJbmRleCkgJiZcclxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLmFkZChvdGhJbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoIShcclxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxyXG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcclxuICAgICAgICApKSB7XHJcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcclxuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXHJcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXHJcbiAqXHJcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcclxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxyXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cclxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xyXG4gIHN3aXRjaCAodGFnKSB7XHJcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxyXG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XHJcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcclxuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XHJcblxyXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcclxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxyXG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIGNhc2UgYm9vbFRhZzpcclxuICAgIGNhc2UgZGF0ZVRhZzpcclxuICAgIGNhc2UgbnVtYmVyVGFnOlxyXG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxyXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxyXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcclxuXHJcbiAgICBjYXNlIGVycm9yVGFnOlxyXG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xyXG5cclxuICAgIGNhc2UgcmVnZXhwVGFnOlxyXG4gICAgY2FzZSBzdHJpbmdUYWc6XHJcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXHJcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcclxuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XHJcblxyXG4gICAgY2FzZSBtYXBUYWc6XHJcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcclxuXHJcbiAgICBjYXNlIHNldFRhZzpcclxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRztcclxuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xyXG5cclxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXHJcbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XHJcbiAgICAgIGlmIChzdGFja2VkKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XHJcbiAgICAgIH1cclxuICAgICAgYml0bWFzayB8PSBVTk9SREVSRURfQ09NUEFSRV9GTEFHO1xyXG5cclxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXHJcbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcclxuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xyXG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICBjYXNlIHN5bWJvbFRhZzpcclxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcclxuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcclxuICAgICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxyXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cclxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcclxuICogIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcclxuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHLFxyXG4gICAgICBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcclxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxyXG4gICAgICBvdGhQcm9wcyA9IGtleXMob3RoZXIpLFxyXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XHJcblxyXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xyXG4gIHdoaWxlIChpbmRleC0tKSB7XHJcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xyXG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXHJcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcclxuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XHJcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcclxuICB9XHJcbiAgdmFyIHJlc3VsdCA9IHRydWU7XHJcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xyXG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcclxuXHJcbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xyXG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XHJcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XHJcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcclxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XHJcblxyXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcclxuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXHJcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcclxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcclxuICAgIH1cclxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxyXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSlcclxuICAgICAgICAgIDogY29tcGFyZWRcclxuICAgICAgICApKSB7XHJcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcclxuICB9XHJcbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcclxuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxyXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cclxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcclxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcclxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcclxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XHJcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcclxuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XHJcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XHJcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXHJcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxyXG4gICAgOiBkYXRhLm1hcDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXHJcbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cclxuICovXHJcbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xyXG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcclxuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cclxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cclxuICovXHJcbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xyXG5cclxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEsXHJcbi8vIGZvciBkYXRhIHZpZXdzIGluIEVkZ2UgPCAxNCwgYW5kIHByb21pc2VzIGluIE5vZGUuanMuXHJcbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcclxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcclxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcclxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcclxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcclxuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpLFxyXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAoY3RvclN0cmluZykge1xyXG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcclxuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xyXG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcclxuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcclxuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XHJcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XHJcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xyXG4gIHJldHVybiAhIWxlbmd0aCAmJlxyXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcclxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XHJcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XHJcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcclxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcclxuICAgIDogKHZhbHVlID09PSBudWxsKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cclxuICovXHJcbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcclxuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xyXG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXHJcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xyXG5cclxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cclxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XHJcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xyXG4gICAgfSBjYXRjaCAoZSkge31cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcclxuICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgfVxyXG4gIHJldHVybiAnJztcclxufVxyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIGFcclxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcclxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xyXG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xyXG4gKlxyXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmVxKCdhJywgJ2EnKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmVxKE5hTiwgTmFOKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKi9cclxuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XHJcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxyXG4gKiAgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XHJcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cclxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxyXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXHJcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcclxuICogaXMgYW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXHJcbiAqICBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xyXG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcclxuICogZXF1aXZhbGVudC5cclxuICpcclxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxyXG4gKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXHJcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXHJcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxyXG4gKiBub2RlcyBhcmUgKipub3QqKiBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xyXG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xyXG4gKlxyXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogb2JqZWN0ID09PSBvdGhlcjtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XHJcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNGdW5jdGlvbihfKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xyXG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxyXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cclxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcclxuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXHJcbiAqXHJcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXHJcbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzTGVuZ3RoKDMpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzTGVuZ3RoKCczJyk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcclxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxyXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXHJcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgMC4xLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0KHt9KTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdChfLm5vb3ApO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3QobnVsbCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xyXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xyXG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcclxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc09iamVjdExpa2Uoe30pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc09iamVjdExpa2UobnVsbCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcclxuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDMuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXHJcbiAqXHJcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXHJcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcclxuICogZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAc2luY2UgMC4xLjBcclxuICogQG1lbWJlck9mIF9cclxuICogQGNhdGVnb3J5IE9iamVjdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICogICB0aGlzLmEgPSAxO1xyXG4gKiAgIHRoaXMuYiA9IDI7XHJcbiAqIH1cclxuICpcclxuICogRm9vLnByb3RvdHlwZS5jID0gMztcclxuICpcclxuICogXy5rZXlzKG5ldyBGb28pO1xyXG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXHJcbiAqXHJcbiAqIF8ua2V5cygnaGknKTtcclxuICogLy8gPT4gWycwJywgJzEnXVxyXG4gKi9cclxuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcclxuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG59LHt9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG4vKipcclxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxyXG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcclxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XHJcbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cclxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cclxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXHJcbiAqL1xyXG52YXIgcmVJbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC5fcmVpbnRlcnBvbGF0ZScpLFxyXG4gICAgdGVtcGxhdGVTZXR0aW5ncyA9IHJlcXVpcmUoJ2xvZGFzaC50ZW1wbGF0ZXNldHRpbmdzJyk7XHJcblxyXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cclxudmFyIElORklOSVRZID0gMSAvIDAsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcclxuXHJcbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cclxudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcclxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcclxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxyXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcclxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xyXG5cclxuLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cclxudmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxyXG4gICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxyXG4gICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcclxuXHJcbi8qKlxyXG4gKiBVc2VkIHRvIG1hdGNoXHJcbiAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXHJcbiAqL1xyXG52YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xyXG5cclxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xyXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xyXG5cclxuLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xyXG52YXIgcmVOb01hdGNoID0gLygkXikvO1xyXG5cclxuLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xyXG52YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XHJcblxyXG4vKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cclxudmFyIHN0cmluZ0VzY2FwZXMgPSB7XHJcbiAgJ1xcXFwnOiAnXFxcXCcsXHJcbiAgXCInXCI6IFwiJ1wiLFxyXG4gICdcXG4nOiAnbicsXHJcbiAgJ1xccic6ICdyJyxcclxuICAnXFx1MjAyOCc6ICd1MjAyOCcsXHJcbiAgJ1xcdTIwMjknOiAndTIwMjknXHJcbn07XHJcblxyXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xyXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XHJcblxyXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xyXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcclxuXHJcbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxuXHJcbi8qKlxyXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXHJcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cclxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXHJcbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxyXG4gKi9cclxuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xyXG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcclxuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcclxuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcclxuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcclxuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcclxuICB9XHJcbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcclxuICogc2hvcnRoYW5kcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcclxuICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxyXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xyXG5cclxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcclxuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xyXG4gIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcclxuXHJcbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XHJcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cclxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXHJcbiAqIG9mIGBwcm9wc2AuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcclxuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xyXG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cclxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xyXG4gIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcclxuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XHJcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xyXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcclxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXHJcbiAqIG9mIHZhbHVlcy5cclxuICovXHJcbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xyXG5cclxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXHJcbnZhciBTeW1ib2wgPSByb290LlN5bWJvbCxcclxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XHJcblxyXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXHJcbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcclxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xyXG5cclxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXHJcbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXHJcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cclxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XHJcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cclxuICAvLyBTYWZhcmkgOSBtYWtlcyBgYXJndW1lbnRzLmxlbmd0aGAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cclxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcclxuICAgID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKVxyXG4gICAgOiBbXTtcclxuXHJcbiAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXHJcbiAgICAgIHNraXBJbmRleGVzID0gISFsZW5ndGg7XHJcblxyXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcclxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xyXG4gICAgICByZXN1bHQucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cclxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxyXG4gKi9cclxuZnVuY3Rpb24gYXNzaWduSW5EZWZhdWx0cyhvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XHJcbiAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XHJcbiAgICByZXR1cm4gc3JjVmFsdWU7XHJcbiAgfVxyXG4gIHJldHVybiBvYmpWYWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcclxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcclxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxyXG4gKi9cclxuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XHJcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XHJcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcclxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcclxuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcclxuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcclxuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XHJcbiAgfVxyXG4gIHZhciByZXN1bHQgPSBbXTtcclxuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcclxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICByZXN1bHQucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cclxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XHJcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XHJcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XHJcbiAgfVxyXG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcclxuICAgICAgcmVzdWx0ID0gW107XHJcblxyXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcclxuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xyXG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICBpbmRleCA9IC0xLFxyXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcclxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XHJcblxyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcclxuICAgIH1cclxuICAgIGluZGV4ID0gLTE7XHJcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcclxuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcclxuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IGFycmF5O1xyXG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxyXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cclxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XHJcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cclxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcclxuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XHJcbiAgfVxyXG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XHJcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cclxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cclxuICovXHJcbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XHJcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XHJcblxyXG4gIHZhciBpbmRleCA9IC0xLFxyXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XHJcblxyXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xyXG5cclxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcclxuICAgICAgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgPyBzb3VyY2Vba2V5XSA6IG5ld1ZhbHVlKTtcclxuICB9XHJcbiAgcmV0dXJuIG9iamVjdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XHJcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xyXG4gICAgdmFyIGluZGV4ID0gLTEsXHJcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXHJcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXHJcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxyXG4gICAgICA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XHJcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcclxuICAgICAgbGVuZ3RoID0gMTtcclxuICAgIH1cclxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xyXG4gICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iamVjdDtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XHJcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xyXG4gIHJldHVybiAhIWxlbmd0aCAmJlxyXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcclxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cclxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cclxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXHJcbiAqICBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xyXG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcclxuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xyXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXHJcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXHJcbiAgICAgICkge1xyXG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xyXG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXHJcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xyXG5cclxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXHJcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcclxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xyXG4gIHZhciByZXN1bHQgPSBbXTtcclxuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xyXG4gICAgICByZXN1bHQucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogUGVyZm9ybXMgYVxyXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxyXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XHJcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XHJcbiAqXHJcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uZXEoJ2EnLCAnYScpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uZXEoTmFOLCBOYU4pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqL1xyXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcclxuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXHJcbiAqICBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcclxuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxyXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXHJcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uaXNBcnJheSgnYWJjJyk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcclxuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxyXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxyXG4gKiBpcyBhbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcclxuICogIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XHJcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcclxuICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAzLjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNFcnJvcihFcnJvcik7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XHJcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZXJyb3JUYWcpIHx8XHJcbiAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjEuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzRnVuY3Rpb24oXyk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcclxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXHJcbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XHJcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxyXG4gKlxyXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxyXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc0xlbmd0aCgzKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc0xlbmd0aCgnMycpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXHJcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcclxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxyXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc09iamVjdCh7fSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcclxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXHJcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XHJcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc1N5bWJvbCgnYWJjJyk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcclxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxyXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IExhbmdcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cclxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xyXG4gKiAvLyA9PiAnJ1xyXG4gKlxyXG4gKiBfLnRvU3RyaW5nKC0wKTtcclxuICogLy8gPT4gJy0wJ1xyXG4gKlxyXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+ICcxLDIsMydcclxuICovXHJcbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxyXG4gKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcclxuICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcclxuICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cclxuICpcclxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBhbGlhcyBleHRlbmRXaXRoXHJcbiAqIEBjYXRlZ29yeSBPYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxyXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cclxuICogQHNlZSBfLmFzc2lnbldpdGhcclxuICogQGV4YW1wbGVcclxuICpcclxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcclxuICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xyXG4gKiB9XHJcbiAqXHJcbiAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcclxuICpcclxuICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XHJcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxyXG4gKi9cclxudmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xyXG4gIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcclxufSk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXHJcbiAqXHJcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXHJcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcclxuICogZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAc2luY2UgMC4xLjBcclxuICogQG1lbWJlck9mIF9cclxuICogQGNhdGVnb3J5IE9iamVjdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICogICB0aGlzLmEgPSAxO1xyXG4gKiAgIHRoaXMuYiA9IDI7XHJcbiAqIH1cclxuICpcclxuICogRm9vLnByb3RvdHlwZS5jID0gMztcclxuICpcclxuICogXy5rZXlzKG5ldyBGb28pO1xyXG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXHJcbiAqXHJcbiAqIF8ua2V5cygnaGknKTtcclxuICogLy8gPT4gWycwJywgJzEnXVxyXG4gKi9cclxuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcclxuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxyXG4gKlxyXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyT2YgX1xyXG4gKiBAc2luY2UgMy4wLjBcclxuICogQGNhdGVnb3J5IE9iamVjdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGZ1bmN0aW9uIEZvbygpIHtcclxuICogICB0aGlzLmEgPSAxO1xyXG4gKiAgIHRoaXMuYiA9IDI7XHJcbiAqIH1cclxuICpcclxuICogRm9vLnByb3RvdHlwZS5jID0gMztcclxuICpcclxuICogXy5rZXlzSW4obmV3IEZvbyk7XHJcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxyXG4gKi9cclxuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xyXG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xyXG4gKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxyXG4gKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcclxuICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcclxuICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxyXG4gKlxyXG4gKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xyXG4gKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcclxuICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXHJcbiAqXHJcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXHJcbiAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cclxuICpcclxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXHJcbiAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBjYXRlZ29yeSBTdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXHJcbiAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cclxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cclxuICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cclxuICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXHJcbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXHJcbiAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0ndGVtcGxhdGVTb3VyY2VzW25dJ11cclxuICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXHJcbiAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cclxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxyXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcclxuICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcclxuICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xyXG4gKlxyXG4gKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxyXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XHJcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcclxuICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcclxuICpcclxuICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cclxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcclxuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XHJcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xyXG4gKlxyXG4gKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXHJcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XHJcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcclxuICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXHJcbiAqXHJcbiAqIC8vIFVzZSB0aGUgRVMgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXHJcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcclxuICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcclxuICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xyXG4gKlxyXG4gKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxyXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XHJcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xyXG4gKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xyXG4gKlxyXG4gKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXHJcbiAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XHJcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XHJcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xyXG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcclxuICpcclxuICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cclxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xyXG4gKiBjb21waWxlZChkYXRhKTtcclxuICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cclxuICpcclxuICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cclxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcclxuICogY29tcGlsZWQuc291cmNlO1xyXG4gKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XHJcbiAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XHJcbiAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xyXG4gKiAvLyAgIHJldHVybiBfX3A7XHJcbiAqIC8vIH1cclxuICpcclxuICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxyXG4gKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xyXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xyXG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcclxuICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcclxuICpcclxuICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXHJcbiAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxyXG4gKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxyXG4gKiAgIHZhciBKU1QgPSB7XFxcclxuICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXHJcbiAqICAgfTtcXFxyXG4gKiAnKTtcclxuICovXHJcbmZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcclxuICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXHJcbiAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxyXG4gIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxyXG4gIHZhciBzZXR0aW5ncyA9IHRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0cy5fLnRlbXBsYXRlU2V0dGluZ3MgfHwgdGVtcGxhdGVTZXR0aW5ncztcclxuXHJcbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XHJcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xyXG4gIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBhc3NpZ25JbkRlZmF1bHRzKTtcclxuXHJcbiAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgYXNzaWduSW5EZWZhdWx0cyksXHJcbiAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcclxuICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xyXG5cclxuICB2YXIgaXNFc2NhcGluZyxcclxuICAgICAgaXNFdmFsdWF0aW5nLFxyXG4gICAgICBpbmRleCA9IDAsXHJcbiAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXHJcbiAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcclxuXHJcbiAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxyXG4gIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXHJcbiAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xyXG4gICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcclxuICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcclxuICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xyXG4gICwgJ2cnKTtcclxuXHJcbiAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxyXG4gIHZhciBzb3VyY2VVUkwgPSAnc291cmNlVVJMJyBpbiBvcHRpb25zID8gJy8vIyBzb3VyY2VVUkw9JyArIG9wdGlvbnMuc291cmNlVVJMICsgJ1xcbicgOiAnJztcclxuXHJcbiAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcclxuXHJcbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cclxuICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XHJcblxyXG4gICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXHJcbiAgICBpZiAoZXNjYXBlVmFsdWUpIHtcclxuICAgICAgaXNFc2NhcGluZyA9IHRydWU7XHJcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xyXG4gICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xyXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xyXG4gICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcclxuICAgIH1cclxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xyXG5cclxuICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxyXG4gICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cclxuICAgIHJldHVybiBtYXRjaDtcclxuICB9KTtcclxuXHJcbiAgc291cmNlICs9IFwiJztcXG5cIjtcclxuXHJcbiAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxyXG4gIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cclxuICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlO1xyXG4gIGlmICghdmFyaWFibGUpIHtcclxuICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xyXG4gIH1cclxuICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXHJcbiAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXHJcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxyXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XHJcblxyXG4gIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXHJcbiAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xyXG4gICAgKHZhcmlhYmxlXHJcbiAgICAgID8gJydcclxuICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xyXG4gICAgKSArXHJcbiAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xyXG4gICAgKGlzRXNjYXBpbmdcclxuICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXHJcbiAgICAgICA6ICcnXHJcbiAgICApICtcclxuICAgIChpc0V2YWx1YXRpbmdcclxuICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcclxuICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXHJcbiAgICAgIDogJztcXG4nXHJcbiAgICApICtcclxuICAgIHNvdXJjZSArXHJcbiAgICAncmV0dXJuIF9fcFxcbn0nO1xyXG5cclxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxyXG4gICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcclxuICB9KTtcclxuXHJcbiAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXHJcbiAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cclxuICByZXN1bHQuc291cmNlID0gc291cmNlO1xyXG4gIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcclxuICAgIHRocm93IHJlc3VsdDtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXHJcbiAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDMuMC4wXHJcbiAqIEBjYXRlZ29yeSBVdGlsXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXHJcbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxyXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXHJcbiAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcclxuICogfSwgJz5fPicpO1xyXG4gKlxyXG4gKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xyXG4gKiAgIGVsZW1lbnRzID0gW107XHJcbiAqIH1cclxuICovXHJcbnZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XHJcbiAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxufSx7XCJsb2Rhc2guX3JlaW50ZXJwb2xhdGVcIjo4LFwibG9kYXNoLnRlbXBsYXRlc2V0dGluZ3NcIjo5fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qKlxyXG4gKiBsb2Rhc2ggMy4wLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XHJcbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcclxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cclxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjcuMCA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cclxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xyXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxyXG4gKi9cclxuXHJcbi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXHJcbnZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlSW50ZXJwb2xhdGU7XHJcblxyXG59LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG4vKipcclxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxyXG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcclxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XHJcbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cclxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cclxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXHJcbiAqL1xyXG52YXIgcmVJbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC5fcmVpbnRlcnBvbGF0ZScpO1xyXG5cclxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXHJcbnZhciBJTkZJTklUWSA9IDEgLyAwO1xyXG5cclxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xyXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XHJcblxyXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXHJcbnZhciByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ2BdL2csXHJcbiAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XHJcblxyXG4vKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xyXG52YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcclxuICAgIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nO1xyXG5cclxuLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cclxudmFyIGh0bWxFc2NhcGVzID0ge1xyXG4gICcmJzogJyZhbXA7JyxcclxuICAnPCc6ICcmbHQ7JyxcclxuICAnPic6ICcmZ3Q7JyxcclxuICAnXCInOiAnJnF1b3Q7JyxcclxuICBcIidcIjogJyYjMzk7JyxcclxuICAnYCc6ICcmIzk2OydcclxufTtcclxuXHJcbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXHJcbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcclxuXHJcbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXHJcbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xyXG5cclxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXHJcbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xyXG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcclxuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cclxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXHJcbiAqL1xyXG52YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XHJcblxyXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXHJcbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogVXNlZCB0byByZXNvbHZlIHRoZVxyXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcclxuICogb2YgdmFsdWVzLlxyXG4gKi9cclxudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XHJcblxyXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cclxudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xyXG5cclxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXHJcbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXHJcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XHJcblxyXG4vKipcclxuICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cclxuICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlXHJcbiAqIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbnZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xyXG5cclxuICAvKipcclxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cclxuICAgKlxyXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcclxuICAgKiBAdHlwZSB7UmVnRXhwfVxyXG4gICAqL1xyXG4gICdlc2NhcGUnOiByZUVzY2FwZSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXHJcbiAgICogQHR5cGUge1JlZ0V4cH1cclxuICAgKi9cclxuICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxyXG5cclxuICAvKipcclxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cclxuICAgKlxyXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcclxuICAgKiBAdHlwZSB7UmVnRXhwfVxyXG4gICAqL1xyXG4gICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXHJcblxyXG4gIC8qKlxyXG4gICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cclxuICAgKlxyXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xyXG4gICd2YXJpYWJsZSc6ICcnLFxyXG5cclxuICAvKipcclxuICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICAnaW1wb3J0cyc6IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgJ18nOiB7ICdlc2NhcGUnOiBlc2NhcGUgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcclxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xyXG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xyXG4gIH1cclxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xyXG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxyXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gdHJ1ZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcclxuICogLy8gPT4gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xyXG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XHJcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcclxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlck9mIF9cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBMYW5nXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy50b1N0cmluZyhudWxsKTtcclxuICogLy8gPT4gJydcclxuICpcclxuICogXy50b1N0cmluZygtMCk7XHJcbiAqIC8vID0+ICctMCdcclxuICpcclxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xyXG4gKiAvLyA9PiAnMSwyLDMnXHJcbiAqL1xyXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgXCInXCIsIGFuZCBcIlxcYFwiIGluIGBzdHJpbmdgIHRvXHJcbiAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cclxuICpcclxuICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXHJcbiAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxyXG4gKlxyXG4gKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXHJcbiAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXHJcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcclxuICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxyXG4gKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogQmFja3RpY2tzIGFyZSBlc2NhcGVkIGJlY2F1c2UgaW4gSUUgPCA5LCB0aGV5IGNhbiBicmVhayBvdXQgb2ZcclxuICogYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLiBTZWUgWyM1OV0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzU5KSxcclxuICogWyMxMDJdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDIpLCBbIzEwOF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEwOCksIGFuZFxyXG4gKiBbIzEzM10oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEzMykgb2YgdGhlXHJcbiAqIFtIVE1MNSBTZWN1cml0eSBDaGVhdHNoZWV0XShodHRwczovL2h0bWw1c2VjLm9yZy8pIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcclxuICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcclxuICogWFNTIHZlY3RvcnMuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHNpbmNlIDAuMS4wXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBjYXRlZ29yeSBTdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XHJcbiAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXHJcbiAqL1xyXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XHJcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcclxuICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxyXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxyXG4gICAgOiBzdHJpbmc7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGVTZXR0aW5ncztcclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG59LHtcImxvZGFzaC5fcmVpbnRlcnBvbGF0ZVwiOjh9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBCYXNlZCBvZmYgb2YgW3RoZSBvZmZpY2FsIEdvb2dsZSBkb2N1bWVudF0oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL3V0aWxpdGllcy9wb2x5bGluZWFsZ29yaXRobSlcclxuICpcclxuICogU29tZSBwYXJ0cyBmcm9tIFt0aGlzIGltcGxlbWVudGF0aW9uXShodHRwOi8vZmFjc3RhZmYudW5jYS5lZHUvbWNtY2NsdXIvR29vZ2xlTWFwcy9FbmNvZGVQb2x5bGluZS9Qb2x5bGluZUVuY29kZXIuanMpXHJcbiAqIGJ5IFtNYXJrIE1jQ2x1cmVdKGh0dHA6Ly9mYWNzdGFmZi51bmNhLmVkdS9tY21jY2x1ci8pXHJcbiAqXHJcbiAqIEBtb2R1bGUgcG9seWxpbmVcclxuICovXHJcblxyXG52YXIgcG9seWxpbmUgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGVuY29kZShjb29yZGluYXRlLCBmYWN0b3IpIHtcclxuICAgIGNvb3JkaW5hdGUgPSBNYXRoLnJvdW5kKGNvb3JkaW5hdGUgKiBmYWN0b3IpO1xyXG4gICAgY29vcmRpbmF0ZSA8PD0gMTtcclxuICAgIGlmIChjb29yZGluYXRlIDwgMCkge1xyXG4gICAgICAgIGNvb3JkaW5hdGUgPSB+Y29vcmRpbmF0ZTtcclxuICAgIH1cclxuICAgIHZhciBvdXRwdXQgPSAnJztcclxuICAgIHdoaWxlIChjb29yZGluYXRlID49IDB4MjApIHtcclxuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoMHgyMCB8IChjb29yZGluYXRlICYgMHgxZikpICsgNjMpO1xyXG4gICAgICAgIGNvb3JkaW5hdGUgPj49IDU7XHJcbiAgICB9XHJcbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb29yZGluYXRlICsgNjMpO1xyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlY29kZXMgdG8gYSBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY29vcmRpbmF0ZXMgYXJyYXkuXHJcbiAqXHJcbiAqIFRoaXMgaXMgYWRhcHRlZCBmcm9tIHRoZSBpbXBsZW1lbnRhdGlvbiBpbiBQcm9qZWN0LU9TUk0uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1Byb2plY3QtT1NSTS9vc3JtLWZyb250ZW5kL2Jsb2IvbWFzdGVyL1dlYkNvbnRlbnQvcm91dGluZy9PU1JNLlJvdXRpbmdHZW9tZXRyeS5qc1xyXG4gKi9cclxucG9seWxpbmUuZGVjb2RlID0gZnVuY3Rpb24oc3RyLCBwcmVjaXNpb24pIHtcclxuICAgIHZhciBpbmRleCA9IDAsXHJcbiAgICAgICAgbGF0ID0gMCxcclxuICAgICAgICBsbmcgPSAwLFxyXG4gICAgICAgIGNvb3JkaW5hdGVzID0gW10sXHJcbiAgICAgICAgc2hpZnQgPSAwLFxyXG4gICAgICAgIHJlc3VsdCA9IDAsXHJcbiAgICAgICAgYnl0ZSA9IG51bGwsXHJcbiAgICAgICAgbGF0aXR1ZGVfY2hhbmdlLFxyXG4gICAgICAgIGxvbmdpdHVkZV9jaGFuZ2UsXHJcbiAgICAgICAgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiB8fCA1KTtcclxuXHJcbiAgICAvLyBDb29yZGluYXRlcyBoYXZlIHZhcmlhYmxlIGxlbmd0aCB3aGVuIGVuY29kZWQsIHNvIGp1c3Qga2VlcFxyXG4gICAgLy8gdHJhY2sgb2Ygd2hldGhlciB3ZSd2ZSBoaXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLiBJbiBlYWNoXHJcbiAgICAvLyBsb29wIGl0ZXJhdGlvbiwgYSBzaW5nbGUgY29vcmRpbmF0ZSBpcyBkZWNvZGVkLlxyXG4gICAgd2hpbGUgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAvLyBSZXNldCBzaGlmdCwgcmVzdWx0LCBhbmQgYnl0ZVxyXG4gICAgICAgIGJ5dGUgPSBudWxsO1xyXG4gICAgICAgIHNoaWZ0ID0gMDtcclxuICAgICAgICByZXN1bHQgPSAwO1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGJ5dGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCsrKSAtIDYzO1xyXG4gICAgICAgICAgICByZXN1bHQgfD0gKGJ5dGUgJiAweDFmKSA8PCBzaGlmdDtcclxuICAgICAgICAgICAgc2hpZnQgKz0gNTtcclxuICAgICAgICB9IHdoaWxlIChieXRlID49IDB4MjApO1xyXG5cclxuICAgICAgICBsYXRpdHVkZV9jaGFuZ2UgPSAoKHJlc3VsdCAmIDEpID8gfihyZXN1bHQgPj4gMSkgOiAocmVzdWx0ID4+IDEpKTtcclxuXHJcbiAgICAgICAgc2hpZnQgPSByZXN1bHQgPSAwO1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGJ5dGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCsrKSAtIDYzO1xyXG4gICAgICAgICAgICByZXN1bHQgfD0gKGJ5dGUgJiAweDFmKSA8PCBzaGlmdDtcclxuICAgICAgICAgICAgc2hpZnQgKz0gNTtcclxuICAgICAgICB9IHdoaWxlIChieXRlID49IDB4MjApO1xyXG5cclxuICAgICAgICBsb25naXR1ZGVfY2hhbmdlID0gKChyZXN1bHQgJiAxKSA/IH4ocmVzdWx0ID4+IDEpIDogKHJlc3VsdCA+PiAxKSk7XHJcblxyXG4gICAgICAgIGxhdCArPSBsYXRpdHVkZV9jaGFuZ2U7XHJcbiAgICAgICAgbG5nICs9IGxvbmdpdHVkZV9jaGFuZ2U7XHJcblxyXG4gICAgICAgIGNvb3JkaW5hdGVzLnB1c2goW2xhdCAvIGZhY3RvciwgbG5nIC8gZmFjdG9yXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZXMgdGhlIGdpdmVuIFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSBjb29yZGluYXRlcyBhcnJheS5cclxuICpcclxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPE51bWJlcj4+fSBjb29yZGluYXRlc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG5wb2x5bGluZS5lbmNvZGUgPSBmdW5jdGlvbihjb29yZGluYXRlcywgcHJlY2lzaW9uKSB7XHJcbiAgICBpZiAoIWNvb3JkaW5hdGVzLmxlbmd0aCkgeyByZXR1cm4gJyc7IH1cclxuXHJcbiAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiB8fCA1KSxcclxuICAgICAgICBvdXRwdXQgPSBlbmNvZGUoY29vcmRpbmF0ZXNbMF1bMF0sIGZhY3RvcikgKyBlbmNvZGUoY29vcmRpbmF0ZXNbMF1bMV0sIGZhY3Rvcik7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBhID0gY29vcmRpbmF0ZXNbaV0sIGIgPSBjb29yZGluYXRlc1tpIC0gMV07XHJcbiAgICAgICAgb3V0cHV0ICs9IGVuY29kZShhWzBdIC0gYlswXSwgZmFjdG9yKTtcclxuICAgICAgICBvdXRwdXQgKz0gZW5jb2RlKGFbMV0gLSBiWzFdLCBmYWN0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBmbGlwcGVkKGNvb3Jkcykge1xyXG4gICAgdmFyIGZsaXBwZWQgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZmxpcHBlZC5wdXNoKGNvb3Jkc1tpXS5zbGljZSgpLnJldmVyc2UoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmxpcHBlZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuY29kZXMgYSBHZW9KU09OIExpbmVTdHJpbmcgZmVhdHVyZS9nZW9tZXRyeS5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGdlb2pzb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvblxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxucG9seWxpbmUuZnJvbUdlb0pTT04gPSBmdW5jdGlvbihnZW9qc29uLCBwcmVjaXNpb24pIHtcclxuICAgIGlmIChnZW9qc29uICYmIGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XHJcbiAgICAgICAgZ2VvanNvbiA9IGdlb2pzb24uZ2VvbWV0cnk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWdlb2pzb24gfHwgZ2VvanNvbi50eXBlICE9PSAnTGluZVN0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IG11c3QgYmUgYSBHZW9KU09OIExpbmVTdHJpbmcnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwb2x5bGluZS5lbmNvZGUoZmxpcHBlZChnZW9qc29uLmNvb3JkaW5hdGVzKSwgcHJlY2lzaW9uKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIHRvIGEgR2VvSlNPTiBMaW5lU3RyaW5nIGdlb21ldHJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmVjaXNpb25cclxuICogQHJldHVybnMge09iamVjdH1cclxuICovXHJcbnBvbHlsaW5lLnRvR2VvSlNPTiA9IGZ1bmN0aW9uKHN0ciwgcHJlY2lzaW9uKSB7XHJcbiAgICB2YXIgY29vcmRzID0gcG9seWxpbmUuZGVjb2RlKHN0ciwgcHJlY2lzaW9uKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxyXG4gICAgICAgIGNvb3JkaW5hdGVzOiBmbGlwcGVkKGNvb3JkcylcclxuICAgIH07XHJcbn07XHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gcG9seWxpbmU7XHJcbn1cclxuXHJcbn0se31dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZnVuY3Rpb24gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKGV4dHJhQXJndW1lbnQpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKF9yZWYpIHtcclxuICAgIHZhciBkaXNwYXRjaCA9IF9yZWYuZGlzcGF0Y2g7XHJcbiAgICB2YXIgZ2V0U3RhdGUgPSBfcmVmLmdldFN0YXRlO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHJldHVybiBhY3Rpb24oZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYUFyZ3VtZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciB0aHVuayA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZSgpO1xyXG50aHVuay53aXRoRXh0cmFBcmd1bWVudCA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZTtcclxuXHJcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHRodW5rO1xyXG59LHt9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBhcHBseU1pZGRsZXdhcmU7XHJcblxyXG52YXIgX2NvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKTtcclxuXHJcbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXHJcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcclxuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cclxuICpcclxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxyXG4gKlxyXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcclxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXHJcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cclxuICpcclxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxyXG4gKi9cclxuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xyXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpIHtcclxuICAgICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmUocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBlbmhhbmNlcik7XHJcbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcclxuICAgICAgdmFyIGNoYWluID0gW107XHJcblxyXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcclxuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXHJcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xyXG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaChhY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcclxuICAgICAgICByZXR1cm4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKTtcclxuICAgICAgfSk7XHJcbiAgICAgIF9kaXNwYXRjaCA9IF9jb21wb3NlMltcImRlZmF1bHRcIl0uYXBwbHkodW5kZWZpbmVkLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xyXG5cclxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdG9yZSwge1xyXG4gICAgICAgIGRpc3BhdGNoOiBfZGlzcGF0Y2hcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH07XHJcbn1cclxufSx7XCIuL2NvbXBvc2VcIjoxNX1dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBiaW5kQWN0aW9uQ3JlYXRvcnM7XHJcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvbiBjcmVhdG9ycywgaW50byBhbiBvYmplY3Qgd2l0aCB0aGVcclxuICogc2FtZSBrZXlzLCBidXQgd2l0aCBldmVyeSBmdW5jdGlvbiB3cmFwcGVkIGludG8gYSBgZGlzcGF0Y2hgIGNhbGwgc28gdGhleVxyXG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcclxuICogYHN0b3JlLmRpc3BhdGNoKE15QWN0aW9uQ3JlYXRvcnMuZG9Tb21ldGhpbmcoKSlgIHlvdXJzZWxmIGp1c3QgZmluZS5cclxuICpcclxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXHJcbiAqIGFuZCBnZXQgYSBmdW5jdGlvbiBpbiByZXR1cm4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cclxuICogY3JlYXRvciBmdW5jdGlvbnMuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzYFxyXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwYXRjaCBUaGUgYGRpc3BhdGNoYCBmdW5jdGlvbiBhdmFpbGFibGUgb24geW91ciBSZWR1eFxyXG4gKiBzdG9yZS5cclxuICpcclxuICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gVGhlIG9iamVjdCBtaW1pY2tpbmcgdGhlIG9yaWdpbmFsIG9iamVjdCwgYnV0IHdpdGhcclxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxyXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxyXG4gKiBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcclxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAnICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcclxuICB9XHJcblxyXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xyXG4gIHZhciBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgIHZhciBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcclxuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xyXG59XHJcbn0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb21iaW5lUmVkdWNlcnM7XHJcblxyXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xyXG5cclxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcclxuXHJcbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcclxuXHJcbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4vdXRpbHMvd2FybmluZycpO1xyXG5cclxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbikge1xyXG4gIHZhciBhY3Rpb25UeXBlID0gYWN0aW9uICYmIGFjdGlvbi50eXBlO1xyXG4gIHZhciBhY3Rpb25OYW1lID0gYWN0aW9uVHlwZSAmJiAnXCInICsgYWN0aW9uVHlwZS50b1N0cmluZygpICsgJ1wiJyB8fCAnYW4gYWN0aW9uJztcclxuXHJcbiAgcmV0dXJuICdHaXZlbiBhY3Rpb24gJyArIGFjdGlvbk5hbWUgKyAnLCByZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQuICcgKyAnVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLic7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UoaW5wdXRTdGF0ZSwgcmVkdWNlcnMsIGFjdGlvbikge1xyXG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcclxuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCA/ICdpbml0aWFsU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XHJcblxyXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XHJcbiAgfVxyXG5cclxuICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShpbnB1dFN0YXRlKSkge1xyXG4gICAgcmV0dXJuICdUaGUgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIicgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArICdcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyAnICsgKCdrZXlzOiBcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIicpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHJldHVybiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICB9KTtcclxuXHJcbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcclxuICAgIHJldHVybiAnVW5leHBlY3RlZCAnICsgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDEgPyAna2V5cycgOiAna2V5JykgKyAnICcgKyAoJ1wiJyArIHVuZXhwZWN0ZWRLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiIGZvdW5kIGluICcgKyBhcmd1bWVudE5hbWUgKyAnLiAnKSArICdFeHBlY3RlZCB0byBmaW5kIG9uZSBvZiB0aGUga25vd24gcmVkdWNlciBrZXlzIGluc3RlYWQ6ICcgKyAoJ1wiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiLiBVbmV4cGVjdGVkIGtleXMgd2lsbCBiZSBpZ25vcmVkLicpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNhbml0eShyZWR1Y2Vycykge1xyXG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHZhciByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcclxuICAgIHZhciBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCB9KTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiAnICsgJ0lmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCAnICsgJ2V4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgJyArICdub3QgYmUgdW5kZWZpbmVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0eXBlID0gJ0BAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05fJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xyXG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiB0eXBlIH0pID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuICcgKyAoJ0RvblxcJ3QgdHJ5IHRvIGhhbmRsZSAnICsgX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgKyAnIG9yIG90aGVyIGFjdGlvbnMgaW4gXCJyZWR1eC8qXCIgJykgKyAnbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgJyArICdjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCAnICsgJ2luIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSAnICsgJ2FjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4nKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxyXG4gKiByZWR1Y2VyIGZ1bmN0aW9uLiBJdCB3aWxsIGNhbGwgZXZlcnkgY2hpbGQgcmVkdWNlciwgYW5kIGdhdGhlciB0aGVpciByZXN1bHRzXHJcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxyXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcclxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxyXG4gKiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhcyByZWR1Y2Vyc2Agc3ludGF4LiBUaGUgcmVkdWNlcnMgbWF5IG5ldmVyIHJldHVyblxyXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXHJcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxyXG4gKiB1bnJlY29nbml6ZWQgYWN0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXHJcbiAqIHBhc3NlZCBvYmplY3QsIGFuZCBidWlsZHMgYSBzdGF0ZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xyXG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcclxuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcclxuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBmaW5hbFJlZHVjZXJzW2tleV0gPSByZWR1Y2Vyc1trZXldO1xyXG4gICAgfVxyXG4gIH1cclxuICB2YXIgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpO1xyXG5cclxuICB2YXIgc2FuaXR5RXJyb3I7XHJcbiAgdHJ5IHtcclxuICAgIGFzc2VydFJlZHVjZXJTYW5pdHkoZmluYWxSZWR1Y2Vycyk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgc2FuaXR5RXJyb3IgPSBlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKCkge1xyXG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XHJcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xyXG5cclxuICAgIGlmIChzYW5pdHlFcnJvcikge1xyXG4gICAgICB0aHJvdyBzYW5pdHlFcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24pO1xyXG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcclxuICAgICAgICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkod2FybmluZ01lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIga2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tpXTtcclxuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW2tleV07XHJcbiAgICAgIHZhciBwcmV2aW91c1N0YXRlRm9yS2V5ID0gc3RhdGVba2V5XTtcclxuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcclxuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgICBuZXh0U3RhdGVba2V5XSA9IG5leHRTdGF0ZUZvcktleTtcclxuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBuZXh0U3RhdGUgOiBzdGF0ZTtcclxuICB9O1xyXG59XHJcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxyXG59LHtcIi4vY3JlYXRlU3RvcmVcIjoxNixcIi4vdXRpbHMvd2FybmluZ1wiOjE4LFwiX3Byb2Nlc3NcIjoyLFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIjoyM31dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbXBvc2U7XHJcbi8qKlxyXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxyXG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcclxuICogdGhlIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIG9idGFpbmVkIGJ5IGNvbXBvc2luZyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zXHJcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXHJcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XHJcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuICB9XHJcblxyXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgIHJldHVybiBhcmc7XHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGxhc3QgPSBmdW5jc1tmdW5jcy5sZW5ndGggLSAxXTtcclxuICAgICAgdmFyIHJlc3QgPSBmdW5jcy5zbGljZSgwLCAtMSk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdjogZnVuY3Rpb24gdigpIHtcclxuICAgICAgICAgIHJldHVybiByZXN0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChjb21wb3NlZCwgZikge1xyXG4gICAgICAgICAgICByZXR1cm4gZihjb21wb3NlZCk7XHJcbiAgICAgICAgICB9LCBsYXN0LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSgpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgX3JldCA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcclxuICB9XHJcbn1cclxufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5leHBvcnRzLkFjdGlvblR5cGVzID0gdW5kZWZpbmVkO1xyXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNyZWF0ZVN0b3JlO1xyXG5cclxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcclxuXHJcbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcclxuXHJcbnZhciBfc3ltYm9sT2JzZXJ2YWJsZSA9IHJlcXVpcmUoJ3N5bWJvbC1vYnNlcnZhYmxlJyk7XHJcblxyXG52YXIgX3N5bWJvbE9ic2VydmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sT2JzZXJ2YWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXHJcbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAqIElmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLlxyXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXHJcbiAqL1xyXG52YXIgQWN0aW9uVHlwZXMgPSBleHBvcnRzLkFjdGlvblR5cGVzID0ge1xyXG4gIElOSVQ6ICdAQHJlZHV4L0lOSVQnXHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXHJcbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxyXG4gKlxyXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XHJcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcclxuICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXHJcbiAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2FueX0gW2luaXRpYWxTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XHJcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXHJcbiAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXHJcbiAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcclxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5oYW5jZXIgVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxyXG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXHJcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcclxuICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cclxuICpcclxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcclxuICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBlbmhhbmNlcikge1xyXG4gIHZhciBfcmVmMjtcclxuXHJcbiAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgZW5oYW5jZXIgPSBpbml0aWFsU3RhdGU7XHJcbiAgICBpbml0aWFsU3RhdGUgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgaW5pdGlhbFN0YXRlKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcclxuICB2YXIgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlO1xyXG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XHJcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xyXG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XHJcblxyXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XHJcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xyXG4gICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycy5zbGljZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XHJcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXHJcbiAgICogYW5kIHNvbWUgcGFydCBvZiB0aGUgc3RhdGUgdHJlZSBtYXkgcG90ZW50aWFsbHkgaGF2ZSBjaGFuZ2VkLiBZb3UgbWF5IHRoZW5cclxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cclxuICAgKlxyXG4gICAqIFlvdSBtYXkgY2FsbCBgZGlzcGF0Y2goKWAgZnJvbSBhIGNoYW5nZSBsaXN0ZW5lciwgd2l0aCB0aGUgZm9sbG93aW5nXHJcbiAgICogY2F2ZWF0czpcclxuICAgKlxyXG4gICAqIDEuIFRoZSBzdWJzY3JpcHRpb25zIGFyZSBzbmFwc2hvdHRlZCBqdXN0IGJlZm9yZSBldmVyeSBgZGlzcGF0Y2goKWAgY2FsbC5cclxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcclxuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cclxuICAgKiBIb3dldmVyLCB0aGUgbmV4dCBgZGlzcGF0Y2goKWAgY2FsbCwgd2hldGhlciBuZXN0ZWQgb3Igbm90LCB3aWxsIHVzZSBhIG1vcmVcclxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxyXG4gICAqXHJcbiAgICogMi4gVGhlIGxpc3RlbmVyIHNob3VsZCBub3QgZXhwZWN0IHRvIHNlZSBhbGwgc3RhdGUgY2hhbmdlcywgYXMgdGhlIHN0YXRlXHJcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcclxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xyXG4gICAqIHJlZ2lzdGVyZWQgYmVmb3JlIHRoZSBgZGlzcGF0Y2goKWAgc3RhcnRlZCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBsYXRlc3RcclxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBldmVyeSBkaXNwYXRjaC5cclxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xyXG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XHJcblxyXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xyXG4gICAgbmV4dExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XHJcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcclxuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cclxuICAgKlxyXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcclxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXHJcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xyXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXHJcbiAgICpcclxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xyXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXHJcbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXHJcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxyXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xyXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXHJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcclxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcclxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXHJcbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xyXG4gICAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyW1wiZGVmYXVsdFwiXSkoYWN0aW9uKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XHJcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsaXN0ZW5lcnNbaV0oKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXHJcbiAgICpcclxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXHJcbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxyXG4gICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcclxuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcclxuICAgIH1cclxuXHJcbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xyXG4gICAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW50ZXJvcGVyYWJpbGl0eSBwb2ludCBmb3Igb2JzZXJ2YWJsZS9yZWFjdGl2ZSBsaWJyYXJpZXMuXHJcbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXHJcbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcclxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcclxuICAgIHZhciBfcmVmO1xyXG5cclxuICAgIHZhciBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcclxuICAgIHJldHVybiBfcmVmID0ge1xyXG4gICAgICAvKipcclxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxyXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxyXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cclxuICAgICAgICogQHJldHVybnMge3N1YnNjcmlwdGlvbn0gQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cclxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cclxuICAgICAgICovXHJcblxyXG4gICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xyXG4gICAgICAgICAgaWYgKG9ic2VydmVyLm5leHQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xyXG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlIH07XHJcbiAgICAgIH1cclxuICAgIH0sIF9yZWZbX3N5bWJvbE9ic2VydmFibGUyW1wiZGVmYXVsdFwiXV0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSwgX3JlZjtcclxuICB9XHJcblxyXG4gIC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XHJcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXHJcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cclxuICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XHJcblxyXG4gIHJldHVybiBfcmVmMiA9IHtcclxuICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcclxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxyXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxyXG4gICAgcmVwbGFjZVJlZHVjZXI6IHJlcGxhY2VSZWR1Y2VyXHJcbiAgfSwgX3JlZjJbX3N5bWJvbE9ic2VydmFibGUyW1wiZGVmYXVsdFwiXV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcclxufVxyXG59LHtcImxvZGFzaC9pc1BsYWluT2JqZWN0XCI6MjMsXCJzeW1ib2wtb2JzZXJ2YWJsZVwiOjI0fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5leHBvcnRzLmNvbXBvc2UgPSBleHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IGV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBleHBvcnRzLmNyZWF0ZVN0b3JlID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcclxuXHJcbnZhciBfY3JlYXRlU3RvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlU3RvcmUpO1xyXG5cclxudmFyIF9jb21iaW5lUmVkdWNlcnMgPSByZXF1aXJlKCcuL2NvbWJpbmVSZWR1Y2VycycpO1xyXG5cclxudmFyIF9jb21iaW5lUmVkdWNlcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tYmluZVJlZHVjZXJzKTtcclxuXHJcbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9iaW5kQWN0aW9uQ3JlYXRvcnMnKTtcclxuXHJcbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmRBY3Rpb25DcmVhdG9ycyk7XHJcblxyXG52YXIgX2FwcGx5TWlkZGxld2FyZSA9IHJlcXVpcmUoJy4vYXBwbHlNaWRkbGV3YXJlJyk7XHJcblxyXG52YXIgX2FwcGx5TWlkZGxld2FyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBseU1pZGRsZXdhcmUpO1xyXG5cclxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XHJcblxyXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XHJcblxyXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcclxuXHJcbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxyXG5cclxuLypcclxuKiBUaGlzIGlzIGEgZHVtbXkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGZ1bmN0aW9uIG5hbWUgaGFzIGJlZW4gYWx0ZXJlZCBieSBtaW5pZmljYXRpb24uXHJcbiogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxyXG4qL1xyXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGlzQ3J1c2hlZC5uYW1lID09PSAnc3RyaW5nJyAmJiBpc0NydXNoZWQubmFtZSAhPT0gJ2lzQ3J1c2hlZCcpIHtcclxuICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXFwncHJvZHVjdGlvblxcJy4gJyArICdUaGlzIG1lYW5zIHRoYXQgeW91IGFyZSBydW5uaW5nIGEgc2xvd2VyIGRldmVsb3BtZW50IGJ1aWxkIG9mIFJlZHV4LiAnICsgJ1lvdSBjYW4gdXNlIGxvb3NlLWVudmlmeSAoaHR0cHM6Ly9naXRodWIuY29tL3plcnRvc2gvbG9vc2UtZW52aWZ5KSBmb3IgYnJvd3NlcmlmeSAnICsgJ29yIERlZmluZVBsdWdpbiBmb3Igd2VicGFjayAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMDAzMDAzMSkgJyArICd0byBlbnN1cmUgeW91IGhhdmUgdGhlIGNvcnJlY3QgY29kZSBmb3IgeW91ciBwcm9kdWN0aW9uIGJ1aWxkLicpO1xyXG59XHJcblxyXG5leHBvcnRzLmNyZWF0ZVN0b3JlID0gX2NyZWF0ZVN0b3JlMltcImRlZmF1bHRcIl07XHJcbmV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gX2NvbWJpbmVSZWR1Y2VyczJbXCJkZWZhdWx0XCJdO1xyXG5leHBvcnRzLmJpbmRBY3Rpb25DcmVhdG9ycyA9IF9iaW5kQWN0aW9uQ3JlYXRvcnMyW1wiZGVmYXVsdFwiXTtcclxuZXhwb3J0cy5hcHBseU1pZGRsZXdhcmUgPSBfYXBwbHlNaWRkbGV3YXJlMltcImRlZmF1bHRcIl07XHJcbmV4cG9ydHMuY29tcG9zZSA9IF9jb21wb3NlMltcImRlZmF1bHRcIl07XHJcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxyXG59LHtcIi4vYXBwbHlNaWRkbGV3YXJlXCI6MTIsXCIuL2JpbmRBY3Rpb25DcmVhdG9yc1wiOjEzLFwiLi9jb21iaW5lUmVkdWNlcnNcIjoxNCxcIi4vY29tcG9zZVwiOjE1LFwiLi9jcmVhdGVTdG9yZVwiOjE2LFwiLi91dGlscy93YXJuaW5nXCI6MTgsXCJfcHJvY2Vzc1wiOjJ9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gd2FybmluZztcclxuLyoqXHJcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxyXG4gKiBAcmV0dXJucyB7dm9pZH1cclxuICovXHJcbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xyXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cclxuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xyXG4gIH1cclxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cclxuICB0cnkge1xyXG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXHJcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxyXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xyXG4gIH0gY2F0Y2ggKGUpIHt9XHJcbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xyXG59XHJcbn0se31dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XHJcblxyXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cclxudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XHJcblxyXG59LHtcIi4vX292ZXJBcmdcIjoyMX1dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XHJcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcclxuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxyXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XHJcbiAgICB9IGNhdGNoIChlKSB7fVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGlzSG9zdE9iamVjdDtcclxuXHJcbn0se31dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xyXG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcclxuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcclxuICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XHJcblxyXG59LHt9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcclxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogXy5pc09iamVjdExpa2Uoe30pO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqXHJcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc09iamVjdExpa2UobnVsbCk7XHJcbiAqIC8vID0+IGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcclxuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xyXG5cclxufSx7fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG52YXIgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXHJcbiAgICBpc0hvc3RPYmplY3QgPSByZXF1aXJlKCcuL19pc0hvc3RPYmplY3QnKSxcclxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XHJcblxyXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXHJcbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcclxuXHJcbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cclxudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcclxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cclxudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcclxuXHJcbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xyXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cclxudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xyXG5cclxuLyoqXHJcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcclxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXHJcbiAqIG9mIHZhbHVlcy5cclxuICovXHJcbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcclxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJPZiBfXHJcbiAqIEBzaW5jZSAwLjguMFxyXG4gKiBAY2F0ZWdvcnkgTGFuZ1xyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogZnVuY3Rpb24gRm9vKCkge1xyXG4gKiAgIHRoaXMuYSA9IDE7XHJcbiAqIH1cclxuICpcclxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xyXG4gKiAvLyA9PiBmYWxzZVxyXG4gKlxyXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcclxuICogLy8gPT4gZmFsc2VcclxuICpcclxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XHJcbiAqIC8vID0+IHRydWVcclxuICpcclxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xyXG4gKiAvLyA9PiB0cnVlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8XHJcbiAgICAgIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpICE9IG9iamVjdFRhZyB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XHJcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcclxuICByZXR1cm4gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiZcclxuICAgIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmcpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XHJcblxyXG59LHtcIi4vX2dldFByb3RvdHlwZVwiOjE5LFwiLi9faXNIb3N0T2JqZWN0XCI6MjAsXCIuL2lzT2JqZWN0TGlrZVwiOjIyfV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbi8qIGdsb2JhbCB3aW5kb3cgKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3BvbnlmaWxsJykoZ2xvYmFsIHx8IHdpbmRvdyB8fCB0aGlzKTtcclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG59LHtcIi4vcG9ueWZpbGxcIjoyNX1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xyXG5cdHZhciByZXN1bHQ7XHJcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xyXG5cclxuXHRpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XHJcblx0XHRcdHJlc3VsdCA9IFN5bWJvbC5vYnNlcnZhYmxlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XHJcblx0XHRcdFN5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG59LHt9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBBIHR5cGVhaGVhZCBjb21wb25lbnQgZm9yIGlucHV0c1xyXG4gKiBAY2xhc3MgU3VnZ2VzdGlvbnNcclxuICpcclxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBlbCBBIHZhbGlkIEhUTUwgaW5wdXQgZWxlbWVudFxyXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIEFuIGFycmF5IG9mIGRhdGEgdXNlZCBmb3IgcmVzdWx0c1xyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGltaXQ9NV0gTWF4IG51bWJlciBvZiByZXN1bHRzIHRvIGRpc3BsYXkgaW4gdGhlIGF1dG8gc3VnZ2VzdCBsaXN0LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluTGVuZ3RoPTJdIE51bWJlciBvZiBjaGFyYWN0ZXJzIHR5cGVkIGludG8gYW4gaW5wdXQgdG8gdHJpZ2dlciBzdWdnZXN0aW9ucy5cclxuICogQHJldHVybiB7U3VnZ2VzdGlvbnN9IGB0aGlzYFxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBpbiB0aGUgYnJvd3NlclxyXG4gKiB2YXIgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xyXG4gKiB2YXIgZGF0YSA9IFtcclxuICogICAnUm95IEVsZHJpZGdlJyxcclxuICogICAnUm95IEhhcmdyb3ZlJyxcclxuICogICAnUmV4IFN0ZXdhcnQnXHJcbiAqIF07XHJcbiAqXHJcbiAqIG5ldyBTdWdnZXN0aW9ucyhpbnB1dCwgZGF0YSk7XHJcbiAqXHJcbiAqIC8vIHdpdGggb3B0aW9uc1xyXG4gKiB2YXIgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xyXG4gKiB2YXIgZGF0YSA9IFt7XHJcbiAqICAgbmFtZTogJ1JveSBFbGRyaWRnZScsXHJcbiAqICAgeWVhcjogMTkxMVxyXG4gKiB9LCB7XHJcbiAqICAgbmFtZTogJ1JveSBIYXJncm92ZScsXHJcbiAqICAgeWVhcjogMTk2OVxyXG4gKiB9LCB7XHJcbiAqICAgbmFtZTogJ1JleCBTdGV3YXJ0JyxcclxuICogICB5ZWFyOiAxOTA3XHJcbiAqIH1dO1xyXG4gKlxyXG4gKiB2YXIgdHlwZWFoZWFkID0gbmV3IFN1Z2dlc3Rpb25zKGlucHV0LCBkYXRhLCB7XHJcbiAqICAgZmlsdGVyOiBmYWxzZSwgLy8gRGlzYWJsZSBmaWx0ZXJpbmdcclxuICogICBtaW5MZW5ndGg6IDMsIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIHR5cGVkIGludG8gYW4gaW5wdXQgdG8gdHJpZ2dlciBzdWdnZXN0aW9ucy5cclxuICogICBsaW1pdDogMyAvLyAgTWF4IG51bWJlciBvZiByZXN1bHRzIHRvIGRpc3BsYXkuXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiAvLyBBcyB3ZSdyZSBwYXNzaW5nIGFuIG9iamVjdCBvZiBhbiBhcnJheXMgYXMgZGF0YSwgb3ZlcnJpZGVcclxuICogLy8gYGdldEl0ZW1WYWx1ZWAgYnkgc3BlY2lmeWluZyB0aGUgc3BlY2lmaWMgcHJvcGVydHkgdG8gc2VhcmNoIG9uLlxyXG4gKiB0eXBlYWhlYWQuZ2V0SXRlbVZhbHVlID0gZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS5uYW1lIH07XHJcbiAqXHJcbiAqIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xyXG4gKiAgIGNvbnNvbGUubG9nKHR5cGVhaGVhZC5zZWxlY3RlZCk7IC8vIEN1cnJlbnQgc2VsZWN0ZWQgaXRlbS5cclxuICogfSk7XHJcbiAqXHJcbiAqIC8vIFdpdGggYnJvd3NlcmlmeVxyXG4gKiB2YXIgU3VnZ2VzdGlvbnMgPSByZXF1aXJlKCdzdWdnZXN0aW9ucycpO1xyXG4gKlxyXG4gKiBuZXcgU3VnZ2VzdGlvbnMoaW5wdXQsIGRhdGEpO1xyXG4gKi9cclxudmFyIFN1Z2dlc3Rpb25zID0gcmVxdWlyZSgnLi9zcmMvc3VnZ2VzdGlvbnMnKTtcclxud2luZG93LlN1Z2dlc3Rpb25zID0gbW9kdWxlLmV4cG9ydHMgPSBTdWdnZXN0aW9ucztcclxuXHJcbn0se1wiLi9zcmMvc3VnZ2VzdGlvbnNcIjoyOX1dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLypcclxuICogRnV6enlcclxuICogaHR0cHM6Ly9naXRodWIuY29tL215b3JrL2Z1enp5XHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiBNYXR0IFlvcmtcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4gKi9cclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbnZhciByb290ID0gdGhpcztcclxuXHJcbnZhciBmdXp6eSA9IHt9O1xyXG5cclxuLy8gVXNlIGluIG5vZGUgb3IgaW4gYnJvd3NlclxyXG5pZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdXp6eTtcclxufSBlbHNlIHtcclxuICByb290LmZ1enp5ID0gZnV6enk7XHJcbn1cclxuXHJcbi8vIFJldHVybiBhbGwgZWxlbWVudHMgb2YgYGFycmF5YCB0aGF0IGhhdmUgYSBmdXp6eVxyXG4vLyBtYXRjaCBhZ2FpbnN0IGBwYXR0ZXJuYC5cclxuZnV6enkuc2ltcGxlRmlsdGVyID0gZnVuY3Rpb24ocGF0dGVybiwgYXJyYXkpIHtcclxuICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKHN0cmluZykge1xyXG4gICAgcmV0dXJuIGZ1enp5LnRlc3QocGF0dGVybiwgc3RyaW5nKTtcclxuICB9KTtcclxufTtcclxuXHJcbi8vIERvZXMgYHBhdHRlcm5gIGZ1enp5IG1hdGNoIGBzdHJpbmdgP1xyXG5mdXp6eS50ZXN0ID0gZnVuY3Rpb24ocGF0dGVybiwgc3RyaW5nKSB7XHJcbiAgcmV0dXJuIGZ1enp5Lm1hdGNoKHBhdHRlcm4sIHN0cmluZykgIT09IG51bGw7XHJcbn07XHJcblxyXG4vLyBJZiBgcGF0dGVybmAgbWF0Y2hlcyBgc3RyaW5nYCwgd3JhcCBlYWNoIG1hdGNoaW5nIGNoYXJhY3RlclxyXG4vLyBpbiBgb3B0cy5wcmVgIGFuZCBgb3B0cy5wb3N0YC4gSWYgbm8gbWF0Y2gsIHJldHVybiBudWxsXHJcbmZ1enp5Lm1hdGNoID0gZnVuY3Rpb24ocGF0dGVybiwgc3RyaW5nLCBvcHRzKSB7XHJcbiAgb3B0cyA9IG9wdHMgfHwge307XHJcbiAgdmFyIHBhdHRlcm5JZHggPSAwXHJcbiAgICAsIHJlc3VsdCA9IFtdXHJcbiAgICAsIGxlbiA9IHN0cmluZy5sZW5ndGhcclxuICAgICwgdG90YWxTY29yZSA9IDBcclxuICAgICwgY3VyclNjb3JlID0gMFxyXG4gICAgLy8gcHJlZml4XHJcbiAgICAsIHByZSA9IG9wdHMucHJlIHx8ICcnXHJcbiAgICAvLyBzdWZmaXhcclxuICAgICwgcG9zdCA9IG9wdHMucG9zdCB8fCAnJ1xyXG4gICAgLy8gU3RyaW5nIHRvIGNvbXBhcmUgYWdhaW5zdC4gVGhpcyBtaWdodCBiZSBhIGxvd2VyY2FzZSB2ZXJzaW9uIG9mIHRoZVxyXG4gICAgLy8gcmF3IHN0cmluZ1xyXG4gICAgLCBjb21wYXJlU3RyaW5nID0gIG9wdHMuY2FzZVNlbnNpdGl2ZSAmJiBzdHJpbmcgfHwgc3RyaW5nLnRvTG93ZXJDYXNlKClcclxuICAgICwgY2gsIGNvbXBhcmVDaGFyO1xyXG5cclxuICBwYXR0ZXJuID0gb3B0cy5jYXNlU2Vuc2l0aXZlICYmIHBhdHRlcm4gfHwgcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAvLyBGb3IgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZywgZWl0aGVyIGFkZCBpdCB0byB0aGUgcmVzdWx0XHJcbiAgLy8gb3Igd3JhcCBpbiB0ZW1wbGF0ZSBpZiBpdCdzIHRoZSBuZXh0IHN0cmluZyBpbiB0aGUgcGF0dGVyblxyXG4gIGZvcih2YXIgaWR4ID0gMDsgaWR4IDwgbGVuOyBpZHgrKykge1xyXG4gICAgY2ggPSBzdHJpbmdbaWR4XTtcclxuICAgIGlmKGNvbXBhcmVTdHJpbmdbaWR4XSA9PT0gcGF0dGVybltwYXR0ZXJuSWR4XSkge1xyXG4gICAgICBjaCA9IHByZSArIGNoICsgcG9zdDtcclxuICAgICAgcGF0dGVybklkeCArPSAxO1xyXG5cclxuICAgICAgLy8gY29uc2VjdXRpdmUgY2hhcmFjdGVycyBzaG91bGQgaW5jcmVhc2UgdGhlIHNjb3JlIG1vcmUgdGhhbiBsaW5lYXJseVxyXG4gICAgICBjdXJyU2NvcmUgKz0gMSArIGN1cnJTY29yZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN1cnJTY29yZSA9IDA7XHJcbiAgICB9XHJcbiAgICB0b3RhbFNjb3JlICs9IGN1cnJTY29yZTtcclxuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGNoO1xyXG4gIH1cclxuXHJcbiAgLy8gcmV0dXJuIHJlbmRlcmVkIHN0cmluZyBpZiB3ZSBoYXZlIGEgbWF0Y2ggZm9yIGV2ZXJ5IGNoYXJcclxuICBpZihwYXR0ZXJuSWR4ID09PSBwYXR0ZXJuLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIHtyZW5kZXJlZDogcmVzdWx0LmpvaW4oJycpLCBzY29yZTogdG90YWxTY29yZX07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8vIFRoZSBub3JtYWwgZW50cnkgcG9pbnQuIEZpbHRlcnMgYGFycmAgZm9yIG1hdGNoZXMgYWdhaW5zdCBgcGF0dGVybmAuXHJcbi8vIEl0IHJldHVybnMgYW4gYXJyYXkgd2l0aCBtYXRjaGluZyB2YWx1ZXMgb2YgdGhlIHR5cGU6XHJcbi8vXHJcbi8vICAgICBbe1xyXG4vLyAgICAgICAgIHN0cmluZzogICAnPGI+bGFoJyAvLyBUaGUgcmVuZGVyZWQgc3RyaW5nXHJcbi8vICAgICAgICwgaW5kZXg6ICAgIDIgICAgICAgIC8vIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiBgYXJyYFxyXG4vLyAgICAgICAsIG9yaWdpbmFsOiAnYmxhaCcgICAvLyBUaGUgb3JpZ2luYWwgZWxlbWVudCBpbiBgYXJyYFxyXG4vLyAgICAgfV1cclxuLy9cclxuLy8gYG9wdHNgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IGJhZy4gRGV0YWlsczpcclxuLy9cclxuLy8gICAgb3B0cyA9IHtcclxuLy8gICAgICAgIC8vIHN0cmluZyB0byBwdXQgYmVmb3JlIGEgbWF0Y2hpbmcgY2hhcmFjdGVyXHJcbi8vICAgICAgICBwcmU6ICAgICAnPGI+J1xyXG4vL1xyXG4vLyAgICAgICAgLy8gc3RyaW5nIHRvIHB1dCBhZnRlciBtYXRjaGluZyBjaGFyYWN0ZXJcclxuLy8gICAgICAsIHBvc3Q6ICAgICc8L2I+J1xyXG4vL1xyXG4vLyAgICAgICAgLy8gT3B0aW9uYWwgZnVuY3Rpb24uIElucHV0IGlzIGFuIGVudHJ5IGluIHRoZSBnaXZlbiBhcnJgLFxyXG4vLyAgICAgICAgLy8gb3V0cHV0IHNob3VsZCBiZSB0aGUgc3RyaW5nIHRvIHRlc3QgYHBhdHRlcm5gIGFnYWluc3QuXHJcbi8vICAgICAgICAvLyBJbiB0aGlzIGV4YW1wbGUsIGlmIGBhcnIgPSBbe2NyeWluZzogJ2tvYWxhJ31dYCB3ZSB3b3VsZCByZXR1cm5cclxuLy8gICAgICAgIC8vICdrb2FsYScuXHJcbi8vICAgICAgLCBleHRyYWN0OiBmdW5jdGlvbihhcmcpIHsgcmV0dXJuIGFyZy5jcnlpbmc7IH1cclxuLy8gICAgfVxyXG5mdXp6eS5maWx0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuLCBhcnIsIG9wdHMpIHtcclxuICBvcHRzID0gb3B0cyB8fCB7fTtcclxuICByZXR1cm4gYXJyXHJcbiAgICAucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGVsZW1lbnQsIGlkeCwgYXJyKSB7XHJcbiAgICAgIHZhciBzdHIgPSBlbGVtZW50O1xyXG4gICAgICBpZihvcHRzLmV4dHJhY3QpIHtcclxuICAgICAgICBzdHIgPSBvcHRzLmV4dHJhY3QoZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlbmRlcmVkID0gZnV6enkubWF0Y2gocGF0dGVybiwgc3RyLCBvcHRzKTtcclxuICAgICAgaWYocmVuZGVyZWQgIT0gbnVsbCkge1xyXG4gICAgICAgIHByZXZbcHJldi5sZW5ndGhdID0ge1xyXG4gICAgICAgICAgICBzdHJpbmc6IHJlbmRlcmVkLnJlbmRlcmVkXHJcbiAgICAgICAgICAsIHNjb3JlOiByZW5kZXJlZC5zY29yZVxyXG4gICAgICAgICAgLCBpbmRleDogaWR4XHJcbiAgICAgICAgICAsIG9yaWdpbmFsOiBlbGVtZW50XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcHJldjtcclxuICAgIH0sIFtdKVxyXG5cclxuICAgIC8vIFNvcnQgYnkgc2NvcmUuIEJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQgd3J0IHN0YWJsZS91bnN0YWJsZVxyXG4gICAgLy8gc29ydGluZywgc28gZm9yY2Ugc3RhYmxlIGJ5IHVzaW5nIHRoZSBpbmRleCBpbiB0aGUgY2FzZSBvZiB0aWUuXHJcbiAgICAvLyBTZWUgaHR0cDovL29mYi5uZXQvfnNldGhtbC9pcy1zb3J0LXN0YWJsZS5odG1sXHJcbiAgICAuc29ydChmdW5jdGlvbihhLGIpIHtcclxuICAgICAgdmFyIGNvbXBhcmUgPSBiLnNjb3JlIC0gYS5zY29yZTtcclxuICAgICAgaWYoY29tcGFyZSkgcmV0dXJuIGNvbXBhcmU7XHJcbiAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuXHJcbn0oKSk7XHJcblxyXG5cclxufSx7fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4nVXNlIHN0cmljdCc7XHJcblxyXG52YXIgTGlzdCA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gIHRoaXMuaXRlbXMgPSBbXTtcclxuICB0aGlzLmFjdGl2ZSA9IDA7XHJcbiAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcclxuICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gJ3N1Z2dlc3Rpb25zJztcclxuXHJcbiAgY29tcG9uZW50LmVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZWxlbWVudCwgY29tcG9uZW50LmVsLm5leHRTaWJsaW5nKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkxpc3QucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbn07XHJcblxyXG5MaXN0LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbn07XHJcblxyXG5MaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpdGVtKSB7XHJcbiAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xyXG59O1xyXG5cclxuTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLml0ZW1zID0gW107XHJcbiAgdGhpcy5hY3RpdmUgPSAwO1xyXG59O1xyXG5cclxuTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiAhdGhpcy5pdGVtcy5sZW5ndGg7XHJcbn07XHJcblxyXG5MaXN0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9ICcnO1xyXG5cclxuICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPT09IDApIHtcclxuICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB0aGlzLmRyYXdJdGVtKHRoaXMuaXRlbXNbaV0sIHRoaXMuYWN0aXZlID09PSBpKTtcclxuICB9XHJcblxyXG4gIHRoaXMuc2hvdygpO1xyXG59O1xyXG5cclxuTGlzdC5wcm90b3R5cGUuZHJhd0l0ZW0gPSBmdW5jdGlvbihpdGVtLCBhY3RpdmUpIHtcclxuICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpLFxyXG4gICAgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuXHJcbiAgaWYgKGFjdGl2ZSkgbGkuY2xhc3NOYW1lICs9ICcgYWN0aXZlJztcclxuXHJcbiAgYS5pbm5lckhUTUwgPSBpdGVtLnN0cmluZztcclxuXHJcbiAgbGkuYXBwZW5kQ2hpbGQoYSk7XHJcbiAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxpKTtcclxuXHJcbiAgbGkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmhhbmRsZU1vdXNlRG93bi5jYWxsKHRoaXMsIGl0ZW0pO1xyXG4gIH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5MaXN0LnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbihpdGVtKSB7XHJcbiAgdGhpcy5jb21wb25lbnQudmFsdWUoaXRlbS5vcmlnaW5hbCk7XHJcbiAgdGhpcy5jbGVhcigpO1xyXG4gIHRoaXMuZHJhdygpO1xyXG59O1xyXG5cclxuTGlzdC5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgdGhpcy5hY3RpdmUgPSBpbmRleDtcclxuICB0aGlzLmRyYXcoKTtcclxufTtcclxuXHJcbkxpc3QucHJvdG90eXBlLnByZXZpb3VzID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5tb3ZlKHRoaXMuYWN0aXZlID09PSAwID8gdGhpcy5pdGVtcy5sZW5ndGggLSAxIDogdGhpcy5hY3RpdmUgLSAxKTtcclxufTtcclxuXHJcbkxpc3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLm1vdmUodGhpcy5hY3RpdmUgPT09IHRoaXMuaXRlbXMubGVuZ3RoIC0gMSA/IDAgOiB0aGlzLmFjdGl2ZSArIDEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaXN0O1xyXG5cclxufSx7fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKTtcclxudmFyIGZ1enp5ID0gcmVxdWlyZSgnZnV6enknKTtcclxudmFyIExpc3QgPSByZXF1aXJlKCcuL2xpc3QnKTtcclxuXHJcbnZhciBTdWdnZXN0aW9ucyA9IGZ1bmN0aW9uKGVsLCBkYXRhLCBvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7XHJcbiAgICBtaW5MZW5ndGg6IDIsXHJcbiAgICBsaW1pdDogNSxcclxuICAgIGZpbHRlcjogdHJ1ZVxyXG4gIH0sIG9wdGlvbnMpO1xyXG5cclxuICB0aGlzLmVsID0gZWw7XHJcbiAgdGhpcy5kYXRhID0gZGF0YSB8fCBbXTtcclxuICB0aGlzLmxpc3QgPSBuZXcgTGlzdCh0aGlzKTtcclxuXHJcbiAgdGhpcy5xdWVyeSA9ICcnO1xyXG4gIHRoaXMuc2VsZWN0ZWQgPSBudWxsO1xyXG5cclxuICB0aGlzLmxpc3QuZHJhdygpO1xyXG5cclxuICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24oZSkge1xyXG4gICAgdGhpcy5oYW5kbGVLZXlVcChlLmtleUNvZGUpO1xyXG4gIH0uYmluZCh0aGlzKSwgZmFsc2UpO1xyXG5cclxuICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XHJcbiAgICB0aGlzLmhhbmRsZUtleURvd24oZSk7XHJcbiAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5oYW5kbGVGb2N1cygpO1xyXG4gIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5oYW5kbGVCbHVyKCk7XHJcbiAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5TdWdnZXN0aW9ucy5wcm90b3R5cGUuaGFuZGxlS2V5VXAgPSBmdW5jdGlvbihrZXlDb2RlKSB7XHJcbiAgLy8gNDAgLSBET1dOXHJcbiAgLy8gMzggLSBVUFxyXG4gIC8vIDI3IC0gRVNDXHJcbiAgLy8gMTMgLSBFTlRFUlxyXG4gIC8vIDkgLSBUQUJcclxuXHJcbiAgaWYgKGtleUNvZGUgPT09IDQwIHx8XHJcbiAgICAgIGtleUNvZGUgPT09IDM4IHx8XHJcbiAgICAgIGtleUNvZGUgPT09IDI3IHx8XHJcbiAgICAgIGtleUNvZGUgPT09IDEzIHx8XHJcbiAgICAgIGtleUNvZGUgPT09IDkpIHJldHVybjtcclxuXHJcbiAgdGhpcy5xdWVyeSA9IHRoaXMubm9ybWFsaXplKHRoaXMuZWwudmFsdWUpO1xyXG5cclxuICB0aGlzLmxpc3QuY2xlYXIoKTtcclxuXHJcbiAgaWYgKHRoaXMucXVlcnkubGVuZ3RoIDwgdGhpcy5vcHRpb25zLm1pbkxlbmd0aCkge1xyXG4gICAgdGhpcy5saXN0LmRyYXcoKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHRoaXMuZ2V0Q2FuZGlkYXRlcyhmdW5jdGlvbihkYXRhKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGhpcy5saXN0LmFkZChkYXRhW2ldKTtcclxuICAgICAgaWYgKGkgPT09ICh0aGlzLm9wdGlvbnMubGltaXQgLSAxKSkgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB0aGlzLmxpc3QuZHJhdygpO1xyXG4gIH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5TdWdnZXN0aW9ucy5wcm90b3R5cGUuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uKGUpIHtcclxuICBzd2l0Y2ggKGUua2V5Q29kZSkge1xyXG4gICAgY2FzZSAxMzogLy8gRU5URVJcclxuICAgIGNhc2UgOTogIC8vIFRBQlxyXG4gICAgICBpZiAoIXRoaXMubGlzdC5pc0VtcHR5KCkpIHtcclxuICAgICAgICB0aGlzLnZhbHVlKHRoaXMubGlzdC5pdGVtc1t0aGlzLmxpc3QuYWN0aXZlXS5vcmlnaW5hbCk7XHJcbiAgICAgICAgdGhpcy5saXN0LmhpZGUoKTtcclxuICAgICAgfVxyXG4gICAgYnJlYWs7XHJcbiAgICBjYXNlIDI3OiAvLyBFU0NcclxuICAgICAgaWYgKCF0aGlzLmxpc3QuaXNFbXB0eSgpKSB0aGlzLmxpc3QuaGlkZSgpO1xyXG4gICAgYnJlYWs7XHJcbiAgICBjYXNlIDM4OiAvLyBVUFxyXG4gICAgICB0aGlzLmxpc3QucHJldmlvdXMoKTtcclxuICAgIGJyZWFrO1xyXG4gICAgY2FzZSA0MDogLy8gRE9XTlxyXG4gICAgICB0aGlzLmxpc3QubmV4dCgpO1xyXG4gICAgYnJlYWs7XHJcbiAgfVxyXG59O1xyXG5cclxuU3VnZ2VzdGlvbnMucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLmxpc3QuaGlkZSgpO1xyXG59O1xyXG5cclxuU3VnZ2VzdGlvbnMucHJvdG90eXBlLmhhbmRsZUZvY3VzID0gZnVuY3Rpb24oKSB7XHJcbiAgaWYgKCF0aGlzLmxpc3QuaXNFbXB0eSgpKSB0aGlzLmxpc3Quc2hvdygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBkYXRhIHByZXZpb3VzbHkgcGFzc2VkXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHJldmlzZWREYXRhXHJcbiAqL1xyXG5TdWdnZXN0aW9ucy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ocmV2aXNlZERhdGEpIHtcclxuICB0aGlzLmRhdGEgPSByZXZpc2VkRGF0YTtcclxuICB0aGlzLmxpc3QuZHJhdygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsZWFycyBkYXRhXHJcbiAqL1xyXG5TdWdnZXN0aW9ucy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLmRhdGEgPSBbXTtcclxuICB0aGlzLmxpc3QuY2xlYXIoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgdGhlIHJlc3VsdHMgbGlzdCBhbmQgaW5wdXQgdmFsdWUgZm9yIG1hdGNoaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqL1xyXG5TdWdnZXN0aW9ucy5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XHJcbiAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV2YWx1YXRlcyB3aGV0aGVyIGFuIGFycmF5IGl0ZW0gcXVhbGlmaWVzIGFzIGEgbWF0Y2ggd2l0aCB0aGUgY3VycmVudCBxdWVyeVxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gY2FuZGlkYXRlIGEgcG9zc2libGUgaXRlbSBmcm9tIHRoZSBhcnJheSBwYXNzZWRcclxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IHRoZSBjdXJyZW50IHF1ZXJ5XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5TdWdnZXN0aW9ucy5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihjYW5kaWRhdGUsIHF1ZXJ5KSB7XHJcbiAgcmV0dXJuIGNhbmRpZGF0ZS5pbmRleE9mKHF1ZXJ5KSA+IC0xO1xyXG59O1xyXG5cclxuU3VnZ2VzdGlvbnMucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICB0aGlzLnNlbGVjdGVkID0gdmFsdWU7XHJcbiAgdGhpcy5lbC52YWx1ZSA9IHRoaXMuZ2V0SXRlbVZhbHVlKHZhbHVlKTtcclxuXHJcbiAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XHJcbiAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XHJcbiAgICBlLmluaXRFdmVudCgnY2hhbmdlJywgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgdGhpcy5lbC5kaXNwYXRjaEV2ZW50KGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmVsLmZpcmVFdmVudCgnb25jaGFuZ2UnKTtcclxuICB9XHJcbn07XHJcblxyXG5TdWdnZXN0aW9ucy5wcm90b3R5cGUuZ2V0Q2FuZGlkYXRlcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICBwcmU6ICc8c3Ryb25nPicsXHJcbiAgICBwb3N0OiAnPC9zdHJvbmc+JyxcclxuICAgIGV4dHJhY3Q6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHRoaXMuZ2V0SXRlbVZhbHVlKGQpOyB9LmJpbmQodGhpcylcclxuICB9O1xyXG5cclxuICB2YXIgcmVzdWx0cyA9IHRoaXMub3B0aW9ucy5maWx0ZXIgP1xyXG4gICAgZnV6enkuZmlsdGVyKHRoaXMucXVlcnksIHRoaXMuZGF0YSwgb3B0aW9ucykgOlxyXG4gICAgdGhpcy5kYXRhLm1hcChmdW5jdGlvbihkKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgb3JpZ2luYWw6IGQsXHJcbiAgICAgICAgc3RyaW5nOiB0aGlzLmdldEl0ZW1WYWx1ZShkKS5yZXBsYWNlKG5ldyBSZWdFeHAoJygnICsgdGhpcy5xdWVyeSArICcpJywgJ2lnJyksIGZ1bmN0aW9uKCQxLCBtYXRjaCkge1xyXG4gICAgICAgICAgcmV0dXJuICc8c3Ryb25nPicgKyBtYXRjaCArICc8L3N0cm9uZz4nO1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH07XHJcbiAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICBjYWxsYmFjayhyZXN1bHRzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGb3IgYSBnaXZlbiBpdGVtIGluIHRoZSBkYXRhIGFycmF5LCByZXR1cm4gd2hhdCBzaG91bGQgYmUgdXNlZCBhcyB0aGUgY2FuZGlkYXRlIHN0cmluZ1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGl0ZW0gYW4gaXRlbSBmcm9tIHRoZSBkYXRhIGFycmF5XHJcbiAqIEByZXR1cm4ge1N0cmluZ30gaXRlbVxyXG4gKi9cclxuU3VnZ2VzdGlvbnMucHJvdG90eXBlLmdldEl0ZW1WYWx1ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcclxuICByZXR1cm4gaXRlbTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3VnZ2VzdGlvbnM7XHJcblxyXG59LHtcIi4vbGlzdFwiOjI4LFwiZnV6enlcIjoyNyxcInh0ZW5kXCI6MzJ9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBlYWNoID0gcmVxdWlyZSgndHVyZi1tZXRhJykuY29vcmRFYWNoO1xyXG5cclxuLyoqXHJcbiAqIFRha2VzIGFueSB7QGxpbmsgR2VvSlNPTn0gb2JqZWN0LCBjYWxjdWxhdGVzIHRoZSBleHRlbnQgb2YgYWxsIGlucHV0IGZlYXR1cmVzLCBhbmQgcmV0dXJucyBhIGJvdW5kaW5nIGJveC5cclxuICpcclxuICogQG1vZHVsZSB0dXJmL2V4dGVudFxyXG4gKiBAY2F0ZWdvcnkgbWVhc3VyZW1lbnRcclxuICogQHBhcmFtIHtHZW9KU09OfSBpbnB1dCBhbnkgdmFsaWQgR2VvSlNPTiBPYmplY3RcclxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gdGhlIGJvdW5kaW5nIGJveCBvZiBgaW5wdXRgIGdpdmVuXHJcbiAqIGFzIGFuIGFycmF5IGluIFdTRU4gb3JkZXIgKHdlc3QsIHNvdXRoLCBlYXN0LCBub3J0aClcclxuICogQGV4YW1wbGVcclxuICogdmFyIGlucHV0ID0ge1xyXG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXHJcbiAqICAgXCJmZWF0dXJlc1wiOiBbXHJcbiAqICAgICB7XHJcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcclxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxyXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcclxuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxyXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzExNC4xNzUzMjksIDIyLjI1MjRdXHJcbiAqICAgICAgIH1cclxuICogICAgIH0sIHtcclxuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxyXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXHJcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xyXG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXHJcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTE0LjE3MDAwNywgMjIuMjY3OTY5XVxyXG4gKiAgICAgICB9XHJcbiAqICAgICB9LCB7XHJcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcclxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxyXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcclxuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxyXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzExNC4yMDA2NDksIDIyLjI3NDY0MV1cclxuICogICAgICAgfVxyXG4gKiAgICAgfSwge1xyXG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXHJcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcclxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XHJcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcclxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMTQuMTg2NzQ0LCAyMi4yNjU3NDVdXHJcbiAqICAgICAgIH1cclxuICogICAgIH1cclxuICogICBdXHJcbiAqIH07XHJcbiAqXHJcbiAqIHZhciBiYm94ID0gdHVyZi5leHRlbnQoaW5wdXQpO1xyXG4gKlxyXG4gKiB2YXIgYmJveFBvbHlnb24gPSB0dXJmLmJib3hQb2x5Z29uKGJib3gpO1xyXG4gKlxyXG4gKiB2YXIgcmVzdWx0RmVhdHVyZXMgPSBpbnB1dC5mZWF0dXJlcy5jb25jYXQoYmJveFBvbHlnb24pO1xyXG4gKiB2YXIgcmVzdWx0ID0ge1xyXG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXHJcbiAqICAgXCJmZWF0dXJlc1wiOiByZXN1bHRGZWF0dXJlc1xyXG4gKiB9O1xyXG4gKlxyXG4gKiAvLz1yZXN1bHRcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGF5ZXIpIHtcclxuICAgIHZhciBleHRlbnQgPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XHJcbiAgICBlYWNoKGxheWVyLCBmdW5jdGlvbihjb29yZCkge1xyXG4gICAgICBpZiAoZXh0ZW50WzBdID4gY29vcmRbMF0pIGV4dGVudFswXSA9IGNvb3JkWzBdO1xyXG4gICAgICBpZiAoZXh0ZW50WzFdID4gY29vcmRbMV0pIGV4dGVudFsxXSA9IGNvb3JkWzFdO1xyXG4gICAgICBpZiAoZXh0ZW50WzJdIDwgY29vcmRbMF0pIGV4dGVudFsyXSA9IGNvb3JkWzBdO1xyXG4gICAgICBpZiAoZXh0ZW50WzNdIDwgY29vcmRbMV0pIGV4dGVudFszXSA9IGNvb3JkWzFdO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZXh0ZW50O1xyXG59O1xyXG5cclxufSx7XCJ0dXJmLW1ldGFcIjozMX1dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLyoqXHJcbiAqIExhemlseSBpdGVyYXRlIG92ZXIgY29vcmRpbmF0ZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvXHJcbiAqIEFycmF5LmZvckVhY2guXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAodmFsdWUpXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGV4Y2x1ZGVXcmFwQ29vcmQgd2hldGhlciBvciBub3QgdG8gaW5jbHVkZVxyXG4gKiB0aGUgZmluYWwgY29vcmRpbmF0ZSBvZiBMaW5lYXJSaW5ncyB0aGF0IHdyYXBzIHRoZSByaW5nIGluIGl0cyBpdGVyYXRpb24uXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBwb2ludCA9IHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFswLCAwXSB9O1xyXG4gKiBjb29yZEVhY2gocG9pbnQsIGZ1bmN0aW9uKGNvb3Jkcykge1xyXG4gKiAgIC8vIGNvb3JkcyBpcyBlcXVhbCB0byBbMCwgMF1cclxuICogfSk7XHJcbiAqL1xyXG5mdW5jdGlvbiBjb29yZEVhY2gobGF5ZXIsIGNhbGxiYWNrLCBleGNsdWRlV3JhcENvb3JkKSB7XHJcbiAgdmFyIGksIGosIGssIGcsIGdlb21ldHJ5LCBzdG9wRywgY29vcmRzLFxyXG4gICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24sXHJcbiAgICB3cmFwU2hyaW5rID0gMCxcclxuICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uLFxyXG4gICAgaXNGZWF0dXJlQ29sbGVjdGlvbiA9IGxheWVyLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcbiAgICBpc0ZlYXR1cmUgPSBsYXllci50eXBlID09PSAnRmVhdHVyZScsXHJcbiAgICBzdG9wID0gaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGxheWVyLmZlYXR1cmVzLmxlbmd0aCA6IDE7XHJcblxyXG4gIC8vIFRoaXMgbG9naWMgbWF5IGxvb2sgYSBsaXR0bGUgd2VpcmQuIFRoZSByZWFzb24gd2h5IGl0IGlzIHRoYXQgd2F5XHJcbiAgLy8gaXMgYmVjYXVzZSBpdCdzIHRyeWluZyB0byBiZSBmYXN0LiBHZW9KU09OIHN1cHBvcnRzIG11bHRpcGxlIGtpbmRzXHJcbiAgLy8gb2Ygb2JqZWN0cyBhdCBpdHMgcm9vdDogRmVhdHVyZUNvbGxlY3Rpb24sIEZlYXR1cmVzLCBHZW9tZXRyaWVzLlxyXG4gIC8vIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSByZXNwb25zaWJpbGl0eSBvZiBoYW5kbGluZyBhbGwgb2YgdGhlbSwgYW5kIHRoYXRcclxuICAvLyBtZWFucyB0aGF0IHNvbWUgb2YgdGhlIGBmb3JgIGxvb3BzIHlvdSBzZWUgYmVsb3cgYWN0dWFsbHkganVzdCBkb24ndCBhcHBseVxyXG4gIC8vIHRvIGNlcnRhaW4gaW5wdXRzLiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBnaXZlIHRoaXMganVzdCBhXHJcbiAgLy8gUG9pbnQgZ2VvbWV0cnksIHRoZW4gYm90aCBsb29wcyBhcmUgc2hvcnQtY2lyY3VpdGVkIGFuZCBhbGwgd2UgZG9cclxuICAvLyBpcyBncmFkdWFsbHkgcmVuYW1lIHRoZSBpbnB1dCB1bnRpbCBpdCdzIGNhbGxlZCAnZ2VvbWV0cnknLlxyXG4gIC8vXHJcbiAgLy8gVGhpcyBhbHNvIGFpbXMgdG8gYWxsb2NhdGUgYXMgZmV3IHJlc291cmNlcyBhcyBwb3NzaWJsZToganVzdCBhXHJcbiAgLy8gZmV3IG51bWJlcnMgYW5kIGJvb2xlYW5zLCByYXRoZXIgdGhhbiBhbnkgdGVtcG9yYXJ5IGFycmF5cyBhcyB3b3VsZFxyXG4gIC8vIGJlIHJlcXVpcmVkIHdpdGggdGhlIG5vcm1hbGl6YXRpb24gYXBwcm9hY2guXHJcbiAgZm9yIChpID0gMDsgaSA8IHN0b3A7IGkrKykge1xyXG5cclxuICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uID0gKGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBsYXllci5mZWF0dXJlc1tpXS5nZW9tZXRyeSA6XHJcbiAgICAgICAgKGlzRmVhdHVyZSA/IGxheWVyLmdlb21ldHJ5IDogbGF5ZXIpKTtcclxuICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24udHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbic7XHJcbiAgICBzdG9wRyA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5sZW5ndGggOiAxO1xyXG5cclxuICAgIGZvciAoZyA9IDA7IGcgPCBzdG9wRzsgZysrKSB7XHJcblxyXG4gICAgICBnZW9tZXRyeSA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uID9cclxuICAgICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXNbZ10gOiBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbjtcclxuICAgICAgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XHJcblxyXG4gICAgICB3cmFwU2hyaW5rID0gKGV4Y2x1ZGVXcmFwQ29vcmQgJiZcclxuICAgICAgICAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSkgP1xyXG4gICAgICAgIDEgOiAwO1xyXG5cclxuICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2ludCcpIHtcclxuICAgICAgICBjYWxsYmFjayhjb29yZHMpO1xyXG4gICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyB8fCBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSBjYWxsYmFjayhjb29yZHNbal0pO1xyXG4gICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyB8fCBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykge1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29vcmRzW2pdLmxlbmd0aCAtIHdyYXBTaHJpbms7IGsrKylcclxuICAgICAgICAgICAgY2FsbGJhY2soY29vcmRzW2pdW2tdKTtcclxuICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29vcmRzW2pdLmxlbmd0aDsgaysrKVxyXG4gICAgICAgICAgICBmb3IgKGwgPSAwOyBsIDwgY29vcmRzW2pdW2tdLmxlbmd0aCAtIHdyYXBTaHJpbms7IGwrKylcclxuICAgICAgICAgICAgICBjYWxsYmFjayhjb29yZHNbal1ba11bbF0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBHZW9tZXRyeSBUeXBlJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMuY29vcmRFYWNoID0gY29vcmRFYWNoO1xyXG5cclxuLyoqXHJcbiAqIExhemlseSByZWR1Y2UgY29vcmRpbmF0ZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0IGludG8gYSBzaW5nbGUgdmFsdWUsXHJcbiAqIHNpbWlsYXIgdG8gaG93IEFycmF5LnJlZHVjZSB3b3Jrcy4gSG93ZXZlciwgaW4gdGhpcyBjYXNlIHdlIGxhemlseSBydW5cclxuICogdGhlIHJlZHVjdGlvbiwgc28gYW4gYXJyYXkgb2YgYWxsIGNvb3JkaW5hdGVzIGlzIHVubmVjZXNzYXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKG1lbW8sIHZhbHVlKSBhbmQgcmV0dXJuc1xyXG4gKiBhIG5ldyBtZW1vXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGV4Y2x1ZGVXcmFwQ29vcmQgd2hldGhlciBvciBub3QgdG8gaW5jbHVkZVxyXG4gKiB0aGUgZmluYWwgY29vcmRpbmF0ZSBvZiBMaW5lYXJSaW5ncyB0aGF0IHdyYXBzIHRoZSByaW5nIGluIGl0cyBpdGVyYXRpb24uXHJcbiAqIEBwYXJhbSB7Kn0gbWVtbyB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgbWVtbzogY2FuIGJlIGFueSB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29vcmRSZWR1Y2UobGF5ZXIsIGNhbGxiYWNrLCBtZW1vLCBleGNsdWRlV3JhcENvb3JkKSB7XHJcbiAgY29vcmRFYWNoKGxheWVyLCBmdW5jdGlvbihjb29yZCkge1xyXG4gICAgbWVtbyA9IGNhbGxiYWNrKG1lbW8sIGNvb3JkKTtcclxuICB9LCBleGNsdWRlV3JhcENvb3JkKTtcclxuICByZXR1cm4gbWVtbztcclxufVxyXG5tb2R1bGUuZXhwb3J0cy5jb29yZFJlZHVjZSA9IGNvb3JkUmVkdWNlO1xyXG5cclxuLyoqXHJcbiAqIExhemlseSBpdGVyYXRlIG92ZXIgcHJvcGVydHkgb2JqZWN0cyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG9cclxuICogQXJyYXkuZm9yRWFjaC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGFueSBHZW9KU09OIG9iamVjdFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzICh2YWx1ZSlcclxuICogQGV4YW1wbGVcclxuICogdmFyIHBvaW50ID0geyB0eXBlOiAnRmVhdHVyZScsIGdlb21ldHJ5OiBudWxsLCBwcm9wZXJ0aWVzOiB7IGZvbzogMSB9IH07XHJcbiAqIHByb3BFYWNoKHBvaW50LCBmdW5jdGlvbihwcm9wcykge1xyXG4gKiAgIC8vIHByb3BzIGlzIGVxdWFsIHRvIHsgZm9vOiAxfVxyXG4gKiB9KTtcclxuICovXHJcbmZ1bmN0aW9uIHByb3BFYWNoKGxheWVyLCBjYWxsYmFjaykge1xyXG4gIHZhciBpO1xyXG4gIHN3aXRjaCAobGF5ZXIudHlwZSkge1xyXG4gICAgICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XHJcbiAgICAgICAgZmVhdHVyZXMgPSBsYXllci5mZWF0dXJlcztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXIuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sobGF5ZXIuZmVhdHVyZXNbaV0ucHJvcGVydGllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdGZWF0dXJlJzpcclxuICAgICAgICBjYWxsYmFjayhsYXllci5wcm9wZXJ0aWVzKTtcclxuICAgICAgICBicmVhaztcclxuICB9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMucHJvcEVhY2ggPSBwcm9wRWFjaDtcclxuXHJcbi8qKlxyXG4gKiBMYXppbHkgcmVkdWNlIHByb3BlcnRpZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0IGludG8gYSBzaW5nbGUgdmFsdWUsXHJcbiAqIHNpbWlsYXIgdG8gaG93IEFycmF5LnJlZHVjZSB3b3Jrcy4gSG93ZXZlciwgaW4gdGhpcyBjYXNlIHdlIGxhemlseSBydW5cclxuICogdGhlIHJlZHVjdGlvbiwgc28gYW4gYXJyYXkgb2YgYWxsIHByb3BlcnRpZXMgaXMgdW5uZWNlc3NhcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAobWVtbywgY29vcmQpIGFuZCByZXR1cm5zXHJcbiAqIGEgbmV3IG1lbW9cclxuICogQHBhcmFtIHsqfSBtZW1vIHRoZSBzdGFydGluZyB2YWx1ZSBvZiBtZW1vOiBjYW4gYmUgYW55IHR5cGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBwcm9wUmVkdWNlKGxheWVyLCBjYWxsYmFjaywgbWVtbykge1xyXG4gIHByb3BFYWNoKGxheWVyLCBmdW5jdGlvbihwcm9wKSB7XHJcbiAgICBtZW1vID0gY2FsbGJhY2sobWVtbywgcHJvcCk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG1lbW87XHJcbn1cclxubW9kdWxlLmV4cG9ydHMucHJvcFJlZHVjZSA9IHByb3BSZWR1Y2U7XHJcblxyXG59LHt9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXHJcblxyXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuZnVuY3Rpb24gZXh0ZW5kKCkge1xyXG4gICAgdmFyIHRhcmdldCA9IHt9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXHJcblxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldFxyXG59XHJcblxyXG59LHt9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLnF1ZXJ5T3JpZ2luID0gcXVlcnlPcmlnaW47XHJcbmV4cG9ydHMucXVlcnlEZXN0aW5hdGlvbiA9IHF1ZXJ5RGVzdGluYXRpb247XHJcbmV4cG9ydHMucXVlcnlPcmlnaW5Db29yZGluYXRlcyA9IHF1ZXJ5T3JpZ2luQ29vcmRpbmF0ZXM7XHJcbmV4cG9ydHMucXVlcnlEZXN0aW5hdGlvbkNvb3JkaW5hdGVzID0gcXVlcnlEZXN0aW5hdGlvbkNvb3JkaW5hdGVzO1xyXG5leHBvcnRzLmNsZWFyT3JpZ2luID0gY2xlYXJPcmlnaW47XHJcbmV4cG9ydHMuY2xlYXJEZXN0aW5hdGlvbiA9IGNsZWFyRGVzdGluYXRpb247XHJcbmV4cG9ydHMuc2V0T3B0aW9ucyA9IHNldE9wdGlvbnM7XHJcbmV4cG9ydHMuaG92ZXJNYXJrZXIgPSBob3Zlck1hcmtlcjtcclxuZXhwb3J0cy5zZXRSb3V0ZUluZGV4ID0gc2V0Um91dGVJbmRleDtcclxuZXhwb3J0cy5jcmVhdGVPcmlnaW4gPSBjcmVhdGVPcmlnaW47XHJcbmV4cG9ydHMuY3JlYXRlRGVzdGluYXRpb24gPSBjcmVhdGVEZXN0aW5hdGlvbjtcclxuZXhwb3J0cy5zZXRQcm9maWxlID0gc2V0UHJvZmlsZTtcclxuZXhwb3J0cy5yZXZlcnNlID0gcmV2ZXJzZTtcclxuZXhwb3J0cy5zZXRPcmlnaW5Gcm9tQ29vcmRpbmF0ZXMgPSBzZXRPcmlnaW5Gcm9tQ29vcmRpbmF0ZXM7XHJcbmV4cG9ydHMuc2V0RGVzdGluYXRpb25Gcm9tQ29vcmRpbmF0ZXMgPSBzZXREZXN0aW5hdGlvbkZyb21Db29yZGluYXRlcztcclxuZXhwb3J0cy5hZGRXYXlwb2ludCA9IGFkZFdheXBvaW50O1xyXG5leHBvcnRzLnNldFdheXBvaW50ID0gc2V0V2F5cG9pbnQ7XHJcbmV4cG9ydHMucmVtb3ZlV2F5cG9pbnQgPSByZW1vdmVXYXlwb2ludDtcclxuZXhwb3J0cy5ldmVudFN1YnNjcmliZSA9IGV2ZW50U3Vic2NyaWJlO1xyXG5leHBvcnRzLmV2ZW50RW1pdCA9IGV2ZW50RW1pdDtcclxuXHJcbnZhciBfYWN0aW9uX3R5cGVzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL2FjdGlvbl90eXBlcycpO1xyXG5cclxudmFyIHR5cGVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2FjdGlvbl90eXBlcyk7XHJcblxyXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxuXHJcbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XHJcblxyXG52YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cclxuZnVuY3Rpb24gb3JpZ2luUG9pbnQoY29vcmRpbmF0ZXMpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoKSB7XHJcbiAgICB2YXIgb3JpZ2luID0gX3V0aWxzMi5kZWZhdWx0LmNyZWF0ZVBvaW50KGNvb3JkaW5hdGVzLCB7XHJcbiAgICAgIGlkOiAnb3JpZ2luJyxcclxuICAgICAgJ21hcmtlci1zeW1ib2wnOiAnQSdcclxuICAgIH0pO1xyXG5cclxuICAgIGRpc3BhdGNoKHsgdHlwZTogdHlwZXMuT1JJR0lOLCBvcmlnaW46IG9yaWdpbiB9KTtcclxuICAgIGRpc3BhdGNoKGV2ZW50RW1pdCgnb3JpZ2luJywgeyBmZWF0dXJlOiBvcmlnaW4gfSkpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlc3RpbmF0aW9uUG9pbnQoY29vcmRpbmF0ZXMpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoKSB7XHJcbiAgICB2YXIgZGVzdGluYXRpb24gPSBfdXRpbHMyLmRlZmF1bHQuY3JlYXRlUG9pbnQoY29vcmRpbmF0ZXMsIHtcclxuICAgICAgaWQ6ICdkZXN0aW5hdGlvbicsXHJcbiAgICAgICdtYXJrZXItc3ltYm9sJzogJ0InXHJcbiAgICB9KTtcclxuXHJcbiAgICBkaXNwYXRjaCh7IHR5cGU6IHR5cGVzLkRFU1RJTkFUSU9OLCBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24gfSk7XHJcbiAgICBkaXNwYXRjaChldmVudEVtaXQoJ2Rlc3RpbmF0aW9uJywgeyBmZWF0dXJlOiBkZXN0aW5hdGlvbiB9KSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0RGlyZWN0aW9ucyhkaXJlY3Rpb25zKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiB0eXBlcy5ESVJFQ1RJT05TLFxyXG4gICAgICBkaXJlY3Rpb25zOiBkaXJlY3Rpb25zXHJcbiAgICB9KTtcclxuICAgIGRpc3BhdGNoKGV2ZW50RW1pdCgncm91dGUnLCB7IHJvdXRlOiBkaXJlY3Rpb25zIH0pKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVXYXlwb2ludHMod2F5cG9pbnRzKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IHR5cGVzLldBWVBPSU5UUyxcclxuICAgIHdheXBvaW50czogd2F5cG9pbnRzXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0SG92ZXJNYXJrZXIoZmVhdHVyZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiB0eXBlcy5IT1ZFUl9NQVJLRVIsXHJcbiAgICBob3Zlck1hcmtlcjogZmVhdHVyZVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZldGNoRGlyZWN0aW9ucygpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgdmFyIF9nZXRTdGF0ZSA9IGdldFN0YXRlKCk7XHJcblxyXG4gICAgdmFyIGFwaSA9IF9nZXRTdGF0ZS5hcGk7XHJcbiAgICB2YXIgYWNjZXNzVG9rZW4gPSBfZ2V0U3RhdGUuYWNjZXNzVG9rZW47XHJcbiAgICB2YXIgcm91dGVJbmRleCA9IF9nZXRTdGF0ZS5yb3V0ZUluZGV4O1xyXG4gICAgdmFyIHByb2ZpbGUgPSBfZ2V0U3RhdGUucHJvZmlsZTtcclxuXHJcbiAgICB2YXIgcXVlcnkgPSBidWlsZERpcmVjdGlvbnNRdWVyeShnZXRTdGF0ZSk7XHJcblxyXG4gICAgLy8gUmVxdWVzdCBwYXJhbXNcclxuICAgIHZhciBvcHRpb25zID0gW107XHJcbiAgICBvcHRpb25zLnB1c2goJ2dlb21ldHJpZXM9cG9seWxpbmUnKTtcclxuICAgIG9wdGlvbnMucHVzaCgnYWx0ZXJuYXRpdmVzPXRydWUnKTtcclxuICAgIG9wdGlvbnMucHVzaCgnc3RlcHM9dHJ1ZScpO1xyXG4gICAgb3B0aW9ucy5wdXNoKCdvdmVydmlldz1mdWxsJyk7XHJcbiAgICBvcHRpb25zLnB1c2goJ2FjY2Vzc190b2tlbj0nICsgYWNjZXNzVG9rZW4pO1xyXG4gICAgcmVxdWVzdC5hYm9ydCgpO1xyXG4gICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBhcGkgKyAnbWFwYm94LycgKyBwcm9maWxlICsgJy8nICsgcXVlcnkgKyAnLmpzb24/JyArIG9wdGlvbnMuam9pbignJicpLCB0cnVlKTtcclxuXHJcbiAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID49IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyA8IDQwMCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHtcclxuICAgICAgICAgIGRpc3BhdGNoKHNldERpcmVjdGlvbnMoW10pKTtcclxuICAgICAgICAgIHJldHVybiBkaXNwYXRjaChzZXRFcnJvcihkYXRhLmVycm9yKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkaXNwYXRjaChzZXRFcnJvcihudWxsKSk7XHJcbiAgICAgICAgaWYgKCFkYXRhLnJvdXRlc1tyb3V0ZUluZGV4XSkgZGlzcGF0Y2goc2V0Um91dGVJbmRleCgwKSk7XHJcbiAgICAgICAgZGlzcGF0Y2goc2V0RGlyZWN0aW9ucyhkYXRhLnJvdXRlcykpO1xyXG5cclxuICAgICAgICAvLyBSZXZpc2Ugb3JpZ2luIC8gZGVzdGluYXRpb24gcG9pbnRzXHJcbiAgICAgICAgZGlzcGF0Y2gob3JpZ2luUG9pbnQoZGF0YS53YXlwb2ludHNbMF0ubG9jYXRpb24pKTtcclxuICAgICAgICBkaXNwYXRjaChkZXN0aW5hdGlvblBvaW50KGRhdGEud2F5cG9pbnRzW2RhdGEud2F5cG9pbnRzLmxlbmd0aCAtIDFdLmxvY2F0aW9uKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGlzcGF0Y2goc2V0RGlyZWN0aW9ucyhbXSkpO1xyXG4gICAgICAgIHJldHVybiBkaXNwYXRjaChzZXRFcnJvcihKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KS5tZXNzYWdlKSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBkaXNwYXRjaChzZXREaXJlY3Rpb25zKFtdKSk7XHJcbiAgICAgIHJldHVybiBkaXNwYXRjaChzZXRFcnJvcihKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KS5tZXNzYWdlKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJlcXVlc3Quc2VuZCgpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qXHJcbiAqIEJ1aWxkIHF1ZXJ5IHVzZWQgdG8gZmV0Y2ggZGlyZWN0aW9uc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdGF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gYnVpbGREaXJlY3Rpb25zUXVlcnkoc3RhdGUpIHtcclxuICB2YXIgX3N0YXRlID0gc3RhdGUoKTtcclxuXHJcbiAgdmFyIG9yaWdpbiA9IF9zdGF0ZS5vcmlnaW47XHJcbiAgdmFyIGRlc3RpbmF0aW9uID0gX3N0YXRlLmRlc3RpbmF0aW9uO1xyXG4gIHZhciB3YXlwb2ludHMgPSBfc3RhdGUud2F5cG9pbnRzO1xyXG5cclxuXHJcbiAgdmFyIHF1ZXJ5ID0gW107XHJcbiAgcXVlcnkucHVzaChvcmlnaW4uZ2VvbWV0cnkuY29vcmRpbmF0ZXMuam9pbignLCcpKTtcclxuICBxdWVyeS5wdXNoKCc7Jyk7XHJcblxyXG4gIC8vIEFkZCBhbnkgd2F5cG9pbnRzLlxyXG4gIGlmICh3YXlwb2ludHMubGVuZ3RoKSB7XHJcbiAgICB3YXlwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAod2F5cG9pbnQpIHtcclxuICAgICAgcXVlcnkucHVzaCh3YXlwb2ludC5nZW9tZXRyeS5jb29yZGluYXRlcy5qb2luKCcsJykpO1xyXG4gICAgICBxdWVyeS5wdXNoKCc7Jyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHF1ZXJ5LnB1c2goZGVzdGluYXRpb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXMuam9pbignLCcpKTtcclxuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5LmpvaW4oJycpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplV2F5cG9pbnQod2F5cG9pbnQpIHtcclxuICB2YXIgcHJvcGVydGllcyA9IHsgaWQ6ICd3YXlwb2ludCcgfTtcclxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih3YXlwb2ludCwge1xyXG4gICAgcHJvcGVydGllczogd2F5cG9pbnQucHJvcGVydGllcyA/IE9iamVjdC5hc3NpZ24od2F5cG9pbnQucHJvcGVydGllcywgcHJvcGVydGllcykgOiBwcm9wZXJ0aWVzXHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEVycm9yKGVycm9yKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiAnRVJST1InLFxyXG4gICAgICBlcnJvcjogZXJyb3JcclxuICAgIH0pO1xyXG4gICAgaWYgKGVycm9yKSBkaXNwYXRjaChldmVudEVtaXQoJ2Vycm9yJywgeyBlcnJvcjogZXJyb3IgfSkpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1ZXJ5T3JpZ2luKHF1ZXJ5KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IHR5cGVzLk9SSUdJTl9RVUVSWSxcclxuICAgIHF1ZXJ5OiBxdWVyeVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1ZXJ5RGVzdGluYXRpb24ocXVlcnkpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogdHlwZXMuREVTVElOQVRJT05fUVVFUlksXHJcbiAgICBxdWVyeTogcXVlcnlcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdWVyeU9yaWdpbkNvb3JkaW5hdGVzKGNvb3Jkcykge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiB0eXBlcy5PUklHSU5fRlJPTV9DT09SRElOQVRFUyxcclxuICAgIGNvb3JkaW5hdGVzOiBjb29yZHNcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdWVyeURlc3RpbmF0aW9uQ29vcmRpbmF0ZXMoY29vcmRzKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IHR5cGVzLkRFU1RJTkFUSU9OX0ZST01fQ09PUkRJTkFURVMsXHJcbiAgICBjb29yZGluYXRlczogY29vcmRzXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2xlYXJPcmlnaW4oKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiB0eXBlcy5PUklHSU5fQ0xFQVJcclxuICAgIH0pO1xyXG4gICAgZGlzcGF0Y2goZXZlbnRFbWl0KCdjbGVhcicsIHsgdHlwZTogJ29yaWdpbicgfSkpO1xyXG4gICAgZGlzcGF0Y2goc2V0RXJyb3IobnVsbCkpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsZWFyRGVzdGluYXRpb24oKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xyXG4gICAgZGlzcGF0Y2goe1xyXG4gICAgICB0eXBlOiB0eXBlcy5ERVNUSU5BVElPTl9DTEVBUlxyXG4gICAgfSk7XHJcbiAgICBkaXNwYXRjaChldmVudEVtaXQoJ2NsZWFyJywgeyB0eXBlOiAnZGVzdGluYXRpb24nIH0pKTtcclxuICAgIGRpc3BhdGNoKHNldEVycm9yKG51bGwpKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogdHlwZXMuU0VUX09QVElPTlMsXHJcbiAgICBvcHRpb25zOiBvcHRpb25zXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gaG92ZXJNYXJrZXIoY29vcmRpbmF0ZXMpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoKSB7XHJcbiAgICB2YXIgZmVhdHVyZSA9IGNvb3JkaW5hdGVzID8gX3V0aWxzMi5kZWZhdWx0LmNyZWF0ZVBvaW50KGNvb3JkaW5hdGVzLCB7IGlkOiAnaG92ZXInIH0pIDoge307XHJcbiAgICBkaXNwYXRjaChzZXRIb3Zlck1hcmtlcihmZWF0dXJlKSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0Um91dGVJbmRleChyb3V0ZUluZGV4KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IHR5cGVzLlJPVVRFX0lOREVYLFxyXG4gICAgcm91dGVJbmRleDogcm91dGVJbmRleFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU9yaWdpbihjb29yZGluYXRlcykge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIGdldFN0YXRlKSB7XHJcbiAgICB2YXIgX2dldFN0YXRlMiA9IGdldFN0YXRlKCk7XHJcblxyXG4gICAgdmFyIGRlc3RpbmF0aW9uID0gX2dldFN0YXRlMi5kZXN0aW5hdGlvbjtcclxuXHJcbiAgICBkaXNwYXRjaChvcmlnaW5Qb2ludChjb29yZGluYXRlcykpO1xyXG4gICAgaWYgKGRlc3RpbmF0aW9uLmdlb21ldHJ5KSBkaXNwYXRjaChmZXRjaERpcmVjdGlvbnMoKSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRGVzdGluYXRpb24oY29vcmRpbmF0ZXMpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgdmFyIF9nZXRTdGF0ZTMgPSBnZXRTdGF0ZSgpO1xyXG5cclxuICAgIHZhciBvcmlnaW4gPSBfZ2V0U3RhdGUzLm9yaWdpbjtcclxuXHJcbiAgICBkaXNwYXRjaChkZXN0aW5hdGlvblBvaW50KGNvb3JkaW5hdGVzKSk7XHJcbiAgICBpZiAob3JpZ2luLmdlb21ldHJ5KSBkaXNwYXRjaChmZXRjaERpcmVjdGlvbnMoKSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0UHJvZmlsZShwcm9maWxlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUpIHtcclxuICAgIHZhciBfZ2V0U3RhdGU0ID0gZ2V0U3RhdGUoKTtcclxuXHJcbiAgICB2YXIgb3JpZ2luID0gX2dldFN0YXRlNC5vcmlnaW47XHJcbiAgICB2YXIgZGVzdGluYXRpb24gPSBfZ2V0U3RhdGU0LmRlc3RpbmF0aW9uO1xyXG5cclxuICAgIGRpc3BhdGNoKHsgdHlwZTogdHlwZXMuRElSRUNUSU9OU19QUk9GSUxFLCBwcm9maWxlOiBwcm9maWxlIH0pO1xyXG4gICAgZGlzcGF0Y2goZXZlbnRFbWl0KCdwcm9maWxlJywgeyBwcm9maWxlOiBwcm9maWxlIH0pKTtcclxuICAgIGlmIChvcmlnaW4uZ2VvbWV0cnkgJiYgZGVzdGluYXRpb24uZ2VvbWV0cnkpIGRpc3BhdGNoKGZldGNoRGlyZWN0aW9ucygpKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXZlcnNlKCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIGdldFN0YXRlKSB7XHJcbiAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgaWYgKHN0YXRlLmRlc3RpbmF0aW9uLmdlb21ldHJ5KSBkaXNwYXRjaChvcmlnaW5Qb2ludChzdGF0ZS5kZXN0aW5hdGlvbi5nZW9tZXRyeS5jb29yZGluYXRlcykpO1xyXG4gICAgaWYgKHN0YXRlLm9yaWdpbi5nZW9tZXRyeSkgZGlzcGF0Y2goZGVzdGluYXRpb25Qb2ludChzdGF0ZS5vcmlnaW4uZ2VvbWV0cnkuY29vcmRpbmF0ZXMpKTtcclxuICAgIGlmIChzdGF0ZS5vcmlnaW4uZ2VvbWV0cnkgJiYgc3RhdGUuZGVzdGluYXRpb24uZ2VvbWV0cnkpIGRpc3BhdGNoKGZldGNoRGlyZWN0aW9ucygpKTtcclxuICB9O1xyXG59XHJcblxyXG4vKlxyXG4gKiBTZXQgb3JpZ2luIGZyb20gY29vcmRpbmF0ZXNcclxuICpcclxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBbbG5nLCBsYXRdIGFycmF5LlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0T3JpZ2luRnJvbUNvb3JkaW5hdGVzKGNvb3Jkcykge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcclxuICAgIGlmICghX3V0aWxzMi5kZWZhdWx0LnZhbGlkQ29vcmRzKGNvb3JkcykpIGNvb3JkcyA9IFtfdXRpbHMyLmRlZmF1bHQud3JhcChjb29yZHNbMF0pLCBfdXRpbHMyLmRlZmF1bHQud3JhcChjb29yZHNbMV0pXTtcclxuICAgIGlmIChpc05hTihjb29yZHNbMF0pICYmIGlzTmFOKGNvb3Jkc1sxXSkpIHJldHVybiBkaXNwYXRjaChzZXRFcnJvcihuZXcgRXJyb3IoJ0Nvb3JkaW5hdGVzIGFyZSBub3QgdmFsaWQnKSkpO1xyXG4gICAgZGlzcGF0Y2gocXVlcnlPcmlnaW5Db29yZGluYXRlcyhjb29yZHMpKTtcclxuICAgIGRpc3BhdGNoKGNyZWF0ZU9yaWdpbihjb29yZHMpKTtcclxuICB9O1xyXG59XHJcblxyXG4vKlxyXG4gKiBTZXQgZGVzdGluYXRpb24gZnJvbSBjb29yZGluYXRlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkcyBbbG5nLCBsYXRdIGFycmF5LlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGVzdGluYXRpb25Gcm9tQ29vcmRpbmF0ZXMoY29vcmRzKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xyXG4gICAgaWYgKCFfdXRpbHMyLmRlZmF1bHQudmFsaWRDb29yZHMoY29vcmRzKSkgY29vcmRzID0gW191dGlsczIuZGVmYXVsdC53cmFwKGNvb3Jkc1swXSksIF91dGlsczIuZGVmYXVsdC53cmFwKGNvb3Jkc1sxXSldO1xyXG4gICAgaWYgKGlzTmFOKGNvb3Jkc1swXSkgJiYgaXNOYU4oY29vcmRzWzFdKSkgcmV0dXJuIGRpc3BhdGNoKHNldEVycm9yKG5ldyBFcnJvcignQ29vcmRpbmF0ZXMgYXJlIG5vdCB2YWxpZCcpKSk7XHJcbiAgICBkaXNwYXRjaChjcmVhdGVEZXN0aW5hdGlvbihjb29yZHMpKTtcclxuICAgIGRpc3BhdGNoKHF1ZXJ5RGVzdGluYXRpb25Db29yZGluYXRlcyhjb29yZHMpKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRXYXlwb2ludChpbmRleCwgd2F5cG9pbnQpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgdmFyIF9nZXRTdGF0ZTUgPSBnZXRTdGF0ZSgpO1xyXG5cclxuICAgIHZhciBkZXN0aW5hdGlvbiA9IF9nZXRTdGF0ZTUuZGVzdGluYXRpb247XHJcbiAgICB2YXIgd2F5cG9pbnRzID0gX2dldFN0YXRlNS53YXlwb2ludHM7XHJcblxyXG4gICAgd2F5cG9pbnRzLnNwbGljZShpbmRleCwgMCwgbm9ybWFsaXplV2F5cG9pbnQod2F5cG9pbnQpKTtcclxuICAgIGRpc3BhdGNoKHVwZGF0ZVdheXBvaW50cyh3YXlwb2ludHMpKTtcclxuICAgIGlmIChkZXN0aW5hdGlvbi5nZW9tZXRyeSkgZGlzcGF0Y2goZmV0Y2hEaXJlY3Rpb25zKCkpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFdheXBvaW50KGluZGV4LCB3YXlwb2ludCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIGdldFN0YXRlKSB7XHJcbiAgICB2YXIgX2dldFN0YXRlNiA9IGdldFN0YXRlKCk7XHJcblxyXG4gICAgdmFyIGRlc3RpbmF0aW9uID0gX2dldFN0YXRlNi5kZXN0aW5hdGlvbjtcclxuICAgIHZhciB3YXlwb2ludHMgPSBfZ2V0U3RhdGU2LndheXBvaW50cztcclxuXHJcbiAgICB3YXlwb2ludHNbaW5kZXhdID0gbm9ybWFsaXplV2F5cG9pbnQod2F5cG9pbnQpO1xyXG4gICAgZGlzcGF0Y2godXBkYXRlV2F5cG9pbnRzKHdheXBvaW50cykpO1xyXG4gICAgaWYgKGRlc3RpbmF0aW9uLmdlb21ldHJ5KSBkaXNwYXRjaChmZXRjaERpcmVjdGlvbnMoKSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlV2F5cG9pbnQod2F5cG9pbnQpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgdmFyIF9nZXRTdGF0ZTcgPSBnZXRTdGF0ZSgpO1xyXG5cclxuICAgIHZhciBkZXN0aW5hdGlvbiA9IF9nZXRTdGF0ZTcuZGVzdGluYXRpb247XHJcbiAgICB2YXIgd2F5cG9pbnRzID0gX2dldFN0YXRlNy53YXlwb2ludHM7XHJcblxyXG4gICAgd2F5cG9pbnRzID0gd2F5cG9pbnRzLmZpbHRlcihmdW5jdGlvbiAod2F5KSB7XHJcbiAgICAgIHJldHVybiAhX3V0aWxzMi5kZWZhdWx0LmNvb3JkaW5hdGVNYXRjaCh3YXksIHdheXBvaW50KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRpc3BhdGNoKHVwZGF0ZVdheXBvaW50cyh3YXlwb2ludHMpKTtcclxuICAgIGlmIChkZXN0aW5hdGlvbi5nZW9tZXRyeSkgZGlzcGF0Y2goZmV0Y2hEaXJlY3Rpb25zKCkpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV2ZW50U3Vic2NyaWJlKHR5cGUsIGZuKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUpIHtcclxuICAgIHZhciBfZ2V0U3RhdGU4ID0gZ2V0U3RhdGUoKTtcclxuXHJcbiAgICB2YXIgZXZlbnRzID0gX2dldFN0YXRlOC5ldmVudHM7XHJcblxyXG4gICAgZXZlbnRzW3R5cGVdID0gZXZlbnRzW3R5cGVdIHx8IFtdO1xyXG4gICAgZXZlbnRzW3R5cGVdLnB1c2goZm4pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogdHlwZXMuRVZFTlRTLFxyXG4gICAgICBldmVudHM6IGV2ZW50c1xyXG4gICAgfTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBldmVudEVtaXQodHlwZSwgZGF0YSkge1xyXG4gIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIGdldFN0YXRlKSB7XHJcbiAgICB2YXIgX2dldFN0YXRlOSA9IGdldFN0YXRlKCk7XHJcblxyXG4gICAgdmFyIGV2ZW50cyA9IF9nZXRTdGF0ZTkuZXZlbnRzO1xyXG5cclxuXHJcbiAgICBpZiAoIWV2ZW50c1t0eXBlXSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IHR5cGVzLkVWRU5UUyxcclxuICAgICAgICBldmVudHM6IGV2ZW50c1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV0uc2xpY2UoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChfdGhpcywgZGF0YSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxufSx7XCIuLi9jb25zdGFudHMvYWN0aW9uX3R5cGVzXCI6MzQsXCIuLi91dGlsc1wiOjQyfV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxudmFyIERFU1RJTkFUSU9OID0gZXhwb3J0cy5ERVNUSU5BVElPTiA9ICdERVNUSU5BVElPTic7XHJcbnZhciBERVNUSU5BVElPTl9DTEVBUiA9IGV4cG9ydHMuREVTVElOQVRJT05fQ0xFQVIgPSAnREVTVElOQVRJT05fQ0xFQVInO1xyXG52YXIgREVTVElOQVRJT05fUVVFUlkgPSBleHBvcnRzLkRFU1RJTkFUSU9OX1FVRVJZID0gJ0RFU1RJTkFUSU9OX1FVRVJZJztcclxudmFyIERFU1RJTkFUSU9OX0ZST01fQ09PUkRJTkFURVMgPSBleHBvcnRzLkRFU1RJTkFUSU9OX0ZST01fQ09PUkRJTkFURVMgPSAnREVTVElOQVRJT05fRlJPTV9DT09SRElOQVRFUyc7XHJcbnZhciBESVJFQ1RJT05TID0gZXhwb3J0cy5ESVJFQ1RJT05TID0gJ0RJUkVDVElPTlMnO1xyXG52YXIgRElSRUNUSU9OU19QUk9GSUxFID0gZXhwb3J0cy5ESVJFQ1RJT05TX1BST0ZJTEUgPSAnRElSRUNUSU9OU19QUk9GSUxFJztcclxudmFyIEVWRU5UUyA9IGV4cG9ydHMuRVZFTlRTID0gJ0VWRU5UUyc7XHJcbnZhciBFUlJPUiA9IGV4cG9ydHMuRVJST1IgPSAnRVJST1InO1xyXG52YXIgSE9WRVJfTUFSS0VSID0gZXhwb3J0cy5IT1ZFUl9NQVJLRVIgPSAnSE9WRVJfTUFSS0VSJztcclxudmFyIE9SSUdJTiA9IGV4cG9ydHMuT1JJR0lOID0gJ09SSUdJTic7XHJcbnZhciBPUklHSU5fQ0xFQVIgPSBleHBvcnRzLk9SSUdJTl9DTEVBUiA9ICdPUklHSU5fQ0xFQVInO1xyXG52YXIgT1JJR0lOX1FVRVJZID0gZXhwb3J0cy5PUklHSU5fUVVFUlkgPSAnT1JJR0lOX1FVRVJZJztcclxudmFyIE9SSUdJTl9GUk9NX0NPT1JESU5BVEVTID0gZXhwb3J0cy5PUklHSU5fRlJPTV9DT09SRElOQVRFUyA9ICdPUklHSU5fRlJPTV9DT09SRElOQVRFUyc7XHJcbnZhciBST1VURV9JTkRFWCA9IGV4cG9ydHMuUk9VVEVfSU5ERVggPSAnUk9VVEVfSU5ERVgnO1xyXG52YXIgU0VUX09QVElPTlMgPSBleHBvcnRzLlNFVF9PUFRJT05TID0gJ1NFVF9PUFRJT05TJztcclxudmFyIFdBWVBPSU5UUyA9IGV4cG9ydHMuV0FZUE9JTlRTID0gJ1dBWVBPSU5UUyc7XHJcblxyXG59LHt9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xyXG5cclxudmFyIF9zdWdnZXN0aW9ucyA9IHJlcXVpcmUoJ3N1Z2dlc3Rpb25zJyk7XHJcblxyXG52YXIgX3N1Z2dlc3Rpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1Z2dlc3Rpb25zKTtcclxuXHJcbnZhciBfbG9kYXNoID0gcmVxdWlyZSgnbG9kYXNoLmRlYm91bmNlJyk7XHJcblxyXG52YXIgX2xvZGFzaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2Rhc2gpO1xyXG5cclxudmFyIF94dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJyk7XHJcblxyXG52YXIgX3h0ZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3h0ZW5kKTtcclxuXHJcbnZhciBfZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XHJcblxyXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxuXHJcbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8vIE1hcGJveCBHZW9jb2RlciB2ZXJzaW9uXHJcbnZhciBBUEkgPSAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9nZW9jb2RpbmcvdjUvbWFwYm94LnBsYWNlcy8nO1xyXG5cclxuLy8gR2VvY29kZXIgLSB0aGlzIHNsaWdodGx5IG1pbWlja3MgdGhlIG1hcGJveGwtZ2wtZ2VvY29kZXIgYnV0IGlzbid0IGFuIGV4YWN0IHJlcGxpY2EuXHJcbi8vIE9uY2UgZ2wtanMgcGx1Z2lucyBjYW4gYmUgYWRkZWQgdG8gY3VzdG9tIGRpdnMsIHdlIHNob3VsZCBiZSBhYmxlIHRvIHJlcXVpcmUgbWFwYm94LWdsLWdlb2NvZGVyXHJcbi8vIGluc3RlYWQgb2YgaW5jbHVkaW5nIGl0IGhlcmVcclxuZnVuY3Rpb24gR2VvY29kZXIob3B0aW9ucykge1xyXG4gIHRoaXMuX2V2ID0gbmV3IF9ldmVudHMuRXZlbnRFbWl0dGVyKCk7XHJcbiAgdGhpcy5vcHRpb25zID0gKDAsIF94dGVuZDIuZGVmYXVsdCkoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuXHJcbkdlb2NvZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgb3B0aW9uczoge1xyXG4gICAgcGxhY2Vob2xkZXI6ICdTZWFyY2gnLFxyXG4gICAgem9vbTogMTYsXHJcbiAgICBmbHlUbzogdHJ1ZVxyXG4gIH0sXHJcblxyXG4gIG9uQWRkOiBmdW5jdGlvbiBvbkFkZChtYXApIHtcclxuICAgIHRoaXMuX21hcCA9IG1hcDtcclxuXHJcbiAgICB0aGlzLnJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcbiAgICAvLyBUZW1wbGF0ZVxyXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBlbC5jbGFzc05hbWUgPSAnbWFwYm94Z2wtY3RybC1nZW9jb2Rlcic7XHJcblxyXG4gICAgdmFyIGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICBpY29uLmNsYXNzTmFtZSA9ICdnZW9jb2Rlci1pY29uIGdlb2NvZGVyLWljb24tc2VhcmNoJztcclxuXHJcbiAgICB2YXIgaW5wdXQgPSB0aGlzLl9pbnB1dEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICAgIGlucHV0LnR5cGUgPSAndGV4dCc7XHJcbiAgICBpbnB1dC5wbGFjZWhvbGRlciA9IHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcjtcclxuXHJcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKDAsIF9sb2Rhc2gyLmRlZmF1bHQpKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGlmICghZS50YXJnZXQudmFsdWUpIHJldHVybiB0aGlzLl9jbGVhckVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgLy8gVEFCLCBFU0MsIExFRlQsIFJJR0hULCBFTlRFUiwgVVAsIERPV05cclxuICAgICAgaWYgKGUubWV0YUtleSB8fCBbOSwgMjcsIDM3LCAzOSwgMTMsIDM4LCA0MF0uaW5kZXhPZihlLmtleUNvZGUpICE9PSAtMSkgcmV0dXJuO1xyXG4gICAgICB0aGlzLl9xdWVyeUZyb21JbnB1dChlLnRhcmdldC52YWx1ZSk7XHJcbiAgICB9LmJpbmQodGhpcykpLCAyMDApO1xyXG5cclxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGlmIChlLnRhcmdldC52YWx1ZSkgdGhpcy5fY2xlYXJFbC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcclxuXHJcbiAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuX3R5cGVhaGVhZC5zZWxlY3RlZDtcclxuICAgICAgaWYgKHNlbGVjdGVkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mbHlUbykge1xyXG4gICAgICAgICAgaWYgKHNlbGVjdGVkLmJib3ggJiYgc2VsZWN0ZWQuY29udGV4dCAmJiBzZWxlY3RlZC5jb250ZXh0Lmxlbmd0aCA8PSAzIHx8IHNlbGVjdGVkLmJib3ggJiYgIXNlbGVjdGVkLmNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGJib3ggPSBzZWxlY3RlZC5iYm94O1xyXG4gICAgICAgICAgICBtYXAuZml0Qm91bmRzKFtbYmJveFswXSwgYmJveFsxXV0sIFtiYm94WzJdLCBiYm94WzNdXV0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWFwLmZseVRvKHtcclxuICAgICAgICAgICAgICBjZW50ZXI6IHNlbGVjdGVkLmNlbnRlcixcclxuICAgICAgICAgICAgICB6b29tOiB0aGlzLm9wdGlvbnMuem9vbVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5wdXQgPSBzZWxlY3RlZDtcclxuICAgICAgICB0aGlzLmZpcmUoJ3Jlc3VsdCcsIHsgcmVzdWx0OiBzZWxlY3RlZCB9KTtcclxuICAgICAgfVxyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICB2YXIgYWN0aW9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgYWN0aW9ucy5jbGFzc0xpc3QuYWRkKCdnZW9jb2Rlci1waW4tcmlnaHQnKTtcclxuXHJcbiAgICB2YXIgY2xlYXIgPSB0aGlzLl9jbGVhckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgICBjbGVhci5jbGFzc05hbWUgPSAnZ2VvY29kZXItaWNvbiBnZW9jb2Rlci1pY29uLWNsb3NlJztcclxuICAgIGNsZWFyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xlYXIuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgdmFyIGxvYWRpbmcgPSB0aGlzLl9sb2FkaW5nRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICBsb2FkaW5nLmNsYXNzTmFtZSA9ICdnZW9jb2Rlci1pY29uIGdlb2NvZGVyLWljb24tbG9hZGluZyc7XHJcblxyXG4gICAgYWN0aW9ucy5hcHBlbmRDaGlsZChjbGVhcik7XHJcbiAgICBhY3Rpb25zLmFwcGVuZENoaWxkKGxvYWRpbmcpO1xyXG5cclxuICAgIGVsLmFwcGVuZENoaWxkKGljb24pO1xyXG4gICAgZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG4gICAgZWwuYXBwZW5kQ2hpbGQoYWN0aW9ucyk7XHJcblxyXG4gICAgLy8gT3ZlcnJpZGUgdGhlIGNvbnRyb2wgYmVpbmcgYWRkZWQgdG8gY29udHJvbCBjb250YWluZXJzXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRhaW5lcikgdGhpcy5vcHRpb25zLnBvc2l0aW9uID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fdHlwZWFoZWFkID0gbmV3IF9zdWdnZXN0aW9uczIuZGVmYXVsdChpbnB1dCwgW10sIHsgZmlsdGVyOiBmYWxzZSB9KTtcclxuICAgIHRoaXMuX3R5cGVhaGVhZC5nZXRJdGVtVmFsdWUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICByZXR1cm4gaXRlbS5wbGFjZV9uYW1lO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gZWw7XHJcbiAgfSxcclxuXHJcbiAgX2dlb2NvZGU6IGZ1bmN0aW9uIF9nZW9jb2RlKHEsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLl9sb2FkaW5nRWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcbiAgICB0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcclxuXHJcbiAgICB2YXIgb3B0aW9ucyA9IFtdO1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcm94aW1pdHkpIG9wdGlvbnMucHVzaCgncHJveGltaXR5PScgKyB0aGlzLm9wdGlvbnMucHJveGltaXR5LmpvaW4oKSk7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmJib3gpIG9wdGlvbnMucHVzaCgnYmJveD0nICsgdGhpcy5vcHRpb25zLmJib3guam9pbigpKTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMuY291bnRyeSkgb3B0aW9ucy5wdXNoKCdjb3VudHJ5PScgKyB0aGlzLm9wdGlvbnMuY291bnRyeSk7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnR5cGVzKSBvcHRpb25zLnB1c2goJ3R5cGVzPScgKyB0aGlzLm9wdGlvbnMudHlwZXMpO1xyXG5cclxuICAgIHZhciBhY2Nlc3NUb2tlbiA9IHRoaXMub3B0aW9ucy5hY2Nlc3NUb2tlbiA/IHRoaXMub3B0aW9ucy5hY2Nlc3NUb2tlbiA6IG1hcGJveGdsLmFjY2Vzc1Rva2VuO1xyXG4gICAgb3B0aW9ucy5wdXNoKCdhY2Nlc3NfdG9rZW49JyArIGFjY2Vzc1Rva2VuKTtcclxuXHJcbiAgICB0aGlzLnJlcXVlc3QuYWJvcnQoKTtcclxuICAgIHRoaXMucmVxdWVzdC5vcGVuKCdHRVQnLCBBUEkgKyBlbmNvZGVVUklDb21wb25lbnQocS50cmltKCkpICsgJy5qc29uPycgKyBvcHRpb25zLmpvaW4oJyYnKSwgdHJ1ZSk7XHJcbiAgICB0aGlzLnJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLl9sb2FkaW5nRWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XHJcbiAgICAgIGlmICh0aGlzLnJlcXVlc3Quc3RhdHVzID49IDIwMCAmJiB0aGlzLnJlcXVlc3Quc3RhdHVzIDwgNDAwKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHRoaXMucmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgIGlmIChkYXRhLmZlYXR1cmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgdGhpcy5fY2xlYXJFbC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fY2xlYXJFbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuICAgICAgICAgIHRoaXMuX3R5cGVhaGVhZC5zZWxlY3RlZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZpcmUoJ3Jlc3VsdHMnLCB7IHJlc3VsdHM6IGRhdGEuZmVhdHVyZXMgfSk7XHJcbiAgICAgICAgdGhpcy5fdHlwZWFoZWFkLnVwZGF0ZShkYXRhLmZlYXR1cmVzKTtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZGF0YS5mZWF0dXJlcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHsgZXJyb3I6IEpTT04ucGFyc2UodGhpcy5yZXF1ZXN0LnJlc3BvbnNlVGV4dCkubWVzc2FnZSB9KTtcclxuICAgICAgfVxyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMucmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLl9sb2FkaW5nRWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XHJcbiAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7IGVycm9yOiBKU09OLnBhcnNlKHRoaXMucmVxdWVzdC5yZXNwb25zZVRleHQpLm1lc3NhZ2UgfSk7XHJcbiAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5yZXF1ZXN0LnNlbmQoKTtcclxuICB9LFxyXG5cclxuICBfcXVlcnlGcm9tSW5wdXQ6IGZ1bmN0aW9uIF9xdWVyeUZyb21JbnB1dChxKSB7XHJcbiAgICBxID0gcS50cmltKCk7XHJcbiAgICBpZiAoIXEpIHRoaXMuX2NsZWFyKCk7XHJcbiAgICBpZiAocS5sZW5ndGggPiAyKSB7XHJcbiAgICAgIHRoaXMuX2dlb2NvZGUocSwgZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgICB0aGlzLl9yZXN1bHRzID0gcmVzdWx0cztcclxuICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfY2hhbmdlOiBmdW5jdGlvbiBfY2hhbmdlKCkge1xyXG4gICAgdmFyIG9uQ2hhbmdlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcclxuICAgIG9uQ2hhbmdlLmluaXRFdmVudCgnY2hhbmdlJywgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgdGhpcy5faW5wdXRFbC5kaXNwYXRjaEV2ZW50KG9uQ2hhbmdlKTtcclxuICB9LFxyXG5cclxuICBfcXVlcnk6IGZ1bmN0aW9uIF9xdWVyeShpbnB1dCkge1xyXG4gICAgaWYgKCFpbnB1dCkgcmV0dXJuO1xyXG4gICAgaWYgKCh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlucHV0KSkgPT09ICdvYmplY3QnICYmIGlucHV0Lmxlbmd0aCkge1xyXG4gICAgICBpbnB1dCA9IFtfdXRpbHMyLmRlZmF1bHQud3JhcChpbnB1dFswXSksIF91dGlsczIuZGVmYXVsdC53cmFwKGlucHV0WzFdKV0uam9pbigpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2dlb2NvZGUoaW5wdXQsIGZ1bmN0aW9uIChyZXN1bHRzKSB7XHJcbiAgICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHJldHVybjtcclxuICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdHNbMF07XHJcbiAgICAgIHRoaXMuX3Jlc3VsdHMgPSByZXN1bHRzO1xyXG4gICAgICB0aGlzLl90eXBlYWhlYWQuc2VsZWN0ZWQgPSByZXN1bHQ7XHJcbiAgICAgIHRoaXMuX2lucHV0RWwudmFsdWUgPSByZXN1bHQucGxhY2VfbmFtZTtcclxuICAgICAgdGhpcy5fY2hhbmdlKCk7XHJcbiAgICB9LmJpbmQodGhpcykpO1xyXG4gIH0sXHJcblxyXG4gIF9zZXRJbnB1dDogZnVuY3Rpb24gX3NldElucHV0KGlucHV0KSB7XHJcbiAgICBpZiAoIWlucHV0KSByZXR1cm47XHJcbiAgICBpZiAoKHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaW5wdXQpKSA9PT0gJ29iamVjdCcgJiYgaW5wdXQubGVuZ3RoKSB7XHJcbiAgICAgIGlucHV0ID0gW191dGlsczIuZGVmYXVsdC53cmFwKGlucHV0WzBdKSwgX3V0aWxzMi5kZWZhdWx0LndyYXAoaW5wdXRbMV0pXS5qb2luKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IGlucHV0IHZhbHVlIHRvIHBhc3NlZCB2YWx1ZSBhbmQgY2xlYXIgZXZlcnl0aGluZyBlbHNlLlxyXG4gICAgdGhpcy5faW5wdXRFbC52YWx1ZSA9IGlucHV0O1xyXG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xyXG4gICAgdGhpcy5fdHlwZWFoZWFkLnNlbGVjdGVkID0gbnVsbDtcclxuICAgIHRoaXMuX3R5cGVhaGVhZC5jbGVhcigpO1xyXG4gICAgdGhpcy5fY2hhbmdlKCk7XHJcbiAgfSxcclxuXHJcbiAgX2NsZWFyOiBmdW5jdGlvbiBfY2xlYXIoKSB7XHJcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XHJcbiAgICB0aGlzLl9pbnB1dEVsLnZhbHVlID0gJyc7XHJcbiAgICB0aGlzLl90eXBlYWhlYWQuc2VsZWN0ZWQgPSBudWxsO1xyXG4gICAgdGhpcy5fdHlwZWFoZWFkLmNsZWFyKCk7XHJcbiAgICB0aGlzLl9jaGFuZ2UoKTtcclxuICAgIHRoaXMuX2lucHV0RWwuZm9jdXMoKTtcclxuICAgIHRoaXMuX2NsZWFyRWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XHJcbiAgICB0aGlzLmZpcmUoJ2NsZWFyJyk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0UmVzdWx0OiBmdW5jdGlvbiBnZXRSZXN1bHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW5wdXQ7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0ICYgcXVlcnkgdGhlIGlucHV0XHJcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHF1ZXJ5IEFuIGFycmF5IG9mIGNvb3JkaW5hdGVzIFtsbmcsIGxhdF0gb3IgbG9jYXRpb24gbmFtZSBhcyBhIHN0cmluZy5cclxuICAgKiBAcmV0dXJucyB7R2VvY29kZXJ9IHRoaXNcclxuICAgKi9cclxuICBxdWVyeTogZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5Mikge1xyXG4gICAgdGhpcy5fcXVlcnkoX3F1ZXJ5Mik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTZXQgaW5wdXRcclxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gdmFsdWUgQW4gYXJyYXkgb2YgY29vcmRpbmF0ZXMgW2xuZywgbGF0XSBvciBsb2NhdGlvbiBuYW1lIGFzIGEgc3RyaW5nLiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24ganVzdCBzZXRzIHRoZSBpbnB1dCBhbmQgZG9lcyBub3QgdHJpZ2dlciBhbiBBUEkgcmVxdWVzdC5cclxuICAgKiBAcmV0dXJucyB7R2VvY29kZXJ9IHRoaXNcclxuICAgKi9cclxuICBzZXRJbnB1dDogZnVuY3Rpb24gc2V0SW5wdXQodmFsdWUpIHtcclxuICAgIHRoaXMuX3NldElucHV0KHZhbHVlKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YnNjcmliZSB0byBldmVudHMgdGhhdCBoYXBwZW4gd2l0aGluIHRoZSBwbHVnaW4uXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgbmFtZSBvZiBldmVudC4gQXZhaWxhYmxlIGV2ZW50cyBhbmQgdGhlIGRhdGEgcGFzc2VkIGludG8gdGhlaXIgcmVzcGVjdGl2ZSBldmVudCBvYmplY3RzIGFyZTpcclxuICAgKlxyXG4gICAqIC0gX19jbGVhcl9fIGBFbWl0dGVkIHdoZW4gdGhlIGlucHV0IGlzIGNsZWFyZWRgXHJcbiAgICogLSBfX2xvYWRpbmdfXyBgRW1pdHRlZCB3aGVuIHRoZSBnZW9jb2RlciBpcyBsb29raW5nIHVwIGEgcXVlcnlgXHJcbiAgICogLSBfX3Jlc3VsdHNfXyBgeyByZXN1bHRzIH0gRmlyZWQgd2hlbiB0aGUgZ2VvY29kZXIgcmV0dXJucyBhIHJlc3BvbnNlYFxyXG4gICAqIC0gX19yZXN1bHRfXyBgeyByZXN1bHQgfSBGaXJlZCB3aGVuIGlucHV0IGlzIHNldGBcclxuICAgKiAtIF9fZXJyb3JfXyBgeyBlcnJvciB9IEVycm9yIGFzIHN0cmluZ1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGZ1bmN0aW9uIHRoYXQncyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC5cclxuICAgKiBAcmV0dXJucyB7R2VvY29kZXJ9IHRoaXM7XHJcbiAgICovXHJcbiAgb246IGZ1bmN0aW9uIG9uKHR5cGUsIGZuKSB7XHJcbiAgICB0aGlzLl9ldi5vbih0eXBlLCBmbik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBGaXJlIGFuIGV2ZW50XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgZXZlbnQgbmFtZS5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBldmVudCBkYXRhIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uIHN1YnNjcmliZWQuXHJcbiAgICogQHJldHVybnMge0dlb2NvZGVyfSB0aGlzXHJcbiAgICovXHJcbiAgZmlyZTogZnVuY3Rpb24gZmlyZSh0eXBlLCBkYXRhKSB7XHJcbiAgICB0aGlzLl9ldi5lbWl0KHR5cGUsIGRhdGEpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFuIGV2ZW50XHJcbiAgICogQHJldHVybnMge0dlb2NvZGVyfSB0aGlzXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgRXZlbnQgbmFtZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0aGF0IHNob3VsZCB1bnN1YnNjcmliZSB0byB0aGUgZXZlbnQgZW1pdHRlZC5cclxuICAgKi9cclxuICBvZmY6IGZ1bmN0aW9uIG9mZih0eXBlLCBmbikge1xyXG4gICAgdGhpcy5fZXYucmVtb3ZlTGlzdGVuZXIodHlwZSwgZm4pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHZW9jb2RlcjtcclxuXHJcbn0se1wiLi4vdXRpbHNcIjo0MixcImV2ZW50c1wiOjEsXCJsb2Rhc2guZGVib3VuY2VcIjo1LFwic3VnZ2VzdGlvbnNcIjoyNixcInh0ZW5kXCI6MzJ9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcclxuXHJcbnZhciBfZ2VvY29kZXIgPSByZXF1aXJlKCcuL2dlb2NvZGVyJyk7XHJcblxyXG52YXIgX2dlb2NvZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dlb2NvZGVyKTtcclxuXHJcbnZhciBfbG9kYXNoID0gcmVxdWlyZSgnbG9kYXNoLnRlbXBsYXRlJyk7XHJcblxyXG52YXIgX2xvZGFzaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2Rhc2gpO1xyXG5cclxudmFyIF9sb2Rhc2gzID0gcmVxdWlyZSgnbG9kYXNoLmlzZXF1YWwnKTtcclxuXHJcbnZhciBfbG9kYXNoNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZGFzaDMpO1xyXG5cclxudmFyIF90dXJmRXh0ZW50ID0gcmVxdWlyZSgndHVyZi1leHRlbnQnKTtcclxuXHJcbnZhciBfdHVyZkV4dGVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90dXJmRXh0ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5cclxuIC8vIHN1YnN0YWNrL2JyZnMjMzlcclxudmFyIHRtcGwgPSAoMCwgX2xvZGFzaDIuZGVmYXVsdCkoXCI8ZGl2IGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1jb21wb25lbnQgbWFwYm94LWRpcmVjdGlvbnMtaW5wdXRzJz5cXG4gIDxkaXYgY2xhc3M9J21hcGJveC1kaXJlY3Rpb25zLWNvbXBvbmVudC1rZXlsaW5lJz5cXG4gICAgPGRpdiBjbGFzcz0nbWFwYm94LWRpcmVjdGlvbnMtb3JpZ2luJz5cXG4gICAgICA8bGFiZWwgY2xhc3M9J21hcGJveC1mb3JtLWxhYmVsJz5cXG4gICAgICAgIDxzcGFuIGNsYXNzPSdkaXJlY3Rpb25zLWljb24gZGlyZWN0aW9ucy1pY29uLWRlcGFydCcgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6IzkzQUZENzsnID48L3NwYW4+XFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8ZGl2IGlkPSdtYXBib3gtZGlyZWN0aW9ucy1vcmlnaW4taW5wdXQnPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGJ1dHRvblxcbiAgICAgIGNsYXNzPSdkaXJlY3Rpb25zLWljb24gZGlyZWN0aW9ucy1pY29uLXJldmVyc2UgZGlyZWN0aW9ucy1yZXZlcnNlIGpzLXJldmVyc2UtaW5wdXRzJ1xcbiAgICAgIHRpdGxlPSdSZXZlcnNlIG9yaWdpbiAmYW1wOyBkZXN0aW5hdGlvbic+XFxuICAgIDwvYnV0dG9uPlxcblxcbiAgICA8ZGl2IGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1kZXN0aW5hdGlvbic+XFxuICAgICAgPGxhYmVsIGNsYXNzPSdtYXBib3gtZm9ybS1sYWJlbCc+XFxuICAgICAgICA8c3BhbiBjbGFzcz0nZGlyZWN0aW9ucy1pY29uIGRpcmVjdGlvbnMtaWNvbi1hcnJpdmUnIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOiM2MDhCQzc7Jz48L3NwYW4+XFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8ZGl2IGlkPSdtYXBib3gtZGlyZWN0aW9ucy1kZXN0aW5hdGlvbi1pbnB1dCc+PC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1wcm9maWxlIG1hcGJveC1kaXJlY3Rpb25zLWNvbXBvbmVudC1rZXlsaW5lIG1hcGJveC1kaXJlY3Rpb25zLWNsZWFyZml4Jz4gPGlucHV0XFxuICAgICAgaWQ9J21hcGJveC1kaXJlY3Rpb25zLXByb2ZpbGUtZHJpdmluZydcXG4gICAgICB0eXBlPSdyYWRpbydcXG4gICAgICBuYW1lPSdwcm9maWxlJ1xcbiAgICAgIDwlIGlmIChwcm9maWxlID09PSAnZHJpdmluZycpIHsgJT5jaGVja2VkPCUgfSAlPlxcbiAgICAvPlxcbiAgICA8bGFiZWwgZm9yPSdtYXBib3gtZGlyZWN0aW9ucy1wcm9maWxlLWRyaXZpbmcnPkRyaXZpbmc8L2xhYmVsPlxcbiAgICA8aW5wdXRcXG4gICAgICBpZD0nbWFwYm94LWRpcmVjdGlvbnMtcHJvZmlsZS13YWxraW5nJ1xcbiAgICAgIHR5cGU9J3JhZGlvJ1xcbiAgICAgIG5hbWU9J3Byb2ZpbGUnXFxuICAgICAgPCUgaWYgKHByb2ZpbGUgPT09ICd3YWxraW5nJykgeyAlPmNoZWNrZWQ8JSB9ICU+XFxuICAgIC8+XFxuICAgIDxsYWJlbCBmb3I9J21hcGJveC1kaXJlY3Rpb25zLXByb2ZpbGUtd2Fsa2luZyc+V2Fsa2luZzwvbGFiZWw+XFxuICAgIDxpbnB1dFxcbiAgICAgIGlkPSdtYXBib3gtZGlyZWN0aW9ucy1wcm9maWxlLWN5Y2xpbmcnXFxuICAgICAgdHlwZT0ncmFkaW8nXFxuICAgICAgbmFtZT0ncHJvZmlsZSdcXG4gICAgICA8JSBpZiAocHJvZmlsZSA9PT0gJ2N5Y2xpbmcnKSB7ICU+Y2hlY2tlZDwlIH0gJT5cXG4gICAgLz5cXG4gICAgPGxhYmVsIGZvcj0nbWFwYm94LWRpcmVjdGlvbnMtcHJvZmlsZS1jeWNsaW5nJz5DeWNsaW5nPC9sYWJlbD5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiKTtcclxuXHJcbi8qKlxyXG4gKiBJbnB1dHMgY29udHJvbGxlclxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBTdW1tYXJ5IHBhcmVudCBjb250YWluZXJcclxuICogQHBhcmFtIHtPYmplY3R9IHN0b3JlIEEgcmVkdXggc3RvcmVcclxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbnMgQWN0aW9ucyBhbiBlbGVtZW50IGNhbiBkaXNwYXRjaFxyXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXBib3hnbCBpbnN0YW5jZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciBJbnB1dHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gSW5wdXRzKGVsLCBzdG9yZSwgYWN0aW9ucywgbWFwKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5wdXRzKTtcclxuXHJcbiAgICB2YXIgX3N0b3JlJGdldFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICB2YXIgb3JpZ2luUXVlcnkgPSBfc3RvcmUkZ2V0U3RhdGUub3JpZ2luUXVlcnk7XHJcbiAgICB2YXIgZGVzdGluYXRpb25RdWVyeSA9IF9zdG9yZSRnZXRTdGF0ZS5kZXN0aW5hdGlvblF1ZXJ5O1xyXG4gICAgdmFyIHByb2ZpbGUgPSBfc3RvcmUkZ2V0U3RhdGUucHJvZmlsZTtcclxuXHJcblxyXG4gICAgZWwuaW5uZXJIVE1MID0gdG1wbCh7XHJcbiAgICAgIG9yaWdpblF1ZXJ5OiBvcmlnaW5RdWVyeSxcclxuICAgICAgZGVzdGluYXRpb25RdWVyeTogZGVzdGluYXRpb25RdWVyeSxcclxuICAgICAgcHJvZmlsZTogcHJvZmlsZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5jb250YWluZXIgPSBlbDtcclxuICAgIHRoaXMuYWN0aW9ucyA9IGFjdGlvbnM7XHJcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XHJcbiAgICB0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG4gICAgdGhpcy5vbkFkZCgpO1xyXG4gICAgdGhpcy5yZW5kZXIoKTtcclxuICB9XHJcblxyXG4gIF9jcmVhdGVDbGFzcyhJbnB1dHMsIFt7XHJcbiAgICBrZXk6ICdhbmltYXRlVG9Db29yZGluYXRlcycsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZVRvQ29vcmRpbmF0ZXMobW9kZSwgY29vcmRzKSB7XHJcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUyID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgdmFyIG9yaWdpbiA9IF9zdG9yZSRnZXRTdGF0ZTIub3JpZ2luO1xyXG4gICAgICB2YXIgZGVzdGluYXRpb24gPSBfc3RvcmUkZ2V0U3RhdGUyLmRlc3RpbmF0aW9uO1xyXG5cclxuXHJcbiAgICAgIGlmIChvcmlnaW4uZ2VvbWV0cnkgJiYgZGVzdGluYXRpb24uZ2VvbWV0cnkgJiYgISgwLCBfbG9kYXNoNC5kZWZhdWx0KShvcmlnaW4uZ2VvbWV0cnksIGRlc3RpbmF0aW9uLmdlb21ldHJ5KSkge1xyXG5cclxuICAgICAgICAvLyBBbmltYXRlIG1hcCB0byBmaXQgYm91bmRzLlxyXG4gICAgICAgIHZhciBiYiA9ICgwLCBfdHVyZkV4dGVudDIuZGVmYXVsdCkoe1xyXG4gICAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuICAgICAgICAgIGZlYXR1cmVzOiBbb3JpZ2luLCBkZXN0aW5hdGlvbl1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5fbWFwLmZpdEJvdW5kcyhbW2JiWzBdLCBiYlsxXV0sIFtiYlsyXSwgYmJbM11dXSwgeyBwYWRkaW5nOiA4MCB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9tYXAuZmx5VG8oeyBjZW50ZXI6IGNvb3JkcyB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ29uQWRkJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkFkZCgpIHtcclxuICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgIHZhciBfYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcclxuICAgICAgdmFyIGNsZWFyT3JpZ2luID0gX2FjdGlvbnMuY2xlYXJPcmlnaW47XHJcbiAgICAgIHZhciBjbGVhckRlc3RpbmF0aW9uID0gX2FjdGlvbnMuY2xlYXJEZXN0aW5hdGlvbjtcclxuICAgICAgdmFyIGNyZWF0ZU9yaWdpbiA9IF9hY3Rpb25zLmNyZWF0ZU9yaWdpbjtcclxuICAgICAgdmFyIGNyZWF0ZURlc3RpbmF0aW9uID0gX2FjdGlvbnMuY3JlYXRlRGVzdGluYXRpb247XHJcbiAgICAgIHZhciBzZXRQcm9maWxlID0gX2FjdGlvbnMuc2V0UHJvZmlsZTtcclxuICAgICAgdmFyIHJldmVyc2UgPSBfYWN0aW9ucy5yZXZlcnNlO1xyXG5cclxuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZTMgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgICB2YXIgZ2VvY29kZXIgPSBfc3RvcmUkZ2V0U3RhdGUzLmdlb2NvZGVyO1xyXG4gICAgICB2YXIgYWNjZXNzVG9rZW4gPSBfc3RvcmUkZ2V0U3RhdGUzLmFjY2Vzc1Rva2VuO1xyXG5cclxuXHJcbiAgICAgIHRoaXMub3JpZ2luSW5wdXQgPSBuZXcgX2dlb2NvZGVyMi5kZWZhdWx0KE9iamVjdC5hc3NpZ24oe30sIHtcclxuICAgICAgICBmbHlUbzogZmFsc2UsXHJcbiAgICAgICAgcGxhY2Vob2xkZXI6ICdTdGFydG9ydCcsXHJcbiAgICAgICAgYWNjZXNzVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgIH0sIGdlb2NvZGVyKSk7XHJcblxyXG4gICAgICB2YXIgb3JpZ2luRWwgPSB0aGlzLm9yaWdpbklucHV0Lm9uQWRkKCk7XHJcbiAgICAgIHZhciBvcmlnaW5Db250YWluZXJFbCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNtYXBib3gtZGlyZWN0aW9ucy1vcmlnaW4taW5wdXQnKTtcclxuICAgICAgb3JpZ2luQ29udGFpbmVyRWwuYXBwZW5kQ2hpbGQob3JpZ2luRWwpO1xyXG5cclxuICAgICAgdGhpcy5kZXN0aW5hdGlvbklucHV0ID0gbmV3IF9nZW9jb2RlcjIuZGVmYXVsdChPYmplY3QuYXNzaWduKHt9LCB7XHJcbiAgICAgICAgZmx5VG86IGZhbHNlLFxyXG4gICAgICAgIHBsYWNlaG9sZGVyOiAnWmllbG9ydCcsXHJcbiAgICAgICAgYWNjZXNzVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgIH0sIGdlb2NvZGVyKSk7XHJcblxyXG4gICAgICB2YXIgZGVzdGluYXRpb25FbCA9IHRoaXMuZGVzdGluYXRpb25JbnB1dC5vbkFkZCgpO1xyXG4gICAgICB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjbWFwYm94LWRpcmVjdGlvbnMtZGVzdGluYXRpb24taW5wdXQnKS5hcHBlbmRDaGlsZChkZXN0aW5hdGlvbkVsKTtcclxuXHJcbiAgICAgIHRoaXMub3JpZ2luSW5wdXQub24oJ3Jlc3VsdCcsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIGNvb3JkcyA9IGUucmVzdWx0LmNlbnRlcjtcclxuICAgICAgICBjcmVhdGVPcmlnaW4oY29vcmRzKTtcclxuICAgICAgICBfdGhpcy5hbmltYXRlVG9Db29yZGluYXRlcygnb3JpZ2luJywgY29vcmRzKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLm9yaWdpbklucHV0Lm9uKCdjbGVhcicsIGNsZWFyT3JpZ2luKTtcclxuXHJcbiAgICAgIHRoaXMuZGVzdGluYXRpb25JbnB1dC5vbigncmVzdWx0JywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB2YXIgY29vcmRzID0gZS5yZXN1bHQuY2VudGVyO1xyXG4gICAgICAgIGNyZWF0ZURlc3RpbmF0aW9uKGNvb3Jkcyk7XHJcbiAgICAgICAgX3RoaXMuYW5pbWF0ZVRvQ29vcmRpbmF0ZXMoJ2Rlc3RpbmF0aW9uJywgY29vcmRzKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmRlc3RpbmF0aW9uSW5wdXQub24oJ2NsZWFyJywgY2xlYXJEZXN0aW5hdGlvbik7XHJcblxyXG4gICAgICAvLyBEcml2aW5nIC8gV2Fsa2luZyAvIEN5Y2xpbmcgcHJvZmlsZXNcclxuICAgICAgdmFyIHByb2ZpbGVzID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdJyk7XHJcbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwocHJvZmlsZXMsIGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHNldFByb2ZpbGUoZWwuaWQucmVwbGFjZSgnbWFwYm94LWRpcmVjdGlvbnMtcHJvZmlsZS0nLCAnJykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFJldmVyc2luZyBPcmlnaW4gLyBEZXN0aW5hdGlvblxyXG4gICAgICB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuanMtcmV2ZXJzZS1pbnB1dHMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlNCA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgICAgIHZhciBvcmlnaW4gPSBfc3RvcmUkZ2V0U3RhdGU0Lm9yaWdpbjtcclxuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSBfc3RvcmUkZ2V0U3RhdGU0LmRlc3RpbmF0aW9uO1xyXG5cclxuICAgICAgICBpZiAob3JpZ2luKSBfdGhpcy5hY3Rpb25zLnF1ZXJ5RGVzdGluYXRpb24ob3JpZ2luLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuICAgICAgICBpZiAoZGVzdGluYXRpb24pIF90aGlzLmFjdGlvbnMucXVlcnlPcmlnaW4oZGVzdGluYXRpb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG4gICAgICAgIHJldmVyc2UoKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAncmVuZGVyJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cclxuICAgICAgdGhpcy5zdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGU1ID0gX3RoaXMyLnN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgICAgIHZhciBvcmlnaW5RdWVyeSA9IF9zdG9yZSRnZXRTdGF0ZTUub3JpZ2luUXVlcnk7XHJcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uUXVlcnkgPSBfc3RvcmUkZ2V0U3RhdGU1LmRlc3RpbmF0aW9uUXVlcnk7XHJcbiAgICAgICAgdmFyIG9yaWdpblF1ZXJ5Q29vcmRpbmF0ZXMgPSBfc3RvcmUkZ2V0U3RhdGU1Lm9yaWdpblF1ZXJ5Q29vcmRpbmF0ZXM7XHJcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uUXVlcnlDb29yZGluYXRlcyA9IF9zdG9yZSRnZXRTdGF0ZTUuZGVzdGluYXRpb25RdWVyeUNvb3JkaW5hdGVzO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKG9yaWdpblF1ZXJ5KSB7XHJcbiAgICAgICAgICBfdGhpczIub3JpZ2luSW5wdXQucXVlcnkob3JpZ2luUXVlcnkpO1xyXG4gICAgICAgICAgX3RoaXMyLmFjdGlvbnMucXVlcnlPcmlnaW4obnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGVzdGluYXRpb25RdWVyeSkge1xyXG4gICAgICAgICAgX3RoaXMyLmRlc3RpbmF0aW9uSW5wdXQucXVlcnkoZGVzdGluYXRpb25RdWVyeSk7XHJcbiAgICAgICAgICBfdGhpczIuYWN0aW9ucy5xdWVyeURlc3RpbmF0aW9uKG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9yaWdpblF1ZXJ5Q29vcmRpbmF0ZXMpIHtcclxuICAgICAgICAgIF90aGlzMi5vcmlnaW5JbnB1dC5zZXRJbnB1dChvcmlnaW5RdWVyeUNvb3JkaW5hdGVzKTtcclxuICAgICAgICAgIF90aGlzMi5hbmltYXRlVG9Db29yZGluYXRlcygnb3JpZ2luJywgb3JpZ2luUXVlcnlDb29yZGluYXRlcyk7XHJcbiAgICAgICAgICBfdGhpczIuYWN0aW9ucy5xdWVyeU9yaWdpbkNvb3JkaW5hdGVzKG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uUXVlcnlDb29yZGluYXRlcykge1xyXG4gICAgICAgICAgX3RoaXMyLmRlc3RpbmF0aW9uSW5wdXQuc2V0SW5wdXQoZGVzdGluYXRpb25RdWVyeUNvb3JkaW5hdGVzKTtcclxuICAgICAgICAgIF90aGlzMi5hbmltYXRlVG9Db29yZGluYXRlcygnZGVzdGluYXRpb24nLCBkZXN0aW5hdGlvblF1ZXJ5Q29vcmRpbmF0ZXMpO1xyXG4gICAgICAgICAgX3RoaXMyLmFjdGlvbnMucXVlcnlEZXN0aW5hdGlvbkNvb3JkaW5hdGVzKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG5cclxuICByZXR1cm4gSW5wdXRzO1xyXG59KCk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBJbnB1dHM7XHJcblxyXG59LHtcIi4vZ2VvY29kZXJcIjozNSxcImxvZGFzaC5pc2VxdWFsXCI6NixcImxvZGFzaC50ZW1wbGF0ZVwiOjcsXCJ0dXJmLWV4dGVudFwiOjMwfV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XHJcblxyXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxuXHJcbnZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xyXG5cclxudmFyIF9sb2Rhc2ggPSByZXF1aXJlKCdsb2Rhc2gudGVtcGxhdGUnKTtcclxuXHJcbnZhciBfbG9kYXNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZGFzaCk7XHJcblxyXG52YXIgX2xvZGFzaDMgPSByZXF1aXJlKCdsb2Rhc2guaXNlcXVhbCcpO1xyXG5cclxudmFyIF9sb2Rhc2g0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9kYXNoMyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbiAvLyBzdWJzdGFjay9icmZzIzM5XHJcbnZhciBpbnN0cnVjdGlvbnNUZW1wbGF0ZSA9ICgwLCBfbG9kYXNoMi5kZWZhdWx0KShcIjxkaXYgY2xhc3M9J2RpcmVjdGlvbnMtY29udHJvbCBkaXJlY3Rpb25zLWNvbnRyb2wtZGlyZWN0aW9ucyc+XFxuICA8ZGl2IGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1jb21wb25lbnQgbWFwYm94LWRpcmVjdGlvbnMtcm91dGUtc3VtbWFyeTwlIGlmIChyb3V0ZXMgPiAxKSB7ICU+IG1hcGJveC1kaXJlY3Rpb25zLW11bHRpcGxlPCUgfSAlPic+XFxuICAgIDwlIGlmIChyb3V0ZXMgPiAxKSB7ICU+XFxuICAgIDxkaXYgY2xhc3M9J21hcGJveC1kaXJlY3Rpb25zLXJvdXRlcyBtYXBib3gtZGlyZWN0aW9ucy1jbGVhcmZpeCc+XFxuICAgICAgPCUgZm9yICh2YXIgaSA9IDA7IGkgPCByb3V0ZXM7IGkrKykgeyAlPlxcbiAgICAgICAgPGlucHV0IHR5cGU9J3JhZGlvJyBuYW1lPSdyb3V0ZXMnIGlkPSc8JT0gaSAlPicgPCUgaWYgKGkgPT09IHJvdXRlSW5kZXgpIHsgJT5jaGVja2VkPCUgfSAlPj5cXG4gICAgICAgIDxsYWJlbCBmb3I9JzwlPSBpICU+JyBjbGFzcz0nbWFwYm94LWRpcmVjdGlvbnMtcm91dGUnPjwlPSBpICsgMSAlPjwvbGFiZWw+XFxuICAgICAgPCUgfSAlPlxcbiAgICA8L2Rpdj5cXG4gICAgPCUgfSAlPlxcbiAgICA8aDE+PCUtIGR1cmF0aW9uICU+PC9oMT5cXG4gICAgPHNwYW4+PCUtIGRpc3RhbmNlICU+PC9zcGFuPlxcbiAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1pbnN0cnVjdGlvbnMnPlxcbiAgICA8ZGl2IGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1pbnN0cnVjdGlvbnMtd3JhcHBlcic+XFxuICAgICAgPG9sIGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1zdGVwcyc+XFxuICAgICAgICA8JSBzdGVwcy5mb3JFYWNoKGZ1bmN0aW9uKHN0ZXApIHsgJT5cXG4gICAgICAgICAgPCVcXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBzdGVwLmRpc3RhbmNlID8gZm9ybWF0KHN0ZXAuZGlzdGFuY2UpIDogZmFsc2U7XFxuICAgICAgICAgICAgdmFyIGljb24gPSBzdGVwLm1hbmV1dmVyLm1vZGlmaWVyID8gc3RlcC5tYW5ldXZlci5tb2RpZmllci5yZXBsYWNlKC9cXFxccysvZywgJy0nKS50b0xvd2VyQ2FzZSgpIDogc3RlcC5tYW5ldXZlci50eXBlLnJlcGxhY2UoL1xcXFxzKy9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XFxuXFxuICAgICAgICAgICAgaWYgKHN0ZXAubWFuZXV2ZXIudHlwZSA9PT0gJ2Fycml2ZScgfHwgc3RlcC5tYW5ldXZlci50eXBlID09PSAnZGVwYXJ0Jykge1xcbiAgICAgICAgICAgICAgaWNvbiA9IHN0ZXAubWFuZXV2ZXIudHlwZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHN0ZXAubWFuZXV2ZXIudHlwZSA9PT0gJ3JvdW5kYWJvdXQnIHx8IHN0ZXAubWFuZXV2ZXIudHlwZSA9PT0gJ3JvdGFyeScpIHtcXG4gICAgICAgICAgICAgIGljb249ICdyb3VuZGFib3V0JztcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdmFyIGxuZyA9IHN0ZXAubWFuZXV2ZXIubG9jYXRpb25bMF07XFxuICAgICAgICAgICAgdmFyIGxhdCA9IHN0ZXAubWFuZXV2ZXIubG9jYXRpb25bMV07XFxuICAgICAgICAgICU+XFxuICAgICAgICAgIDxsaVxcbiAgICAgICAgICAgIGRhdGEtbGF0PSc8JT0gbGF0ICU+J1xcbiAgICAgICAgICAgIGRhdGEtbG5nPSc8JT0gbG5nICU+J1xcbiAgICAgICAgICAgIGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1zdGVwJz5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz0nZGlyZWN0aW9ucy1pY29uIGRpcmVjdGlvbnMtaWNvbi08JT0gaWNvbiAlPic+PC9zcGFuPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J21hcGJveC1kaXJlY3Rpb25zLXN0ZXAtbWFuZXV2ZXInPlxcbiAgICAgICAgICAgICAgPCU9IHN0ZXAubWFuZXV2ZXIuaW5zdHJ1Y3Rpb24gJT5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8JSBpZiAoZGlzdGFuY2UpIHsgJT5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9J21hcGJveC1kaXJlY3Rpb25zLXN0ZXAtZGlzdGFuY2UnPlxcbiAgICAgICAgICAgICAgICA8JT0gZGlzdGFuY2UgJT5cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwlIH0gJT5cXG4gICAgICAgICAgPC9saT5cXG4gICAgICAgIDwlIH0pOyAlPlxcbiAgICAgIDwvb2w+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCIpO1xyXG52YXIgZXJyb3JUZW1wbGF0ZSA9ICgwLCBfbG9kYXNoMi5kZWZhdWx0KShcIjxkaXYgY2xhc3M9J2RpcmVjdGlvbnMtY29udHJvbCBkaXJlY3Rpb25zLWNvbnRyb2wtZGlyZWN0aW9ucyc+XFxuICA8ZGl2IGNsYXNzPSdtYXBib3gtZGlyZWN0aW9ucy1lcnJvcic+XFxuICAgIDwlPSBlcnJvciAlPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCIpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTdW1tYXJ5L0luc3RydWN0aW9ucyBjb250cm9sbGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFN1bW1hcnkgcGFyZW50IGNvbnRhaW5lclxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RvcmUgQSByZWR1eCBzdG9yZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9ucyBBY3Rpb25zIGFuIGVsZW1lbnQgY2FuIGRpc3BhdGNoXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcGJveGdsIGluc3RhbmNlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxudmFyIEluc3RydWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBJbnN0cnVjdGlvbnMoZWwsIHN0b3JlLCBhY3Rpb25zLCBtYXApIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnN0cnVjdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuY29udGFpbmVyID0gZWw7XHJcbiAgICB0aGlzLmFjdGlvbnMgPSBhY3Rpb25zO1xyXG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xyXG4gICAgdGhpcy5fbWFwID0gbWFwO1xyXG4gICAgdGhpcy5kaXJlY3Rpb25zID0ge307XHJcbiAgICB0aGlzLnJlbmRlcigpO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUNsYXNzKEluc3RydWN0aW9ucywgW3tcclxuICAgIGtleTogJ3JlbmRlcicsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgdGhpcy5zdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYWN0aW9ucyA9IF90aGlzLmFjdGlvbnM7XHJcbiAgICAgICAgdmFyIGhvdmVyTWFya2VyID0gX2FjdGlvbnMuaG92ZXJNYXJrZXI7XHJcbiAgICAgICAgdmFyIHNldFJvdXRlSW5kZXggPSBfYWN0aW9ucy5zZXRSb3V0ZUluZGV4O1xyXG5cclxuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgICAgdmFyIHJvdXRlSW5kZXggPSBfc3RvcmUkZ2V0U3RhdGUucm91dGVJbmRleDtcclxuICAgICAgICB2YXIgdW5pdCA9IF9zdG9yZSRnZXRTdGF0ZS51bml0O1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb25zID0gX3N0b3JlJGdldFN0YXRlLmRpcmVjdGlvbnM7XHJcbiAgICAgICAgdmFyIGVycm9yID0gX3N0b3JlJGdldFN0YXRlLmVycm9yO1xyXG5cclxuICAgICAgICB2YXIgc2hvdWxkUmVuZGVyID0gISgwLCBfbG9kYXNoNC5kZWZhdWx0KShkaXJlY3Rpb25zW3JvdXRlSW5kZXhdLCBfdGhpcy5kaXJlY3Rpb25zKTtcclxuXHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICBfdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gZXJyb3JUZW1wbGF0ZSh7IGVycm9yOiBlcnJvciB9KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkaXJlY3Rpb25zLmxlbmd0aCAmJiBzaG91bGRSZW5kZXIpIHtcclxuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBfdGhpcy5kaXJlY3Rpb25zID0gZGlyZWN0aW9uc1tyb3V0ZUluZGV4XTtcclxuICAgICAgICAgIF90aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSBpbnN0cnVjdGlvbnNUZW1wbGF0ZSh7XHJcbiAgICAgICAgICAgIHJvdXRlSW5kZXg6IHJvdXRlSW5kZXgsXHJcbiAgICAgICAgICAgIHJvdXRlczogZGlyZWN0aW9ucy5sZW5ndGgsXHJcbiAgICAgICAgICAgIHN0ZXBzOiBkaXJlY3Rpb24ubGVnc1swXS5zdGVwcywgLy8gVG9kbzogUmVzcGVjdCBhbGwgbGVncyxcclxuICAgICAgICAgICAgZm9ybWF0OiBfdXRpbHMyLmRlZmF1bHQuZm9ybWF0W3VuaXRdLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogX3V0aWxzMi5kZWZhdWx0LmZvcm1hdFt1bml0XShkaXJlY3Rpb24uZGlzdGFuY2UpLFxyXG4gICAgICAgICAgICBkaXN0YW5jZTogX3V0aWxzMi5kZWZhdWx0LmZvcm1hdC5kdXJhdGlvbihkaXJlY3Rpb24uZHVyYXRpb24pXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICB2YXIgc3RlcHMgPSBfdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLm1hcGJveC1kaXJlY3Rpb25zLXN0ZXAnKTtcclxuXHJcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHN0ZXBzLCBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgdmFyIGxuZyA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1sbmcnKTtcclxuICAgICAgICAgICAgdmFyIGxhdCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1sYXQnKTtcclxuXHJcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBob3Zlck1hcmtlcihbbG5nLCBsYXRdKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBob3Zlck1hcmtlcihudWxsKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBfdGhpcy5fbWFwLmZseVRvKHtcclxuICAgICAgICAgICAgICAgIGNlbnRlcjogW2xuZywgbGF0XSxcclxuICAgICAgICAgICAgICAgIHpvb206IDE2XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdmFyIHJvdXRlcyA9IF90aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKTtcclxuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwocm91dGVzLCBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICBzZXRSb3V0ZUluZGV4KHBhcnNlSW50KGUudGFyZ2V0LmlkLCAxMCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuY29udGFpbmVyLmlubmVySFRNTCAmJiBzaG91bGRSZW5kZXIpIHtcclxuICAgICAgICAgIF90aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1dKTtcclxuXHJcbiAgcmV0dXJuIEluc3RydWN0aW9ucztcclxufSgpO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gSW5zdHJ1Y3Rpb25zO1xyXG5cclxufSx7XCIuLi91dGlsc1wiOjQyLFwibG9kYXNoLmlzZXF1YWxcIjo2LFwibG9kYXNoLnRlbXBsYXRlXCI6N31dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xyXG5cclxudmFyIF9yZWR1eCA9IHJlcXVpcmUoJ3JlZHV4Jyk7XHJcblxyXG52YXIgX3JlZHV4VGh1bmsgPSByZXF1aXJlKCdyZWR1eC10aHVuaycpO1xyXG5cclxudmFyIF9yZWR1eFRodW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlZHV4VGh1bmspO1xyXG5cclxudmFyIF9wb2x5bGluZSA9IHJlcXVpcmUoJ3BvbHlsaW5lJyk7XHJcblxyXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG5cclxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XHJcblxyXG52YXIgX3JlZHVjZXJzID0gcmVxdWlyZSgnLi9yZWR1Y2VycycpO1xyXG5cclxudmFyIF9yZWR1Y2VyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWR1Y2Vycyk7XHJcblxyXG52YXIgX2FjdGlvbnMgPSByZXF1aXJlKCcuL2FjdGlvbnMnKTtcclxuXHJcbnZhciBhY3Rpb25zID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2FjdGlvbnMpO1xyXG5cclxudmFyIF9kaXJlY3Rpb25zX3N0eWxlID0gcmVxdWlyZSgnLi9kaXJlY3Rpb25zX3N0eWxlJyk7XHJcblxyXG52YXIgX2RpcmVjdGlvbnNfc3R5bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlyZWN0aW9uc19zdHlsZSk7XHJcblxyXG52YXIgX2lucHV0cyA9IHJlcXVpcmUoJy4vY29udHJvbHMvaW5wdXRzJyk7XHJcblxyXG52YXIgX2lucHV0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnB1dHMpO1xyXG5cclxudmFyIF9pbnN0cnVjdGlvbnMgPSByZXF1aXJlKCcuL2NvbnRyb2xzL2luc3RydWN0aW9ucycpO1xyXG5cclxudmFyIF9pbnN0cnVjdGlvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5zdHJ1Y3Rpb25zKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbnZhciBzdG9yZVdpdGhNaWRkbGV3YXJlID0gKDAsIF9yZWR1eC5hcHBseU1pZGRsZXdhcmUpKF9yZWR1eFRodW5rMi5kZWZhdWx0KShfcmVkdXguY3JlYXRlU3RvcmUpO1xyXG52YXIgc3RvcmUgPSBzdG9yZVdpdGhNaWRkbGV3YXJlKF9yZWR1Y2VyczIuZGVmYXVsdCk7XHJcblxyXG4vLyBTdGF0ZSBvYmplY3QgbWFuYWdlbWVudCB2aWEgcmVkdXhcclxuXHJcblxyXG4vLyBDb250cm9sc1xyXG5cclxuLyoqXHJcbiAqIFRoZSBEaXJlY3Rpb25zIGNvbnRyb2xcclxuICogQGNsYXNzIE1hcGJveERpcmVjdGlvbnNcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuc3R5bGVzXSBPdmVycmlkZSBkZWZhdWx0IGxheWVyIHByb3BlcnRpZXMgb2YgdGhlIFtkaXJlY3Rpb25zIHNvdXJjZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtZGlyZWN0aW9ucy9ibG9iL21hc3Rlci9zcmMvZGlyZWN0aW9uc19zdHlsZS5qcykuIERvY3VtZW50YXRpb24gZm9yIGVhY2ggcHJvcGVydHkgYXJlIHNwZWNpZmllZCBpbiB0aGUgW01hcGJveCBHTCBTdHlsZSBSZWZlcmVuY2VdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvKS5cclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFjY2Vzc1Rva2VuPW51bGxdIFJlcXVpcmVkIHVubGVzcyBgbWFwYm94Z2wuYWNjZXNzVG9rZW5gIGlzIHNldCBnbG9iYWxseVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmludGVyYWN0aXZlPXRydWVdIEVuYWJsZS9EaXNhYmxlIG1vdXNlIG9yIHRvdWNoIGludGVyYWN0aXZpdHkgZnJvbSB0aGUgcGx1Z2luXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm9maWxlPVwiZHJpdmluZy10cmFmZmljXCJdIFJvdXRpbmcgcHJvZmlsZSB0byB1c2UuIE9wdGlvbnM6IGBkcml2aW5nLXRyYWZmaWNgLCBgZHJpdmluZ2AsIGB3YWxraW5nYCwgYGN5Y2xpbmdgXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy51bml0PVwiaW1wZXJpYWxcIl0gTWVhc3VyZW1lbnQgc3lzdGVtIHRvIGJlIHVzZWQgaW4gbmF2aWdhdGlvbiBpbnN0cnVjdGlvbnMuIE9wdGlvbnM6IGBpbXBlcmlhbGAsIGBtZXRyaWNgXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5nZW9jb2Rlcl0gUGFzcyBvcHRpb25zIGF2YWlsYWJsZSB0byBtYXBib3gtZ2wtZ2VvY29kZXIgYXMgW2RvY3VtZW50ZWQgaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtZ2VvY29kZXIvYmxvYi9tYXN0ZXIvQVBJLm1kI21hcGJveGdsZ2VvY29kZXIpLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY29udHJvbHNdXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29udHJvbHMuaW5wdXRzPXRydWVdIEhpZGUgb3IgZGlzcGxheSB0aGUgaW5wdXRzIGNvbnRyb2wuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29udHJvbHMuaW5zdHJ1Y3Rpb25zPXRydWVdIEhpZGUgb3IgZGlzcGxheSB0aGUgaW5zdHJ1Y3Rpb25zIGNvbnRyb2wuXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBNYXBib3hEaXJlY3Rpb25zID0gcmVxdWlyZSgnLi4vc3JjL2luZGV4Jyk7XHJcbiAqIHZhciBkaXJlY3Rpb25zID0gbmV3IE1hcGJveERpcmVjdGlvbnMoe1xyXG4gKiAgIGFjY2Vzc1Rva2VuOiAnWU9VUi1NQVBCT1gtQUNDRVNTLVRPS0VOJyxcclxuICogICB1bml0OiAnbWV0cmljJyxcclxuICogICBwcm9maWxlOiAnY3ljbGluZydcclxuICogfSk7XHJcbiAqIC8vIGFkZCB0byB5b3VyIG1hcGJveGdsIG1hcFxyXG4gKiBtYXAuYWRkQ29udHJvbChkaXJlY3Rpb25zKTtcclxuICpcclxuICogQHJldHVybiB7TWFwYm94RGlyZWN0aW9uc30gYHRoaXNgXHJcbiAqL1xyXG52YXIgTWFwYm94RGlyZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBNYXBib3hEaXJlY3Rpb25zKG9wdGlvbnMpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXBib3hEaXJlY3Rpb25zKTtcclxuXHJcbiAgICB0aGlzLmFjdGlvbnMgPSAoMCwgX3JlZHV4LmJpbmRBY3Rpb25DcmVhdG9ycykoYWN0aW9ucywgc3RvcmUuZGlzcGF0Y2gpO1xyXG4gICAgdGhpcy5hY3Rpb25zLnNldE9wdGlvbnMob3B0aW9ucyB8fCB7fSk7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIHRoaXMub25EcmFnRG93biA9IHRoaXMuX29uRHJhZ0Rvd24uYmluZCh0aGlzKTtcclxuICAgIHRoaXMub25EcmFnTW92ZSA9IHRoaXMuX29uRHJhZ01vdmUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMub25EcmFnVXAgPSB0aGlzLl9vbkRyYWdVcC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5tb3ZlID0gdGhpcy5fbW92ZS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUNsYXNzKE1hcGJveERpcmVjdGlvbnMsIFt7XHJcbiAgICBrZXk6ICdvbkFkZCcsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25BZGQobWFwKSB7XHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICB0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIHZhciBjb250cm9scyA9IF9zdG9yZSRnZXRTdGF0ZS5jb250cm9scztcclxuXHJcblxyXG4gICAgICB2YXIgZWwgPSB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICBlbC5jbGFzc05hbWUgPSAnbWFwYm94Z2wtY3RybC1kaXJlY3Rpb25zIG1hcGJveGdsLWN0cmwnO1xyXG5cclxuICAgICAgLy8gQWRkIGNvbnRyb2xzIHRvIHRoZSBwYWdlXHJcbiAgICAgIHZhciBpbnB1dEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIGlucHV0RWwuY2xhc3NOYW1lID0gJ2RpcmVjdGlvbnMtY29udHJvbCBkaXJlY3Rpb25zLWNvbnRyb2wtaW5wdXRzJztcclxuICAgICAgbmV3IF9pbnB1dHMyLmRlZmF1bHQoaW5wdXRFbCwgc3RvcmUsIHRoaXMuYWN0aW9ucywgdGhpcy5fbWFwKTtcclxuXHJcbiAgICAgIHZhciBkaXJlY3Rpb25zRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgZGlyZWN0aW9uc0VsLmNsYXNzTmFtZSA9ICdkaXJlY3Rpb25zLWNvbnRyb2wgZGlyZWN0aW9ucy1jb250cm9sLWluc3RydWN0aW9ucyc7XHJcblxyXG4gICAgICBuZXcgX2luc3RydWN0aW9uczIuZGVmYXVsdChkaXJlY3Rpb25zRWwsIHN0b3JlLCB7XHJcbiAgICAgICAgaG92ZXJNYXJrZXI6IHRoaXMuYWN0aW9ucy5ob3Zlck1hcmtlcixcclxuICAgICAgICBzZXRSb3V0ZUluZGV4OiB0aGlzLmFjdGlvbnMuc2V0Um91dGVJbmRleFxyXG4gICAgICB9LCB0aGlzLl9tYXApO1xyXG5cclxuICAgICAgaWYgKGNvbnRyb2xzLmlucHV0cykgZWwuYXBwZW5kQ2hpbGQoaW5wdXRFbCk7XHJcbiAgICAgIGlmIChjb250cm9scy5pbnN0cnVjdGlvbnMpIGVsLmFwcGVuZENoaWxkKGRpcmVjdGlvbnNFbCk7XHJcblxyXG4gICAgICB0aGlzLnN1YnNjcmliZWRBY3Rpb25zKCk7XHJcbiAgICAgIGlmICh0aGlzLl9tYXAubG9hZGVkKCkpIHRoaXMubWFwU3RhdGUoKTtlbHNlIHRoaXMuX21hcC5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXMubWFwU3RhdGUoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gZWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBoYXMgYmVlbiBhZGRlZCB0by4gVGhpcyBpcyBjYWxsZWQgYnkgYG1hcC5yZW1vdmVDb250cm9sYCxcclxuICAgICAqIHdoaWNoIGlzIHRoZSByZWNvbW1lbmRlZCBtZXRob2QgdG8gcmVtb3ZlIGNvbnRyb2xzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtDb250cm9sfSBgdGhpc2BcclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6ICdvblJlbW92ZScsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25SZW1vdmUobWFwKSB7XHJcbiAgICAgIHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIpO1xyXG4gICAgICB0aGlzLnJlbW92ZVJvdXRlcygpO1xyXG4gICAgICBtYXAub2ZmKCdtb3VzZWRvd24nLCB0aGlzLm9uRHJhZ0Rvd24pO1xyXG4gICAgICBtYXAub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLm1vdmUpO1xyXG4gICAgICBtYXAub2ZmKCd0b3VjaHN0YXJ0JywgdGhpcy5vbkRyYWdEb3duKTtcclxuICAgICAgbWFwLm9mZigndG91Y2hzdGFydCcsIHRoaXMubW92ZSk7XHJcbiAgICAgIG1hcC5vZmYoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcclxuICAgICAgaWYgKHRoaXMuc3RvcmVVbnN1YnNjcmliZSkge1xyXG4gICAgICAgIHRoaXMuc3RvcmVVbnN1YnNjcmliZSgpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JlVW5zdWJzY3JpYmU7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fbWFwID0gbnVsbDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnbWFwU3RhdGUnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcFN0YXRlKCkge1xyXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHJcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUyID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIHZhciBwcm9maWxlID0gX3N0b3JlJGdldFN0YXRlMi5wcm9maWxlO1xyXG4gICAgICB2YXIgc3R5bGVzID0gX3N0b3JlJGdldFN0YXRlMi5zdHlsZXM7XHJcbiAgICAgIHZhciBpbnRlcmFjdGl2ZSA9IF9zdG9yZSRnZXRTdGF0ZTIuaW50ZXJhY3RpdmU7XHJcblxyXG4gICAgICAvLyBFbWl0IGFueSBkZWZhdWx0IG9yIG9wdGlvbiBzZXQgY29uZmlnXHJcblxyXG4gICAgICB0aGlzLmFjdGlvbnMuZXZlbnRFbWl0KCdwcm9maWxlJywgeyBwcm9maWxlOiBwcm9maWxlIH0pO1xyXG5cclxuICAgICAgdmFyIGdlb2pzb24gPSB7XHJcbiAgICAgICAgdHlwZTogJ2dlb2pzb24nLFxyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcbiAgICAgICAgICBmZWF0dXJlczogW11cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBBZGQgYW5kIHNldCBkYXRhIHRoZW1lIGxheWVyL3N0eWxlXHJcbiAgICAgIHRoaXMuX21hcC5hZGRTb3VyY2UoJ2RpcmVjdGlvbnMnLCBnZW9qc29uKTtcclxuXHJcbiAgICAgIC8vIEFkZCBkaXJlY3Rpb24gc3BlY2lmaWMgc3R5bGVzIHRvIHRoZSBtYXBcclxuICAgICAgX2RpcmVjdGlvbnNfc3R5bGUyLmRlZmF1bHQuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXMyLl9tYXAuYWRkTGF5ZXIoc3R5bGUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChzdHlsZXMgJiYgc3R5bGVzLmxlbmd0aCkgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzMi5fbWFwLmFkZExheWVyKHN0eWxlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoaW50ZXJhY3RpdmUpIHtcclxuICAgICAgICB0aGlzLl9tYXAub24oJ21vdXNlZG93bicsIHRoaXMub25EcmFnRG93bik7XHJcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLm1vdmUpO1xyXG4gICAgICAgIHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xyXG5cclxuICAgICAgICB0aGlzLl9tYXAub24oJ3RvdWNoc3RhcnQnLCB0aGlzLm1vdmUpO1xyXG4gICAgICAgIHRoaXMuX21hcC5vbigndG91Y2hzdGFydCcsIHRoaXMub25EcmFnRG93bik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdzdWJzY3JpYmVkQWN0aW9ucycsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlZEFjdGlvbnMoKSB7XHJcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xyXG5cclxuICAgICAgdGhpcy5zdG9yZVVuc3Vic2NyaWJlID0gc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlMyA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgICAgIHZhciBvcmlnaW4gPSBfc3RvcmUkZ2V0U3RhdGUzLm9yaWdpbjtcclxuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSBfc3RvcmUkZ2V0U3RhdGUzLmRlc3RpbmF0aW9uO1xyXG4gICAgICAgIHZhciBob3Zlck1hcmtlciA9IF9zdG9yZSRnZXRTdGF0ZTMuaG92ZXJNYXJrZXI7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbnMgPSBfc3RvcmUkZ2V0U3RhdGUzLmRpcmVjdGlvbnM7XHJcbiAgICAgICAgdmFyIHJvdXRlSW5kZXggPSBfc3RvcmUkZ2V0U3RhdGUzLnJvdXRlSW5kZXg7XHJcblxyXG5cclxuICAgICAgICB2YXIgZ2VvanNvbiA9IHtcclxuICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcbiAgICAgICAgICBmZWF0dXJlczogW29yaWdpbiwgZGVzdGluYXRpb24sIGhvdmVyTWFya2VyXS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQuZ2VvbWV0cnk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChkaXJlY3Rpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgZGlyZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlLCBpbmRleCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxpbmVTdHJpbmcgPSB7XHJcbiAgICAgICAgICAgICAgZ2VvbWV0cnk6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcclxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiAoMCwgX3BvbHlsaW5lLmRlY29kZSkoZmVhdHVyZS5nZW9tZXRyeSwgNSkubWFwKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICAncm91dGUtaW5kZXgnOiBpbmRleCxcclxuICAgICAgICAgICAgICAgIHJvdXRlOiBpbmRleCA9PT0gcm91dGVJbmRleCA/ICdzZWxlY3RlZCcgOiAnYWx0ZXJuYXRlJ1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGdlb2pzb24uZmVhdHVyZXMucHVzaChsaW5lU3RyaW5nKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSByb3V0ZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgLy8gQ29sbGVjdCBhbnkgcG9zc2libGUgd2F5cG9pbnRzIGZyb20gc3RlcHNcclxuICAgICAgICAgICAgICBmZWF0dXJlLmxlZ3NbMF0uc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGQubWFuZXV2ZXIudHlwZSA9PT0gJ3dheXBvaW50Jykge1xyXG4gICAgICAgICAgICAgICAgICBnZW9qc29uLmZlYXR1cmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeTogZC5tYW5ldXZlci5sb2NhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZDogJ3dheXBvaW50J1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKF90aGlzMy5fbWFwLnN0eWxlICYmIF90aGlzMy5fbWFwLmdldFNvdXJjZSgnZGlyZWN0aW9ucycpKSB7XHJcbiAgICAgICAgICBfdGhpczMuX21hcC5nZXRTb3VyY2UoJ2RpcmVjdGlvbnMnKS5zZXREYXRhKGdlb2pzb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnX29uQ2xpY2snLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNsaWNrKGUpIHtcclxuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlNCA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgICB2YXIgb3JpZ2luID0gX3N0b3JlJGdldFN0YXRlNC5vcmlnaW47XHJcblxyXG4gICAgICB2YXIgY29vcmRzID0gW2UubG5nTGF0LmxuZywgZS5sbmdMYXQubGF0XTtcclxuXHJcbiAgICAgIGlmICghb3JpZ2luLmdlb21ldHJ5KSB7XHJcbiAgICAgICAgdGhpcy5hY3Rpb25zLnNldE9yaWdpbkZyb21Db29yZGluYXRlcyhjb29yZHMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLl9tYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGUucG9pbnQsIHtcclxuICAgICAgICAgIGxheWVyczogWydkaXJlY3Rpb25zLW9yaWdpbi1wb2ludCcsICdkaXJlY3Rpb25zLWRlc3RpbmF0aW9uLXBvaW50JywgJ2RpcmVjdGlvbnMtd2F5cG9pbnQtcG9pbnQnLCAnZGlyZWN0aW9ucy1yb3V0ZS1saW5lLWFsdCddXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChmZWF0dXJlcy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgYW55IHdheXBvaW50c1xyXG4gICAgICAgICAgZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xyXG4gICAgICAgICAgICBpZiAoZi5sYXllci5pZCA9PT0gJ2RpcmVjdGlvbnMtd2F5cG9pbnQtcG9pbnQnKSB7XHJcbiAgICAgICAgICAgICAgX3RoaXM0LmFjdGlvbnMucmVtb3ZlV2F5cG9pbnQoZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmIChmZWF0dXJlc1swXS5wcm9wZXJ0aWVzLnJvdXRlID09PSAnYWx0ZXJuYXRlJykge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBmZWF0dXJlc1swXS5wcm9wZXJ0aWVzWydyb3V0ZS1pbmRleCddO1xyXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMuc2V0Um91dGVJbmRleChpbmRleCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuYWN0aW9ucy5zZXREZXN0aW5hdGlvbkZyb21Db29yZGluYXRlcyhjb29yZHMpO1xyXG4gICAgICAgICAgdGhpcy5fbWFwLmZseVRvKHsgY2VudGVyOiBjb29yZHMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnX21vdmUnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlKGUpIHtcclxuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlNSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcblxyXG4gICAgICB2YXIgaG92ZXJNYXJrZXIgPSBfc3RvcmUkZ2V0U3RhdGU1LmhvdmVyTWFya2VyO1xyXG5cclxuXHJcbiAgICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuX21hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoZS5wb2ludCwge1xyXG4gICAgICAgIGxheWVyczogWydkaXJlY3Rpb25zLXJvdXRlLWxpbmUtYWx0JywgJ2RpcmVjdGlvbnMtcm91dGUtbGluZScsICdkaXJlY3Rpb25zLW9yaWdpbi1wb2ludCcsICdkaXJlY3Rpb25zLWRlc3RpbmF0aW9uLXBvaW50JywgJ2RpcmVjdGlvbnMtaG92ZXItcG9pbnQnXVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuX21hcC5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSBmZWF0dXJlcy5sZW5ndGggPyAncG9pbnRlcicgOiAnJztcclxuXHJcbiAgICAgIGlmIChmZWF0dXJlcy5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmlzQ3Vyc29yT3ZlclBvaW50ID0gZmVhdHVyZXNbMF07XHJcbiAgICAgICAgdGhpcy5fbWFwLmRyYWdQYW4uZGlzYWJsZSgpO1xyXG5cclxuICAgICAgICAvLyBBZGQgYSBwb3NzaWJsZSB3YXlwb2ludCBtYXJrZXIgd2hlbiBob3ZlcmluZyBvdmVyIHRoZSBhY3RpdmUgcm91dGUgbGluZVxyXG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICAgICAgICAgIGlmIChmZWF0dXJlLmxheWVyLmlkID09PSAnZGlyZWN0aW9ucy1yb3V0ZS1saW5lJykge1xyXG4gICAgICAgICAgICBfdGhpczUuYWN0aW9ucy5ob3Zlck1hcmtlcihbZS5sbmdMYXQubG5nLCBlLmxuZ0xhdC5sYXRdKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaG92ZXJNYXJrZXIuZ2VvbWV0cnkpIHtcclxuICAgICAgICAgICAgX3RoaXM1LmFjdGlvbnMuaG92ZXJNYXJrZXIobnVsbCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0N1cnNvck92ZXJQb2ludCkge1xyXG4gICAgICAgIHRoaXMuaXNDdXJzb3JPdmVyUG9pbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9tYXAuZHJhZ1Bhbi5lbmFibGUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogJ19vbkRyYWdEb3duJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25EcmFnRG93bigpIHtcclxuICAgICAgaWYgKCF0aGlzLmlzQ3Vyc29yT3ZlclBvaW50KSByZXR1cm47XHJcbiAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRoaXMuaXNDdXJzb3JPdmVyUG9pbnQ7XHJcbiAgICAgIHRoaXMuX21hcC5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSAnZ3JhYic7XHJcblxyXG4gICAgICB0aGlzLl9tYXAub24oJ21vdXNlbW92ZScsIHRoaXMub25EcmFnTW92ZSk7XHJcbiAgICAgIHRoaXMuX21hcC5vbignbW91c2V1cCcsIHRoaXMub25EcmFnVXApO1xyXG5cclxuICAgICAgdGhpcy5fbWFwLm9uKCd0b3VjaG1vdmUnLCB0aGlzLm9uRHJhZ01vdmUpO1xyXG4gICAgICB0aGlzLl9tYXAub24oJ3RvdWNoZW5kJywgdGhpcy5vbkRyYWdVcCk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiAnX29uRHJhZ01vdmUnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRyYWdNb3ZlKGUpIHtcclxuICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHJldHVybjtcclxuXHJcbiAgICAgIHZhciBjb29yZHMgPSBbZS5sbmdMYXQubG5nLCBlLmxuZ0xhdC5sYXRdO1xyXG4gICAgICBzd2l0Y2ggKHRoaXMuaXNEcmFnZ2luZy5sYXllci5pZCkge1xyXG4gICAgICAgIGNhc2UgJ2RpcmVjdGlvbnMtb3JpZ2luLXBvaW50JzpcclxuICAgICAgICAgIHRoaXMuYWN0aW9ucy5jcmVhdGVPcmlnaW4oY29vcmRzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2RpcmVjdGlvbnMtZGVzdGluYXRpb24tcG9pbnQnOlxyXG4gICAgICAgICAgdGhpcy5hY3Rpb25zLmNyZWF0ZURlc3RpbmF0aW9uKGNvb3Jkcyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkaXJlY3Rpb25zLWhvdmVyLXBvaW50JzpcclxuICAgICAgICAgIHRoaXMuYWN0aW9ucy5ob3Zlck1hcmtlcihjb29yZHMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6ICdfb25EcmFnVXAnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRyYWdVcCgpIHtcclxuICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHJldHVybjtcclxuXHJcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGU2ID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIHZhciBob3Zlck1hcmtlciA9IF9zdG9yZSRnZXRTdGF0ZTYuaG92ZXJNYXJrZXI7XHJcbiAgICAgIHZhciBvcmlnaW4gPSBfc3RvcmUkZ2V0U3RhdGU2Lm9yaWdpbjtcclxuICAgICAgdmFyIGRlc3RpbmF0aW9uID0gX3N0b3JlJGdldFN0YXRlNi5kZXN0aW5hdGlvbjtcclxuXHJcblxyXG4gICAgICBzd2l0Y2ggKHRoaXMuaXNEcmFnZ2luZy5sYXllci5pZCkge1xyXG4gICAgICAgIGNhc2UgJ2RpcmVjdGlvbnMtb3JpZ2luLXBvaW50JzpcclxuICAgICAgICAgIHRoaXMuYWN0aW9ucy5zZXRPcmlnaW5Gcm9tQ29vcmRpbmF0ZXMob3JpZ2luLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2RpcmVjdGlvbnMtZGVzdGluYXRpb24tcG9pbnQnOlxyXG4gICAgICAgICAgdGhpcy5hY3Rpb25zLnNldERlc3RpbmF0aW9uRnJvbUNvb3JkaW5hdGVzKGRlc3RpbmF0aW9uLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2RpcmVjdGlvbnMtaG92ZXItcG9pbnQnOlxyXG4gICAgICAgICAgLy8gQWRkIHdheXBvaW50IGlmIGEgc3VmZmljZW50IGFtb3VudCBvZiBkcmFnZ2luZyBoYXMgb2NjdXJyZWQuXHJcbiAgICAgICAgICBpZiAoaG92ZXJNYXJrZXIuZ2VvbWV0cnkgJiYgIV91dGlsczIuZGVmYXVsdC5jb29yZGluYXRlTWF0Y2godGhpcy5pc0RyYWdnaW5nLCBob3Zlck1hcmtlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmFkZFdheXBvaW50KDAsIGhvdmVyTWFya2VyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fbWFwLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9ICcnO1xyXG5cclxuICAgICAgdGhpcy5fbWFwLm9mZigndG91Y2htb3ZlJywgdGhpcy5vbkRyYWdNb3ZlKTtcclxuICAgICAgdGhpcy5fbWFwLm9mZigndG91Y2hlbmQnLCB0aGlzLm9uRHJhZ1VwKTtcclxuXHJcbiAgICAgIHRoaXMuX21hcC5vZmYoJ21vdXNlbW92ZScsIHRoaXMub25EcmFnTW92ZSk7XHJcbiAgICAgIHRoaXMuX21hcC5vZmYoJ21vdXNldXAnLCB0aGlzLm9uRHJhZ1VwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBUEkgTWV0aG9kc1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVybiBvbiBvciBvZmYgaW50ZXJhY3Rpdml0eVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdGF0ZSBzZXRzIGludGVyYWN0aXZpdHkgYmFzZWQgb24gYSBzdGF0ZSBvZiBgdHJ1ZWAgb3IgYGZhbHNlYC5cclxuICAgICAqIEByZXR1cm5zIHtNYXBib3hEaXJlY3Rpb25zfSB0aGlzXHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnaW50ZXJhY3RpdmUnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyYWN0aXZlKHN0YXRlKSB7XHJcbiAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuX21hcC5vbigndG91Y2hzdGFydCcsIHRoaXMubW92ZSk7XHJcbiAgICAgICAgdGhpcy5fbWFwLm9uKCd0b3VjaHN0YXJ0JywgdGhpcy5vbkRyYWdEb3duKTtcclxuXHJcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3VzZWRvd24nLCB0aGlzLm9uRHJhZ0Rvd24pO1xyXG4gICAgICAgIHRoaXMuX21hcC5vbignbW91c2Vtb3ZlJywgdGhpcy5tb3ZlKTtcclxuICAgICAgICB0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9tYXAub2ZmKCd0b3VjaHN0YXJ0JywgdGhpcy5tb3ZlKTtcclxuICAgICAgICB0aGlzLl9tYXAub2ZmKCd0b3VjaHN0YXJ0JywgdGhpcy5vbkRyYWdEb3duKTtcclxuXHJcbiAgICAgICAgdGhpcy5fbWFwLm9mZignbW91c2Vkb3duJywgdGhpcy5vbkRyYWdEb3duKTtcclxuICAgICAgICB0aGlzLl9tYXAub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLm1vdmUpO1xyXG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBvcmlnaW4gb2YgdGhlIGN1cnJlbnQgcm91dGUuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvcmlnaW5cclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6ICdnZXRPcmlnaW4nLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9yaWdpbigpIHtcclxuICAgICAgcmV0dXJuIHN0b3JlLmdldFN0YXRlKCkub3JpZ2luO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBvcmlnaW4uIF9Ob3RlOl8gY2FsbGluZyB0aGlzIG1ldGhvZCByZXF1aXJlcyB0aGUgW21hcCBsb2FkIGV2ZW50XShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvI01hcC5sb2FkKVxyXG4gICAgICogdG8gaGF2ZSBydW4uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj58U3RyaW5nfSBxdWVyeSBBbiBhcnJheSBvZiBjb29yZGluYXRlcyBbbG5nLCBsYXRdIG9yIGxvY2F0aW9uIG5hbWUgYXMgYSBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7TWFwYm94RGlyZWN0aW9uc30gdGhpc1xyXG4gICAgICovXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogJ3NldE9yaWdpbicsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3JpZ2luKHF1ZXJ5KSB7XHJcbiAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhpcy5hY3Rpb25zLnF1ZXJ5T3JpZ2luKHF1ZXJ5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmFjdGlvbnMuc2V0T3JpZ2luRnJvbUNvb3JkaW5hdGVzKHF1ZXJ5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgY3VycmVudCByb3V0ZS5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RpbmF0aW9uXHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnZ2V0RGVzdGluYXRpb24nLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlc3RpbmF0aW9uKCkge1xyXG4gICAgICByZXR1cm4gc3RvcmUuZ2V0U3RhdGUoKS5kZXN0aW5hdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgZGVzdGluYXRpb24uIF9Ob3RlOl8gY2FsbGluZyB0aGlzIG1ldGhvZCByZXF1aXJlcyB0aGUgW21hcCBsb2FkIGV2ZW50XShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvI01hcC5sb2FkKVxyXG4gICAgICogdG8gaGF2ZSBydW4uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj58U3RyaW5nfSBxdWVyeSBBbiBhcnJheSBvZiBjb29yZGluYXRlcyBbbG5nLCBsYXRdIG9yIGxvY2F0aW9uIG5hbWUgYXMgYSBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7TWFwYm94RGlyZWN0aW9uc30gdGhpc1xyXG4gICAgICovXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogJ3NldERlc3RpbmF0aW9uJyxcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREZXN0aW5hdGlvbihxdWVyeSkge1xyXG4gICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRoaXMuYWN0aW9ucy5xdWVyeURlc3RpbmF0aW9uKHF1ZXJ5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmFjdGlvbnMuc2V0RGVzdGluYXRpb25Gcm9tQ29vcmRpbmF0ZXMocXVlcnkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3YXAgdGhlIG9yaWdpbiBhbmQgZGVzdGluYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7TWFwYm94RGlyZWN0aW9uc30gdGhpc1xyXG4gICAgICovXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogJ3JldmVyc2UnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XHJcbiAgICAgIHRoaXMuYWN0aW9ucy5yZXZlcnNlKCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgd2F5cG9pbnQgdG8gdGhlIHJvdXRlLiBfTm90ZTpfIGNhbGxpbmcgdGhpcyBtZXRob2QgcmVxdWlyZXMgdGhlXHJcbiAgICAgKiBbbWFwIGxvYWQgZXZlbnRdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLWpzL2FwaS8jTWFwLmxvYWQpIHRvIGhhdmUgcnVuLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IHBvc2l0aW9uIHdheXBvaW50IHNob3VsZCBiZSBwbGFjZWQgaW4gdGhlIHdheXBvaW50IGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj58UG9pbnR9IHdheXBvaW50IGNhbiBiZSBhIEdlb0pTT04gUG9pbnQgRmVhdHVyZSBvciBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHJldHVybnMge01hcGJveERpcmVjdGlvbnN9IHRoaXM7XHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnYWRkV2F5cG9pbnQnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFdheXBvaW50KGluZGV4LCB3YXlwb2ludCkge1xyXG4gICAgICBpZiAoIXdheXBvaW50LnR5cGUpIHdheXBvaW50ID0gX3V0aWxzMi5kZWZhdWx0LmNyZWF0ZVBvaW50KHdheXBvaW50LCB7IGlkOiAnd2F5cG9pbnQnIH0pO1xyXG4gICAgICB0aGlzLmFjdGlvbnMuYWRkV2F5cG9pbnQoaW5kZXgsIHdheXBvaW50KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgdGhlIHdheXBvaW50IGF0IGEgZ2l2ZW4gaW5kZXggaW4gdGhlIHJvdXRlLiBfTm90ZTpfIGNhbGxpbmcgdGhpc1xyXG4gICAgICogbWV0aG9kIHJlcXVpcmVzIHRoZSBbbWFwIGxvYWQgZXZlbnRdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLWpzL2FwaS8jTWFwLmxvYWQpXHJcbiAgICAgKiB0byBoYXZlIHJ1bi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBpbmRleGVkIHBvc2l0aW9uIG9mIHRoZSB3YXlwb2ludCB0byB1cGRhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPnxQb2ludH0gd2F5cG9pbnQgY2FuIGJlIGEgR2VvSlNPTiBQb2ludCBGZWF0dXJlIG9yIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7TWFwYm94RGlyZWN0aW9uc30gdGhpcztcclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6ICdzZXRXYXlwb2ludCcsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0V2F5cG9pbnQoaW5kZXgsIHdheXBvaW50KSB7XHJcbiAgICAgIGlmICghd2F5cG9pbnQudHlwZSkgd2F5cG9pbnQgPSBfdXRpbHMyLmRlZmF1bHQuY3JlYXRlUG9pbnQod2F5cG9pbnQsIHsgaWQ6ICd3YXlwb2ludCcgfSk7XHJcbiAgICAgIHRoaXMuYWN0aW9ucy5zZXRXYXlwb2ludChpbmRleCwgd2F5cG9pbnQpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIHdheXBvaW50IGZyb20gdGhlIHJvdXRlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IHBvc2l0aW9uIGluIHRoZSB3YXlwb2ludHMgYXJyYXkuXHJcbiAgICAgKiBAcmV0dXJucyB7TWFwYm94RGlyZWN0aW9uc30gdGhpcztcclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6ICdyZW1vdmVXYXlwb2ludCcsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlV2F5cG9pbnQoaW5kZXgpIHtcclxuICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZTcgPSBzdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgICAgdmFyIHdheXBvaW50cyA9IF9zdG9yZSRnZXRTdGF0ZTcud2F5cG9pbnRzO1xyXG5cclxuICAgICAgdGhpcy5hY3Rpb25zLnJlbW92ZVdheXBvaW50KHdheXBvaW50c1tpbmRleF0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoIGFsbCBjdXJyZW50IHdheXBvaW50cyBpbiBhIHJvdXRlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSB3YXlwb2ludHNcclxuICAgICAqL1xyXG5cclxuICB9LHtcclxuICAgIGtleTogJ2dldERpc3RhbmNlQW5kRHVyYXRpb24nLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlQW5kRHVyYXRpb24oKSB7XHJcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGU4ID0gc3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgaWYoX3N0b3JlJGdldFN0YXRlOCA9PT0gbnVsbCl7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGRpcmVjdGlvbnMgPSBfc3RvcmUkZ2V0U3RhdGU4LmRpcmVjdGlvbnM7XHJcbiAgICAgIHZhciByb3V0ZUluZGV4ID0gX3N0b3JlJGdldFN0YXRlOC5yb3V0ZUluZGV4O1xyXG4gICAgICB2YXIgdW5pdCA9IF9zdG9yZSRnZXRTdGF0ZTgudW5pdDtcclxuXHJcbiAgICAgIGlmKGRpcmVjdGlvbnNbcm91dGVJbmRleF0gPT09IG51bGwpe1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgdmFyIGR1cmF0aW9uID0gX3V0aWxzMi5kZWZhdWx0LmZvcm1hdC5kdXJhdGlvbihkaXJlY3Rpb25zW3JvdXRlSW5kZXhdLmR1cmF0aW9uKTtcclxuICAgICAgdmFyIGRpc3RhbmNlID0gX3V0aWxzMi5kZWZhdWx0LmZvcm1hdFt1bml0XShkaXJlY3Rpb25zW3JvdXRlSW5kZXhdLmRpc3RhbmNlKTtcclxuXHJcbiAgICAgIHJldHVybiB7ZHVyYXRpb24sIGRpc3RhbmNlfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIHJvdXRlcyBhbmQgd2F5cG9pbnRzIGZyb20gdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7TWFwYm94RGlyZWN0aW9uc30gdGhpcztcclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6ICdnZXRXYXlwb2ludHMnLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdheXBvaW50cygpIHtcclxuICAgICAgcmV0dXJuIHN0b3JlLmdldFN0YXRlKCkud2F5cG9pbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgcm91dGVzIGFuZCB3YXlwb2ludHMgZnJvbSB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtNYXBib3hEaXJlY3Rpb25zfSB0aGlzO1xyXG4gICAgICovXHJcblxyXG4gIH0sIHtcclxuICAgIGtleTogJ3JlbW92ZVJvdXRlcycsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlUm91dGVzKCkge1xyXG4gICAgICB0aGlzLmFjdGlvbnMuY2xlYXJPcmlnaW4oKTtcclxuICAgICAgdGhpcy5hY3Rpb25zLmNsZWFyRGVzdGluYXRpb24oKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgdG8gZXZlbnRzIHRoYXQgaGFwcGVuIHdpdGhpbiB0aGUgcGx1Z2luLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgbmFtZSBvZiBldmVudC4gQXZhaWxhYmxlIGV2ZW50cyBhbmQgdGhlIGRhdGEgcGFzc2VkIGludG8gdGhlaXIgcmVzcGVjdGl2ZSBldmVudCBvYmplY3RzIGFyZTpcclxuICAgICAqXHJcbiAgICAgKiAtIF9fY2xlYXJfXyBgeyB0eXBlOiB9IFR5cGUgaXMgb25lIG9mICdvcmlnaW4nIG9yICdkZXN0aW5hdGlvbidgXHJcbiAgICAgKiAtIF9fbG9hZGluZ19fIGB7IHR5cGU6IH0gVHlwZSBpcyBvbmUgb2YgJ29yaWdpbicgb3IgJ2Rlc3RpbmF0aW9uJ2BcclxuICAgICAqIC0gX19wcm9maWxlX18gYHsgcHJvZmlsZSB9IFByb2ZpbGUgaXMgb25lIG9mICdkcml2aW5nJywgJ3dhbGtpbmcnLCBvciAnY3ljbGluZydgXHJcbiAgICAgKiAtIF9fb3JpZ2luX18gYHsgZmVhdHVyZSB9IEZpcmVkIHdoZW4gb3JpZ2luIGlzIHNldGBcclxuICAgICAqIC0gX19kZXN0aW5hdGlvbl9fIGB7IGZlYXR1cmUgfSBGaXJlZCB3aGVuIGRlc3RpbmF0aW9uIGlzIHNldGBcclxuICAgICAqIC0gX19yb3V0ZV9fIGB7IHJvdXRlIH0gRmlyZWQgd2hlbiBhIHJvdXRlIGlzIHVwZGF0ZWRgXHJcbiAgICAgKiAtIF9fZXJyb3JfXyBgeyBlcnJvciB9IEVycm9yIGFzIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gZnVuY3Rpb24gdGhhdCdzIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge01hcGJveERpcmVjdGlvbnN9IHRoaXM7XHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiAnb24nLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKHR5cGUsIGZuKSB7XHJcbiAgICAgIHRoaXMuYWN0aW9ucy5ldmVudFN1YnNjcmliZSh0eXBlLCBmbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH1dKTtcclxuXHJcbiAgcmV0dXJuIE1hcGJveERpcmVjdGlvbnM7XHJcbn0oKTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1hcGJveERpcmVjdGlvbnM7XHJcblxyXG59LHtcIi4vYWN0aW9uc1wiOjMzLFwiLi9jb250cm9scy9pbnB1dHNcIjozNixcIi4vY29udHJvbHMvaW5zdHJ1Y3Rpb25zXCI6MzcsXCIuL2RpcmVjdGlvbnNfc3R5bGVcIjozOSxcIi4vcmVkdWNlcnNcIjo0MSxcIi4vdXRpbHNcIjo0MixcInBvbHlsaW5lXCI6MTAsXCJyZWR1eFwiOjE3LFwicmVkdXgtdGh1bmtcIjoxMX1dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbnZhciBzdHlsZSA9IFt7XHJcbiAgJ2lkJzogJ2RpcmVjdGlvbnMtcm91dGUtbGluZS1hbHQnLFxyXG4gICd0eXBlJzogJ2xpbmUnLFxyXG4gICdzb3VyY2UnOiAnZGlyZWN0aW9ucycsXHJcbiAgJ2xheW91dCc6IHtcclxuICAgICdsaW5lLWNhcCc6ICdyb3VuZCcsXHJcbiAgICAnbGluZS1qb2luJzogJ3JvdW5kJ1xyXG4gIH0sXHJcbiAgJ3BhaW50Jzoge1xyXG4gICAgJ2xpbmUtY29sb3InOiAnI2JiYicsXHJcbiAgICAnbGluZS13aWR0aCc6IDRcclxuICB9LFxyXG4gICdmaWx0ZXInOiBbJ2FsbCcsIFsnaW4nLCAnJHR5cGUnLCAnTGluZVN0cmluZyddLCBbJ2luJywgJ3JvdXRlJywgJ2FsdGVybmF0ZSddXVxyXG59LCB7XHJcbiAgJ2lkJzogJ2RpcmVjdGlvbnMtcm91dGUtbGluZScsXHJcbiAgJ3R5cGUnOiAnbGluZScsXHJcbiAgJ3NvdXJjZSc6ICdkaXJlY3Rpb25zJyxcclxuICAnbGF5b3V0Jzoge1xyXG4gICAgJ2xpbmUtY2FwJzogJ3JvdW5kJyxcclxuICAgICdsaW5lLWpvaW4nOiAncm91bmQnXHJcbiAgfSxcclxuICAncGFpbnQnOiB7XHJcbiAgICAnbGluZS1jb2xvcic6ICcjNjA4QkM3JyxcclxuICAgICdsaW5lLXdpZHRoJzogNFxyXG4gIH0sXHJcbiAgJ2ZpbHRlcic6IFsnYWxsJywgWydpbicsICckdHlwZScsICdMaW5lU3RyaW5nJ10sIFsnaW4nLCAncm91dGUnLCAnc2VsZWN0ZWQnXV1cclxufSwge1xyXG4gICdpZCc6ICdkaXJlY3Rpb25zLWhvdmVyLXBvaW50LWNhc2luZycsXHJcbiAgJ3R5cGUnOiAnY2lyY2xlJyxcclxuICAnc291cmNlJzogJ2RpcmVjdGlvbnMnLFxyXG4gICdwYWludCc6IHtcclxuICAgICdjaXJjbGUtcmFkaXVzJzogOCxcclxuICAgICdjaXJjbGUtY29sb3InOiAnI2ZmZidcclxuICB9LFxyXG4gICdmaWx0ZXInOiBbJ2FsbCcsIFsnaW4nLCAnJHR5cGUnLCAnUG9pbnQnXSwgWydpbicsICdpZCcsICdob3ZlciddXVxyXG59LCB7XHJcbiAgJ2lkJzogJ2RpcmVjdGlvbnMtaG92ZXItcG9pbnQnLFxyXG4gICd0eXBlJzogJ2NpcmNsZScsXHJcbiAgJ3NvdXJjZSc6ICdkaXJlY3Rpb25zJyxcclxuICAncGFpbnQnOiB7XHJcbiAgICAnY2lyY2xlLXJhZGl1cyc6IDYsXHJcbiAgICAnY2lyY2xlLWNvbG9yJzogJyMzYmIyZDAnXHJcbiAgfSxcclxuICAnZmlsdGVyJzogWydhbGwnLCBbJ2luJywgJyR0eXBlJywgJ1BvaW50J10sIFsnaW4nLCAnaWQnLCAnaG92ZXInXV1cclxufSwge1xyXG4gICdpZCc6ICdkaXJlY3Rpb25zLXdheXBvaW50LXBvaW50LWNhc2luZycsXHJcbiAgJ3R5cGUnOiAnY2lyY2xlJyxcclxuICAnc291cmNlJzogJ2RpcmVjdGlvbnMnLFxyXG4gICdwYWludCc6IHtcclxuICAgICdjaXJjbGUtcmFkaXVzJzogOCxcclxuICAgICdjaXJjbGUtY29sb3InOiAnI2ZmZidcclxuICB9LFxyXG4gICdmaWx0ZXInOiBbJ2FsbCcsIFsnaW4nLCAnJHR5cGUnLCAnUG9pbnQnXSwgWydpbicsICdpZCcsICd3YXlwb2ludCddXVxyXG59LCB7XHJcbiAgJ2lkJzogJ2RpcmVjdGlvbnMtd2F5cG9pbnQtcG9pbnQnLFxyXG4gICd0eXBlJzogJ2NpcmNsZScsXHJcbiAgJ3NvdXJjZSc6ICdkaXJlY3Rpb25zJyxcclxuICAncGFpbnQnOiB7XHJcbiAgICAnY2lyY2xlLXJhZGl1cyc6IDYsXHJcbiAgICAnY2lyY2xlLWNvbG9yJzogJyM2MDhCQzcnXHJcbiAgfSxcclxuICAnZmlsdGVyJzogWydhbGwnLCBbJ2luJywgJyR0eXBlJywgJ1BvaW50J10sIFsnaW4nLCAnaWQnLCAnd2F5cG9pbnQnXV1cclxufSwge1xyXG4gICdpZCc6ICdkaXJlY3Rpb25zLW9yaWdpbi1wb2ludCcsXHJcbiAgJ3R5cGUnOiAnY2lyY2xlJyxcclxuICAnc291cmNlJzogJ2RpcmVjdGlvbnMnLFxyXG4gICdwYWludCc6IHtcclxuICAgICdjaXJjbGUtcmFkaXVzJzogMTgsXHJcbiAgICAnY2lyY2xlLWNvbG9yJzogJyM5M0FGRDcnXHJcbiAgfSxcclxuICAnZmlsdGVyJzogWydhbGwnLCBbJ2luJywgJyR0eXBlJywgJ1BvaW50J10sIFsnaW4nLCAnbWFya2VyLXN5bWJvbCcsICdBJ11dXHJcbn0sIHtcclxuICAnaWQnOiAnZGlyZWN0aW9ucy1vcmlnaW4tbGFiZWwnLFxyXG4gICd0eXBlJzogJ3N5bWJvbCcsXHJcbiAgJ3NvdXJjZSc6ICdkaXJlY3Rpb25zJyxcclxuICAnbGF5b3V0Jzoge1xyXG4gICAgJ3RleHQtZmllbGQnOiAnQScsXHJcbiAgICAndGV4dC1mb250JzogWydPcGVuIFNhbnMgQm9sZCcsICdBcmlhbCBVbmljb2RlIE1TIEJvbGQnXSxcclxuICAgICd0ZXh0LXNpemUnOiAxMlxyXG4gIH0sXHJcbiAgJ3BhaW50Jzoge1xyXG4gICAgJ3RleHQtY29sb3InOiAnI2ZmZidcclxuICB9LFxyXG4gICdmaWx0ZXInOiBbJ2FsbCcsIFsnaW4nLCAnJHR5cGUnLCAnUG9pbnQnXSwgWydpbicsICdtYXJrZXItc3ltYm9sJywgJ0EnXV1cclxufSwge1xyXG4gICdpZCc6ICdkaXJlY3Rpb25zLWRlc3RpbmF0aW9uLXBvaW50JyxcclxuICAndHlwZSc6ICdjaXJjbGUnLFxyXG4gICdzb3VyY2UnOiAnZGlyZWN0aW9ucycsXHJcbiAgJ3BhaW50Jzoge1xyXG4gICAgJ2NpcmNsZS1yYWRpdXMnOiAxOCxcclxuICAgICdjaXJjbGUtY29sb3InOiAnIzYwOEJDNydcclxuICB9LFxyXG4gICdmaWx0ZXInOiBbJ2FsbCcsIFsnaW4nLCAnJHR5cGUnLCAnUG9pbnQnXSwgWydpbicsICdtYXJrZXItc3ltYm9sJywgJ0InXV1cclxufSwge1xyXG4gICdpZCc6ICdkaXJlY3Rpb25zLWRlc3RpbmF0aW9uLWxhYmVsJyxcclxuICAndHlwZSc6ICdzeW1ib2wnLFxyXG4gICdzb3VyY2UnOiAnZGlyZWN0aW9ucycsXHJcbiAgJ2xheW91dCc6IHtcclxuICAgICd0ZXh0LWZpZWxkJzogJ0InLFxyXG4gICAgJ3RleHQtZm9udCc6IFsnT3BlbiBTYW5zIEJvbGQnLCAnQXJpYWwgVW5pY29kZSBNUyBCb2xkJ10sXHJcbiAgICAndGV4dC1zaXplJzogMTJcclxuICB9LFxyXG4gICdwYWludCc6IHtcclxuICAgICd0ZXh0LWNvbG9yJzogJyNmZmYnXHJcbiAgfSxcclxuICAnZmlsdGVyJzogWydhbGwnLCBbJ2luJywgJyR0eXBlJywgJ1BvaW50J10sIFsnaW4nLCAnbWFya2VyLXN5bWJvbCcsICdCJ11dXHJcbn1dO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gc3R5bGU7XHJcblxyXG59LHt9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfZGlyZWN0aW9ucyA9IHJlcXVpcmUoJy4vZGlyZWN0aW9ucycpO1xyXG5cclxudmFyIF9kaXJlY3Rpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RpcmVjdGlvbnMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX2RpcmVjdGlvbnMyLmRlZmF1bHQ7XHJcblxyXG59LHtcIi4vZGlyZWN0aW9uc1wiOjM4fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfYWN0aW9uX3R5cGVzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL2FjdGlvbl90eXBlcy5qcycpO1xyXG5cclxudmFyIHR5cGVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2FjdGlvbl90eXBlcyk7XHJcblxyXG52YXIgX2RlZXBBc3NpZ24gPSByZXF1aXJlKCdkZWVwLWFzc2lnbicpO1xyXG5cclxudmFyIF9kZWVwQXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBBc3NpZ24pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XHJcblxyXG52YXIgaW5pdGlhbFN0YXRlID0ge1xyXG4gIC8vIE9wdGlvbnMgc2V0IG9uIGluaXRpYWxpemF0aW9uXHJcbiAgYXBpOiAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9kaXJlY3Rpb25zL3Y1LycsXHJcbiAgcHJvZmlsZTogJ2RyaXZpbmctdHJhZmZpYycsXHJcbiAgdW5pdDogJ2ltcGVyaWFsJyxcclxuICBwcm94aW1pdHk6IGZhbHNlLFxyXG4gIHN0eWxlczogW10sXHJcblxyXG4gIC8vIFVJIGNvbnRyb2xzXHJcbiAgY29udHJvbHM6IHtcclxuICAgIGlucHV0czogdHJ1ZSxcclxuICAgIGluc3RydWN0aW9uczogdHJ1ZVxyXG4gIH0sXHJcblxyXG4gIC8vIE9wdGlvbmFsIHNldHRpbmcgdG8gcGFzcyBvcHRpb25zIGF2YWlsYWJsZSB0byBtYXBib3gtZ2wtZ2VvY29kZXJcclxuICBnZW9jb2Rlcjoge30sXHJcblxyXG4gIGludGVyYWN0aXZlOiB0cnVlLFxyXG5cclxuICAvLyBDb250YWluZXIgZm9yIGNsaWVudCByZWdpc3RlcmVkIGV2ZW50c1xyXG4gIGV2ZW50czoge30sXHJcblxyXG4gIC8vIE1hcmtlciBmZWF0dXJlIGRyYXduIG9uIHRoZSBtYXAgYXQgYW55IHBvaW50LlxyXG4gIG9yaWdpbjoge30sXHJcbiAgZGVzdGluYXRpb246IHt9LFxyXG4gIGhvdmVyTWFya2VyOiB7fSxcclxuICB3YXlwb2ludHM6IFtdLFxyXG5cclxuICAvLyBVc2VyIGlucHV0IHN0cmluZ3Mgb3IgcmVzdWx0IHJldHVybmVkIGZyb20gZ2VvY29kZXJcclxuICBvcmlnaW5RdWVyeTogbnVsbCxcclxuICBkZXN0aW5hdGlvblF1ZXJ5OiBudWxsLFxyXG4gIG9yaWdpblF1ZXJ5Q29vcmRpbmF0ZXM6IG51bGwsXHJcbiAgZGVzdGluYXRpb25RdWVyeUNvb3JkaW5hdGVzOiBudWxsLFxyXG5cclxuICAvLyBEaXJlY3Rpb25zIGRhdGFcclxuICBkaXJlY3Rpb25zOiBbXSxcclxuICByb3V0ZUluZGV4OiAwXHJcbn07XHJcblxyXG5mdW5jdGlvbiBkYXRhKCkge1xyXG4gIHZhciBzdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IGluaXRpYWxTdGF0ZSA6IGFyZ3VtZW50c1swXTtcclxuICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xyXG5cclxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICBjYXNlIHR5cGVzLlNFVF9PUFRJT05TOlxyXG4gICAgICByZXR1cm4gKDAsIF9kZWVwQXNzaWduMi5kZWZhdWx0KSh7fSwgc3RhdGUsIGFjdGlvbi5vcHRpb25zKTtcclxuXHJcbiAgICBjYXNlIHR5cGVzLkRJUkVDVElPTlNfUFJPRklMRTpcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgcHJvZmlsZTogYWN0aW9uLnByb2ZpbGVcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5PUklHSU46XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIG9yaWdpbjogYWN0aW9uLm9yaWdpbixcclxuICAgICAgICBob3Zlck1hcmtlcjoge31cclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5ERVNUSU5BVElPTjpcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgZGVzdGluYXRpb246IGFjdGlvbi5kZXN0aW5hdGlvbixcclxuICAgICAgICBob3Zlck1hcmtlcjoge31cclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5IT1ZFUl9NQVJLRVI6XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIGhvdmVyTWFya2VyOiBhY3Rpb24uaG92ZXJNYXJrZXJcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5XQVlQT0lOVFM6XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIHdheXBvaW50czogYWN0aW9uLndheXBvaW50c1xyXG4gICAgICB9KTtcclxuXHJcbiAgICBjYXNlIHR5cGVzLk9SSUdJTl9RVUVSWTpcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgb3JpZ2luUXVlcnk6IGFjdGlvbi5xdWVyeVxyXG4gICAgICB9KTtcclxuXHJcbiAgICBjYXNlIHR5cGVzLkRFU1RJTkFUSU9OX1FVRVJZOlxyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcclxuICAgICAgICBkZXN0aW5hdGlvblF1ZXJ5OiBhY3Rpb24ucXVlcnlcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5PUklHSU5fRlJPTV9DT09SRElOQVRFUzpcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgb3JpZ2luUXVlcnlDb29yZGluYXRlczogYWN0aW9uLmNvb3JkaW5hdGVzXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGNhc2UgdHlwZXMuREVTVElOQVRJT05fRlJPTV9DT09SRElOQVRFUzpcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgZGVzdGluYXRpb25RdWVyeUNvb3JkaW5hdGVzOiBhY3Rpb24uY29vcmRpbmF0ZXNcclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5PUklHSU5fQ0xFQVI6XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgIG9yaWdpbjoge30sXHJcbiAgICAgICAgb3JpZ2luUXVlcnk6ICcnLFxyXG4gICAgICAgIHdheXBvaW50czogW10sXHJcbiAgICAgICAgZGlyZWN0aW9uczogW11cclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5ERVNUSU5BVElPTl9DTEVBUjpcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XHJcbiAgICAgICAgZGVzdGluYXRpb246IHt9LFxyXG4gICAgICAgIGRlc3RpbmF0aW9uUXVlcnk6ICcnLFxyXG4gICAgICAgIHdheXBvaW50czogW10sXHJcbiAgICAgICAgZGlyZWN0aW9uczogW11cclxuICAgICAgfSk7XHJcblxyXG4gICAgY2FzZSB0eXBlcy5ESVJFQ1RJT05TOlxyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcclxuICAgICAgICBkaXJlY3Rpb25zOiBhY3Rpb24uZGlyZWN0aW9uc1xyXG4gICAgICB9KTtcclxuXHJcbiAgICBjYXNlIHR5cGVzLlJPVVRFX0lOREVYOlxyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcclxuICAgICAgICByb3V0ZUluZGV4OiBhY3Rpb24ucm91dGVJbmRleFxyXG4gICAgICB9KTtcclxuXHJcbiAgICBjYXNlIHR5cGVzLkVSUk9SOlxyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcclxuICAgICAgICBlcnJvcjogYWN0aW9uLmVycm9yXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGRhdGE7XHJcblxyXG59LHtcIi4uL2NvbnN0YW50cy9hY3Rpb25fdHlwZXMuanNcIjozNCxcImRlZXAtYXNzaWduXCI6M31dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmZ1bmN0aW9uIHZhbGlkQ29vcmRzKGNvb3Jkcykge1xyXG4gIHJldHVybiBjb29yZHNbMF0gPj0gLTE4MCAmJiBjb29yZHNbMF0gPD0gMTgwICYmIGNvb3Jkc1sxXSA+PSAtOTAgJiYgY29vcmRzWzFdIDw9IDkwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb29yZGluYXRlTWF0Y2goYSwgYikge1xyXG4gIGEgPSBhLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xyXG4gIGIgPSBiLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xyXG4gIHJldHVybiBhLmpvaW4oKSA9PT0gYi5qb2luKCkgfHwgYVswXS50b0ZpeGVkKDMpID09PSBiWzBdLnRvRml4ZWQoMykgJiYgYVsxXS50b0ZpeGVkKDMpID09PSBiWzFdLnRvRml4ZWQoMyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyYXAobikge1xyXG4gIHZhciBkID0gMTgwIC0gLTE4MDtcclxuICB2YXIgdyA9ICgobiAtIC0xODApICUgZCArIGQpICUgZCArIC0xODA7XHJcbiAgcmV0dXJuIHcgPT09IC0xODAgPyAxODAgOiB3O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVQb2ludChjb29yZGluYXRlcywgcHJvcGVydGllcykge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAnRmVhdHVyZScsXHJcbiAgICBnZW9tZXRyeToge1xyXG4gICAgICB0eXBlOiAnUG9pbnQnLFxyXG4gICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcclxuICAgIH0sXHJcbiAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzID8gcHJvcGVydGllcyA6IHt9XHJcbiAgfTtcclxufVxyXG5cclxudmFyIGZvcm1hdCA9IHtcclxuICBkdXJhdGlvbjogZnVuY3Rpb24gZHVyYXRpb24ocykge1xyXG4gICAgdmFyIG0gPSBNYXRoLmZsb29yKHMgLyA2MCksXHJcbiAgICAgICAgaCA9IE1hdGguZmxvb3IobSAvIDYwKTtcclxuICAgIHMgJT0gNjA7XHJcbiAgICBtICU9IDYwO1xyXG4gICAgaWYgKGggPT09IDAgJiYgbSA9PT0gMCkgcmV0dXJuIHMgKyAncyc7XHJcbiAgICBpZiAoaCA9PT0gMCkgcmV0dXJuIG0gKyAnbWluJztcclxuICAgIHJldHVybiBoICsgJ2ggJyArIG0gKyAnbWluJztcclxuICB9LFxyXG4gIGltcGVyaWFsOiBmdW5jdGlvbiBpbXBlcmlhbChtKSB7XHJcbiAgICB2YXIgbWkgPSBtIC8gMTYwOS4zNDQ7XHJcbiAgICBpZiAobWkgPj0gMTAwKSByZXR1cm4gbWkudG9GaXhlZCgwKSArICdtaSc7XHJcbiAgICBpZiAobWkgPj0gMTApIHJldHVybiBtaS50b0ZpeGVkKDEpICsgJ21pJztcclxuICAgIGlmIChtaSA+PSAwLjEpIHJldHVybiBtaS50b0ZpeGVkKDIpICsgJ21pJztcclxuICAgIHJldHVybiAobWkgKiA1MjgwKS50b0ZpeGVkKDApICsgJ2Z0JztcclxuICB9LFxyXG4gIG1ldHJpYzogZnVuY3Rpb24gbWV0cmljKG0pIHtcclxuICAgIGlmIChtID49IDEwMDAwMCkgcmV0dXJuIChtIC8gMTAwMCkudG9GaXhlZCgwKSArICdrbSc7XHJcbiAgICBpZiAobSA+PSAxMDAwMCkgcmV0dXJuIChtIC8gMTAwMCkudG9GaXhlZCgxKSArICdrbSc7XHJcbiAgICBpZiAobSA+PSAxMDApIHJldHVybiAobSAvIDEwMDApLnRvRml4ZWQoMikgKyAna20nO1xyXG4gICAgcmV0dXJuIG0udG9GaXhlZCgwKSArICdtJztcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSB7IGZvcm1hdDogZm9ybWF0LCBjb29yZGluYXRlTWF0Y2g6IGNvb3JkaW5hdGVNYXRjaCwgY3JlYXRlUG9pbnQ6IGNyZWF0ZVBvaW50LCB2YWxpZENvb3JkczogdmFsaWRDb29yZHMsIHdyYXA6IHdyYXAgfTtcclxuXHJcbn0se31dfSx7fSxbNDBdKSg0MClcclxufSk7XHJcbiIsIi8qZ2xvYmFsICQgKi9cclxuJCh3aW5kb3cpLm9uKFwic2Nyb2xsXCIsIGZ1bmN0aW9uIChldmVudCkge1xyXG5cdHZhciBzY3JvbGxWYWx1ZSA9ICQod2luZG93KS5zY3JvbGxUb3AoKTtcclxuXHRpZiAoc2Nyb2xsVmFsdWUgPiAyMjApIHtcclxuXHRcdCQoXCIubmF2YmFyXCIpLmFkZENsYXNzKFwiYWZmaXhcIik7XHJcblx0fSBlbHNlIHtcclxuXHRcdCQoXCIubmF2YmFyXCIpLnJlbW92ZUNsYXNzKFwiYWZmaXhcIik7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG5cclxuLypMb2FkIGxvY2F0aW9uIChzdG9yZXMyKSovXHJcbnZhciBzdG9yZXMyID0gKGZ1bmN0aW9uICgpIHtcclxuXHRzdG9yZXMyID0gbnVsbDtcclxuXHQkLmFqYXgoe1xyXG5cdFx0XCJhc3luY1wiOiBmYWxzZSxcclxuXHRcdFwiZ2xvYmFsXCI6IGZhbHNlLFxyXG5cdFx0XCJ1cmxcIjogXCJodHRwczovL2xlaXB6aWctZWlua2F1ZmVuLmRlL2xvY2F0aW9uLmpzb25cIixcclxuXHRcdC8vXCJ1cmxcIjogXCJodHRwOi8vbG9jYWxob3N0L3ZlY3RvcnRpbGVzL211c2Vlbi5qc29uXCIsXHJcblx0XHRcImRhdGFUeXBlXCI6IFwianNvblwiLFxyXG5cdFx0XCJzdWNjZXNzXCI6IGZ1bmN0aW9uIChkYXRhKSB7XHJcblx0XHRcdHN0b3JlczIgPSBkYXRhO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHJldHVybiBzdG9yZXMyO1xyXG59KSgpO1xyXG5cclxuLy8gZGVjbGFyZSBtYXBcclxudmFyIG1hcCA9IG5ldyBtYXBib3hnbC5NYXAoe1xyXG5cclxuXHRjb250YWluZXI6IFwibWFwXCIsXHJcblx0c3R5bGU6IFwiaHR0cHM6Ly9sZWlwemlnLWVpbmthdWZlbi5kZS9qc29uL3N0eWxlLWxvY2FsLmpzb25cIixcclxuXHQvL3N0eWxlOiBcImh0dHA6Ly9sb2NhbGhvc3QvdmVjdG9ydGlsZXMvanNvbi9zdHlsZS1sb2NhbC5qc29uXCIsXHJcblxyXG5cdGNlbnRlcjogWzEyLjM3MjIsIDUxLjMyNzJdLFxyXG5cdHpvb206IDExLFxyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZSxcclxuXHRoYXNoOiBmYWxzZSxcclxuXHRtYXhab29tOiAxNC45XHJcbn0pO1xyXG5cclxuLypEZWNsYXJlIE1hcERpcmVjdGlvbnMqL1xyXG5cclxudmFyIG1hcERpcmVjdGlvbnMgPSBuZXcgTWFwYm94RGlyZWN0aW9ucygpO1xyXG4vKk1hcERpcmVjdGlvbnMgU2V0dGluZ3MqL1xyXG5tYXBEaXJlY3Rpb25zLmFjY2Vzc1Rva2VuID0gXCJway5leUoxSWpvaWMyaGxkV0lpTENKaElqb2lXR3RvYlROUE5DSjkudjJKd2xOU0dCbV9LeEpVS0VfV0xpZ1wiO1xyXG5tYXBEaXJlY3Rpb25zLnVuaXQgPSBcIm1ldHJpY1wiO1xyXG5tYXBEaXJlY3Rpb25zLnByb3hpbWl0eSA9IGZhbHNlOyAvKnByb3hpbWl0eSA/PyovXHJcbm1hcERpcmVjdGlvbnMuaW50ZXJhY3RpdmUgPSBmYWxzZTtcclxubWFwRGlyZWN0aW9ucy5wcm9maWxlID0gXCJkcml2aW5nXCI7IC8vLCBcIndhbGtpbmdcIiwgXCJjeWNsaW5nXCI7XHJcbi8vIFVJIGNvbnRyb2xzXHJcbm1hcERpcmVjdGlvbnMuY29udHJvbHMgPSB7XHJcblx0aW5wdXRzOiB0cnVlLFxyXG5cdGluc3RydWN0aW9uczogZmFsc2VcclxufTtcclxuXHJcbi8qQWRkIG1hcERpcmVjdGlvbnMgQ29udHJvbHMqL1xyXG5tYXAuYWRkQ29udHJvbChuZXcgTWFwYm94RGlyZWN0aW9ucyhtYXBEaXJlY3Rpb25zKSwgXCJ0b3AtbGVmdFwiKTtcclxuXHJcbm1hcC5hZGRDb250cm9sKG5ldyBtYXBib3hnbC5TY2FsZUNvbnRyb2woe1xyXG5cdG1heFdpZHRoOiA4MCxcclxuXHR1bml0OiBcIm1ldHJpY1wiXHJcbn0pKTtcclxuXHJcbnZhciBkaXJlY3Rpb25Db250cm9sID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm1hcGJveGdsLWN0cmwtZGlyZWN0aW9uc1wiKTtcclxuZGlyZWN0aW9uQ29udHJvbFtcIjBcIl0uaGlkZGVuID0gdHJ1ZTtcclxudmFyIHB0c1dpdGhpbiA9IG51bGw7XHJcblxyXG4vLyBDcmVhdGUgYSBwb3B1cCAoYnV0IGRvbid0IGFkZCBpdCB0byB0aGUgbWFwIHlldClcclxudmFyIHBvcHVwID0gbmV3IG1hcGJveGdsLlBvcHVwKHtcclxuXHRjbG9zZUJ1dHRvbjogZmFsc2VcclxufSk7XHJcblxyXG52YXIgZmlsdGVyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZlYXR1cmUtZmlsdGVyXCIpO1xyXG52YXIgbGlzdGluZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxpc3RpbmdzXCIpO1xyXG52YXIgdHh0Q2F0ZWdvcmllcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHh0Q2F0ZWdvcmllc1wiKTtcclxuXHJcbi8vIEVtcHR5IEdlb2pzb24gRGF0YVxyXG52YXIgYnVmZmVyZWRMaW5lc3RyaW5nID0ge1xyXG5cdFwiaWRcIjogXCIwXCIsXHJcblx0XCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxyXG5cdFwiZ2VvbWV0cnlcIjoge1xyXG5cdFx0XCJ0eXBlXCI6IFwiUG9pbnRcIixcclxuXHRcdFwiY29vcmRpbmF0ZXNcIjogWzAsIDBdXHJcblx0fSxcclxuXHRcInByb3BlcnRpZXNcIjoge31cclxufTtcclxuXHJcbi8vIEZ1bmN0aW9uc1xyXG5mdW5jdGlvbiBub3JtYWxpemUoc3RyaW5nKSB7XHJcblx0cmV0dXJuIHN0cmluZy50cmltKCkudG9Mb3dlckNhc2UoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUG9wVXAoY3VycmVudEZlYXR1cmUpIHtcclxuXHJcblx0dmFyIHBvcHVwID0gbmV3IG1hcGJveGdsLlBvcHVwKHtcclxuXHRcdFx0Y2xvc2VPbkNsaWNrOiB0cnVlXHJcblx0XHR9KVxyXG5cdFx0LnNldExuZ0xhdChjdXJyZW50RmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcylcclxuXHRcdC5zZXRIVE1MKFwiPGgzPlwiICsgY3VycmVudEZlYXR1cmUucHJvcGVydGllcy5uYW1lICsgXCI8L2gzPlwiICtcclxuXHRcdFx0XCI8aDQ+XCIgKyBjdXJyZW50RmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uICsgXCI8L2g0PlwiKVxyXG5cdFx0LmFkZFRvKG1hcCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFVuaXF1ZUZlYXR1cmVzKGFycmF5LCBjb21wYXJhdG9yUHJvcGVydHkpIHtcclxuXHJcblx0dmFyIGV4aXN0aW5nRmVhdHVyZUtleXMgPSB7fTtcclxuXHQvLyBCZWNhdXNlIGZlYXR1cmVzIGNvbWUgZnJvbSB0aWxlZCB2ZWN0b3IgZGF0YSwgZmVhdHVyZSBnZW9tZXRyaWVzIG1heSBiZSBzcGxpdFxyXG5cdC8vIG9yIGR1cGxpY2F0ZWQgYWNyb3NzIHRpbGUgYm91bmRhcmllcyBhbmQsIGFzIGEgcmVzdWx0LCBmZWF0dXJlcyBtYXkgYXBwZWFyXHJcblx0Ly8gbXVsdGlwbGUgdGltZXMgaW4gcXVlcnkgcmVzdWx0cy5cclxuXHR2YXIgdW5pcXVlRmVhdHVyZXMgPSBhcnJheS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRpZiAoZXhpc3RpbmdGZWF0dXJlS2V5c1tlbC5wcm9wZXJ0aWVzW2NvbXBhcmF0b3JQcm9wZXJ0eV1dKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGV4aXN0aW5nRmVhdHVyZUtleXNbZWwucHJvcGVydGllc1tjb21wYXJhdG9yUHJvcGVydHldXSA9IHRydWU7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gdW5pcXVlRmVhdHVyZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbG9yTG9jYXRpb25MaXN0KGRhdGEpIHtcclxuXHJcblx0Ly8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBsaXN0IG9mIHN0b3Jlc1xyXG5cdC8vIFdJVEhJTiBUSEUgQ0FMQ1VMQVRFRCBST1VURSAhISBhbmQgY29sb3IgaW4gZ3JlZW5cclxuXHRpZiAoZGF0YS5sZW5ndGgpIHtcclxuXHRcdGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG5cclxuXHRcdFx0Ly8gU2hvcnRlbiBkYXRhLmZlYXR1cmUucHJvcGVydGllcyB0byBqdXN0IGBwcm9wYC5cclxuXHRcdFx0dmFyIHByb3AgPSBmZWF0dXJlLnByb3BlcnRpZXM7XHJcblx0XHRcdHZhciBjYXJkSGVhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoZWFkaW5nXCIgKyBwcm9wLmlkKTtcclxuXHRcdFx0aWYgKGNhcmRIZWFkZXIgPT09IG51bGwpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBjYXJkVGl0bGUgPSBjYXJkSGVhZGVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ0aXRsZVwiKTtcclxuXHRcdFx0Y2FyZFRpdGxlWzBdLnN0eWxlLmNvbG9yID0gXCIjNjA4QkM3XCI7XHJcblxyXG5cdFx0fSlcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkTG9jYXRpb25MaXN0KGRhdGEpIHtcclxuXHQvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2Ygc3RvcmVzXHJcblx0bGlzdGluZ3MuaW5uZXJIVE1MID0gXCJcIjtcclxuXHRpZiAoZGF0YS5sZW5ndGgpIHtcclxuXHRcdGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG5cclxuXHRcdFx0Ly8gU2hvcnRlbiBkYXRhLmZlYXR1cmUucHJvcGVydGllcyB0byBqdXN0IGBwcm9wYCBzbyB3ZSdyZSBub3Qgd3JpdGluZyB0aGlzIGxvbmcgZm9ybSBvdmVyIGFuZCBvdmVyIGFnYWluLlxyXG5cdFx0XHR2YXIgcHJvcCA9IGZlYXR1cmUucHJvcGVydGllcztcclxuXHJcblx0XHRcdC8vIFNlbGVjdCB0aGUgbGlzdGluZyBjb250YWluZXIgaW4gdGhlIEhUTUwgYW5kIGFwcGVuZCBhIGRpdiAgd2l0aCB0aGUgY2xhc3MgJ2l0ZW0nIGZvciBlYWNoIHN0b3JlXHJcblx0XHRcdHZhciBjYXJkID0gbGlzdGluZ3MuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XHJcblx0XHRcdGNhcmQuY2xhc3NOYW1lID0gXCJpdGVtIGNhcmQgY2FyZExpc3RcIjtcclxuXHRcdFx0Y2FyZC5pZCA9IHByb3AuaWQ7XHJcblxyXG5cdFx0XHR2YXIgY2FyZEhlYWRlciA9IGNhcmQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XHJcblx0XHRcdGNhcmRIZWFkZXIuY2xhc3NOYW1lID0gXCJjYXJkLWhlYWRlclwiO1xyXG5cdFx0XHRjYXJkSGVhZGVyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0YWJcIik7XHJcblxyXG5cdFx0XHRjYXJkSGVhZGVyLnNldEF0dHJpYnV0ZShcImlkXCIsIFwiaGVhZGluZ1wiICsgY2FyZC5pZCk7XHJcblx0XHRcdGNhcmRIZWFkZXIuaWQgPSBcImhlYWRpbmdcIiArIGNhcmQuaWQ7XHJcblxyXG5cdFx0XHR2YXIgY2FyZE1iMCA9IGNhcmRIZWFkZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImg1XCIpKTtcclxuXHRcdFx0Y2FyZE1iMC5jbGFzc05hbWUgPSBcIm1iLTBcIjtcclxuXHJcblx0XHRcdC8vIENyZWF0ZSBhIG5ldyBsaW5rIHdpdGggdGhlIGNsYXNzICd0aXRsZScgZm9yIGVhY2ggc3RvcmUgYW5kIGZpbGwgaXQgd2l0aCB0aGUgc3RvcmUgYWRkcmVzc1xyXG5cdFx0XHR2YXIgbGluayA9IGNhcmRNYjAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIikpO1xyXG5cdFx0XHRsaW5rLnNldEF0dHJpYnV0ZShcImRhdGEtdG9nZ2xlXCIsIFwiY29sbGFwc2VcIik7XHJcblx0XHRcdGxpbmsuaHJlZiA9IFwiI2NvbGxhcHNlXCIgKyBjYXJkLmlkO1xyXG5cdFx0XHRsaW5rLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKTtcclxuXHRcdFx0bGluay5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIsIFwiY29sbGFwc2VcIiArIGNhcmQuaWQpO1xyXG5cdFx0XHRsaW5rLmNsYXNzTmFtZSA9IFwidGl0bGVcIjtcclxuXHRcdFx0bGluay50ZXh0Q29udGVudCA9IHByb3AubmFtZTtcclxuXHRcdFx0bGluay5kYXRhUG9zaXRpb24gPSBjYXJkLmlkO1xyXG5cclxuXHRcdFx0dmFyIGNhcmRDb2xsYXBzZSA9IGNhcmQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XHJcblx0XHRcdGNhcmRDb2xsYXBzZS5jbGFzc05hbWUgPSBcImNvbGxhcHNlXCI7XHJcblx0XHRcdGNhcmRDb2xsYXBzZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcImNvbGxhcHNlXCIgKyBjYXJkLmlkKTtcclxuXHRcdFx0Y2FyZENvbGxhcHNlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0YWJwYW5lbFwiKTtcclxuXHRcdFx0Y2FyZENvbGxhcHNlLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLCBcImhlYWRpbmdcIiArIGNhcmQuaWQpO1xyXG5cdFx0XHRjYXJkQ29sbGFwc2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1wYXJlbnRcIiwgXCIjbGlzdGluZ3NcIik7XHJcblxyXG5cdFx0XHRpZiAocHJvcC5pbWFnZSkge1xyXG5cdFx0XHRcdHZhciBjYXJkSW1nID0gY2FyZENvbGxhcHNlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIikpO1xyXG5cdFx0XHRcdGNhcmRJbWcuY2xhc3NOYW1lID0gXCJpbWctcmVzcG9uc2l2ZSBpbWctbGlzdGluZ1wiO1xyXG5cdFx0XHRcdGNhcmRJbWcuc3JjID0gcHJvcC5pbWFnZTtcclxuXHRcdFx0XHRjYXJkSW1nLmFsdCA9IHByb3AubmFtZTtcclxuXHRcdFx0XHRjYXJkSW1nLnRpdGxlID0gcHJvcC5uYW1lO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgY2FyZEJvZHkgPSBjYXJkQ29sbGFwc2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XHJcblx0XHRcdGNhcmRCb2R5LmNsYXNzTmFtZSA9IFwiY2FyZC1ib2R5XCI7XHJcblx0XHRcdGNhcmRCb2R5LnRleHRDb250ZW50ID0gcHJvcC5kZXNjcmlwdGlvbjtcclxuXHRcdFx0Y2FyZEJvZHkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChwcm9wLnVybCkge1xyXG5cdFx0XHRcdHZhciBsaW5rQm9keSA9IGNhcmRCb2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpKTtcclxuXHRcdFx0XHRsaW5rQm9keS50ZXh0Q29udGVudCA9IHByb3AubmFtZTtcclxuXHRcdFx0XHRsaW5rQm9keS5ocmVmID0gcHJvcC51cmw7XHJcblx0XHRcdFx0bGlua0JvZHkudGFyZ2V0ID0gXCJfYmxhbmtcIjtcclxuXHRcdFx0XHRsaW5rQm9keS50aXRsZSA9IHByb3AubmFtZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQWRkIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgbGlua3MgaW4gdGhlIHNpZGViYXIgbGlzdGluZ1xyXG5cdFx0XHRsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgY3VycmVudEZlYXR1cmUgdG8gdGhlIHN0b3JlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2xpY2tlZCBsaW5rXHJcblx0XHRcdFx0dmFyIGNsaWNrZWRMaXN0aW5nID0gc3RvcmVzMi5mZWF0dXJlc1t0aGlzLmRhdGFQb3NpdGlvbl07XHJcblxyXG5cdFx0XHRcdHZhciBwb3BVcHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwibWFwYm94Z2wtcG9wdXBcIik7XHJcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIHBvcHVwIG9uIHRoZSBtYXAgYW5kIGlmIHNvLCByZW1vdmUgaXRcclxuXHRcdFx0XHRpZiAocG9wVXBzWzBdKSB7XHJcblx0XHRcdFx0XHRwb3BVcHNbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwb3BVcHNbMF0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gMS4gQ2xvc2UgYWxsIG90aGVyIHBvcHVwcyBhbmQgZGlzcGxheSBwb3B1cCBmb3IgY2xpY2tlZCBzdG9yZVxyXG5cdFx0XHRcdGNyZWF0ZVBvcFVwKGNsaWNrZWRMaXN0aW5nKTtcclxuXHJcblx0XHRcdFx0Ly8gMi4gSGlnaGxpZ2h0IGxpc3RpbmcgaW4gc2lkZWJhciAoYW5kIHJlbW92ZSBoaWdobGlnaHQgZm9yIGFsbCBvdGhlciBsaXN0aW5ncylcclxuXHRcdFx0XHR2YXIgYWN0aXZlSXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJpcy1hY3RpdmVcIik7XHJcblx0XHRcdFx0aWYgKGFjdGl2ZUl0ZW1bMF0pIHtcclxuXHRcdFx0XHRcdGFjdGl2ZUl0ZW1bMF0uY2xhc3NMaXN0LnJlbW92ZShcImlzLWFjdGl2ZVwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5jbGFzc0xpc3QuYWRkKFwiaXMtYWN0aXZlXCIpO1xyXG5cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgZW1wdHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcclxuXHRcdGVtcHR5LnRleHRDb250ZW50ID0gXCJaaWVoZW4gU2llIGRpZSBLYXJ0ZSwgdW0gZGllIEVyZ2Vibmlzc2UgenUgZsO8bGxlblwiO1xyXG5cdFx0bGlzdGluZ3MuYXBwZW5kQ2hpbGQoZW1wdHkpO1xyXG5cclxuXHRcdC8vIHJlbW92ZSBmZWF0dXJlcyBmaWx0ZXJcclxuXHRcdG1hcC5zZXRGaWx0ZXIoXCJsb2NhdGlvbnNcIiwgW1wiaGFzXCIsIFwiQ2F0ZWdvcmllc1wiXSk7XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gUG9wdWxhdGUgZmVhdHVyZXMgZm9yIHRoZSBsaXN0aW5nIG92ZXJsYXkuXHJcblx0aWYgKHB0c1dpdGhpbikge1xyXG5cdFx0Y29sb3JMb2NhdGlvbkxpc3QocHRzV2l0aGluW1wiZmVhdHVyZXNcIl0pO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyT25Sb3V0ZSgpIHtcclxuXHJcblx0dmFyIG1hcERpcmVjdGlvbnNTb3VyY2UgPSBtYXAuZ2V0U291cmNlKFwiZGlyZWN0aW9uc1wiKTtcclxuXHR2YXIgcmFkaXVzID0gMC42O1xyXG5cdHZhciB1bml0ID0gXCJraWxvbWV0ZXJzXCI7XHJcblxyXG5cdC8vdmFyIGRpc3REdXJhdGlvbiA9IG1hcERpcmVjdGlvbnMuZ2V0RGlzdGFuY2VBbmREdXJhdGlvbigpO1xyXG5cclxuXHQvLyBidWZmZXIgdGhlIHJvdXRlIHdpdGggYSBhcmVhIG9mIHJhZGl1cyAncmFkaXVzJ1xyXG5cdGlmIChtYXBEaXJlY3Rpb25zU291cmNlLl9kYXRhLmZlYXR1cmVzLmxlbmd0aCA8IDIpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0dmFyIGJ1ZmZlcmVkTGluZXN0cmluZyA9IHR1cmYuYnVmZmVyKG1hcERpcmVjdGlvbnNTb3VyY2UuX2RhdGEuZmVhdHVyZXNbMl0uZ2VvbWV0cnksIHJhZGl1cywge1xyXG5cdFx0dW5pdHM6IHVuaXRcclxuXHR9KTtcclxuXHJcblx0Ly8gdXBkYXRlIGJ1ZmZlcmVkVHJhY2VTb3VyY2VcclxuXHRtYXAuZ2V0U291cmNlKFwiYnVmZmVyZWRUcmFjZVNvdXJjZVwiKS5zZXREYXRhKGJ1ZmZlcmVkTGluZXN0cmluZyk7XHJcblxyXG5cdC8vIEdldCBsb2NhdGlvbnMgcmVuZGVyZWQgb24gdGhlIG1hcFxyXG5cdHZhciBmZWF0dXJlcyA9IG1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoe1xyXG5cdFx0bGF5ZXJzOiBbXCJsb2NhdGlvbnNcIl1cclxuXHR9KTtcclxuXHJcblx0Ly8gdXNlIGZlYXR1cmVDb2xsZWN0aW9uIHRvIGNvbnZlcnQgZmVhdHVyZXMgKGFycmF5IG9mIGZlYXR1cmVzKSBpbnRvIGEgY29sbGVjdGlvbiBvZiBmZWF0dXJlcyAoT2JqZWN0IHR5cGUgRmVhdHVyZUNvbGxlY3Rpb24pO1xyXG5cdHZhciBjb2xsZWN0aW9uID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlcyk7XHJcblxyXG5cdC8vIEZpbHRlciB0aGUgcG9pbnRzIHRvIHRoZSBhcmVhIGFyb3VuZCB0aGUgZGlyZWN0aW9uXHJcblx0cHRzV2l0aGluID0gdHVyZi5wb2ludHNXaXRoaW5Qb2x5Z29uKGNvbGxlY3Rpb24sIGJ1ZmZlcmVkTGluZXN0cmluZyk7XHJcblxyXG5cdC8vIFBvcHVsYXRlIGZlYXR1cmVzIGZvciB0aGUgbGlzdGluZyBvdmVybGF5LlxyXG5cdGlmIChwdHNXaXRoaW4pIHtcclxuXHRcdGJ1aWxkTG9jYXRpb25MaXN0KGZlYXR1cmVzKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc3BsYXlEaXJlY3Rpb25Db250cm9scygpIHtcclxuXHJcblx0dmFyIGRpcmVjdGlvbkNvbnRyb2wgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwibWFwYm94Z2wtY3RybC1kaXJlY3Rpb25zXCIpO1xyXG5cdGlmIChkaXJlY3Rpb25Db250cm9sW1wiMFwiXS5oaWRkZW4pIHtcclxuXHRcdGRpcmVjdGlvbkNvbnRyb2xbXCIwXCJdLmhpZGRlbiA9IGZhbHNlO1xyXG5cdFx0bWFwLnNldExheW91dFByb3BlcnR5KFwiYnVmZmVyZWRUcmFjZUxheWVyXCIsIFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcblxyXG5cdFx0bWFwLnNldExheW91dFByb3BlcnR5KFwiZGlyZWN0aW9ucy1vcmlnaW4tcG9pbnRcIiwgXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcclxuXHRcdG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShcImRpcmVjdGlvbnMtZGVzdGluYXRpb24tcG9pbnRcIiwgXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcclxuXHRcdG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShcImRpcmVjdGlvbnMtb3JpZ2luLWxhYmVsXCIsIFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcblx0XHRtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJkaXJlY3Rpb25zLWRlc3RpbmF0aW9uLWxhYmVsXCIsIFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcblxyXG5cdFx0bWFwLnNldExheW91dFByb3BlcnR5KFwiZGlyZWN0aW9ucy1ob3Zlci1wb2ludFwiLCBcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xyXG5cdFx0bWFwLnNldExheW91dFByb3BlcnR5KFwiZGlyZWN0aW9ucy13YXlwb2ludC1wb2ludFwiLCBcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xyXG5cdFx0bWFwLnNldExheW91dFByb3BlcnR5KFwiZGlyZWN0aW9ucy1yb3V0ZS1saW5lXCIsIFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcblx0XHRtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJkaXJlY3Rpb25zLXJvdXRlLWxpbmUtYWx0XCIsIFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcblx0XHRmaWx0ZXJPblJvdXRlKCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGRpcmVjdGlvbkNvbnRyb2xbXCIwXCJdLmhpZGRlbiA9IHRydWU7XHJcblx0XHQvLyByZWluaXRpYWxpemUgcHRzV2l0aGluXHJcblx0XHRwdHNXaXRoaW4gPSBudWxsO1xyXG5cclxuXHRcdG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShcImJ1ZmZlcmVkVHJhY2VMYXllclwiLCBcInZpc2liaWxpdHlcIiwgXCJub25lXCIpO1xyXG5cdFx0bWFwLnNldExheW91dFByb3BlcnR5KFwiZGlyZWN0aW9ucy1vcmlnaW4tcG9pbnRcIiwgXCJ2aXNpYmlsaXR5XCIsIFwibm9uZVwiKTtcclxuXHRcdG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShcImRpcmVjdGlvbnMtZGVzdGluYXRpb24tcG9pbnRcIiwgXCJ2aXNpYmlsaXR5XCIsIFwibm9uZVwiKTtcclxuXHRcdG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShcImRpcmVjdGlvbnMtb3JpZ2luLWxhYmVsXCIsIFwidmlzaWJpbGl0eVwiLCBcIm5vbmVcIik7XHJcblx0XHRtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJkaXJlY3Rpb25zLWRlc3RpbmF0aW9uLWxhYmVsXCIsIFwidmlzaWJpbGl0eVwiLCBcIm5vbmVcIik7XHJcblxyXG5cdFx0bWFwLnNldExheW91dFByb3BlcnR5KFwiZGlyZWN0aW9ucy1ob3Zlci1wb2ludFwiLCBcInZpc2liaWxpdHlcIiwgXCJub25lXCIpO1xyXG5cdFx0bWFwLnNldExheW91dFByb3BlcnR5KFwiZGlyZWN0aW9ucy13YXlwb2ludC1wb2ludFwiLCBcInZpc2liaWxpdHlcIiwgXCJub25lXCIpO1xyXG5cdFx0bWFwLnNldExheW91dFByb3BlcnR5KFwiZGlyZWN0aW9ucy1yb3V0ZS1saW5lXCIsIFwidmlzaWJpbGl0eVwiLCBcIm5vbmVcIik7XHJcblx0XHRtYXAuc2V0TGF5b3V0UHJvcGVydHkoXCJkaXJlY3Rpb25zLXJvdXRlLWxpbmUtYWx0XCIsIFwidmlzaWJpbGl0eVwiLCBcIm5vbmVcIik7XHJcblxyXG5cdFx0dmFyIGZlYXR1cmVzID0gbWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyh7XHJcblx0XHRcdGxheWVyczogW1wibG9jYXRpb25zXCJdXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoZmVhdHVyZXMpIHtcclxuXHRcdFx0Ly8gUG9wdWxhdGUgZmVhdHVyZXMgZm9yIHRoZSBsaXN0aW5nIG92ZXJsYXkuXHJcblx0XHRcdGJ1aWxkTG9jYXRpb25MaXN0KGZlYXR1cmVzKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcblxyXG4vLyBDYWxsIGJ1aWxkbGlzdCBmdW5jdGlvbiBvbiBpbml0aWFsaXphdGlvblxyXG5idWlsZExvY2F0aW9uTGlzdChzdG9yZXMyW1wiZmVhdHVyZXNcIl0pO1xyXG5cclxuLy8gTG9hZCBtYXBcclxubWFwLm9uKFwibG9hZFwiLCBmdW5jdGlvbiAoZSkge1xyXG5cclxuXHRtYXAubG9hZEltYWdlKFwiaHR0cHM6Ly9sZWlwemlnLWVpbmthdWZlbi5kZS9tZWRpYS9kaWFnb25hbC1ub2lzZS5wbmdcIiwgZnVuY3Rpb24gKGVycm9yLCBpbWFnZSkge1xyXG5cclxuXHRcdGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcblx0XHRtYXAuYWRkSW1hZ2UoXCJiYWNrZ3JvdW5kX3BhdHRlcm5cIiwgaW1hZ2UpO1xyXG5cdH0pO1xyXG5cclxuXHQvL21hcC5sb2FkSW1hZ2UoJ2h0dHA6Ly9sb2NhbGhvc3QvdmVjdG9ydGlsZXMvbWVkaWEvTWFya2VyX3dpdGhfU2hhZG93LnBuZycsIGZ1bmN0aW9uKGVycm9yLCBpbWFnZSkge1xyXG5cdG1hcC5sb2FkSW1hZ2UoXCJodHRwczovL2xlaXB6aWctZWlua2F1ZmVuLmRlL21lZGlhL01hcmtlcl93aXRoX1NoYWRvdy5wbmdcIiwgZnVuY3Rpb24gKGVycm9yLCBpbWFnZSkge1xyXG5cclxuXHRcdGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XHJcblx0XHRtYXAuYWRkSW1hZ2UoXCJtYXJrZXJfelwiLCBpbWFnZSk7XHJcblxyXG5cdFx0Ly8gQWRkIHRoZSBzdG9yZXMyIChsb2NhdGlvbnNfc291cmNlKSB0byB0aGUgbWFwXHJcblx0XHRtYXAuYWRkU291cmNlKFwibG9jYXRpb25zX3NvdXJjZVwiLCB7XHJcblx0XHRcdFwidHlwZVwiOiBcImdlb2pzb25cIixcclxuXHRcdFx0XCJkYXRhXCI6IHN0b3JlczJcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIEFkZCB0aGUgbG9jYXRpb25zX3NvdXJjZSB0byB0aGUgbWFwIGFzIGEgbGF5ZXJcclxuXHRcdG1hcC5hZGRMYXllcih7XHJcblx0XHRcdFwiaWRcIjogXCJsb2NhdGlvbnNcIixcclxuXHRcdFx0XCJ0eXBlXCI6IFwic3ltYm9sXCIsXHJcblx0XHRcdC8vIEFkZCBhIEdlb0pTT04gc291cmNlIGNvbnRhaW5pbmcgcGxhY2UgY29vcmRpbmF0ZXMgYW5kIGluZm9ybWF0aW9uLlxyXG5cdFx0XHRcInNvdXJjZVwiOiBcImxvY2F0aW9uc19zb3VyY2VcIixcclxuXHRcdFx0XCJsYXlvdXRcIjoge1xyXG5cdFx0XHRcdFwidmlzaWJpbGl0eVwiOiBcInZpc2libGVcIixcclxuXHRcdFx0XHRcImljb24taW1hZ2VcIjogXCJtYXJrZXJfelwiLFxyXG5cdFx0XHRcdFwiaWNvbi1zaXplXCI6IDAuOSxcclxuXHRcdFx0XHRcImljb24tYWxsb3ctb3ZlcmxhcFwiOiB0cnVlXHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIEFkZCB0aGUgYnVmZmVyZWRMaW5lc3RyaW5nIHRvIHRoZSBtYXAgYXMgYSBsYXllclxyXG5cdFx0bWFwLmFkZFNvdXJjZShcImJ1ZmZlcmVkVHJhY2VTb3VyY2VcIiwge1xyXG5cdFx0XHRcInR5cGVcIjogXCJnZW9qc29uXCIsXHJcblx0XHRcdFwiZGF0YVwiOiBidWZmZXJlZExpbmVzdHJpbmcsXHJcblx0XHRcdFwibWF4em9vbVwiOiAxM1xyXG5cdFx0fSk7XHJcblx0XHRtYXAuYWRkTGF5ZXIoe1xyXG5cdFx0XHRcImlkXCI6IFwiYnVmZmVyZWRUcmFjZUxheWVyXCIsXHJcblx0XHRcdFwidHlwZVwiOiBcImZpbGxcIixcclxuXHRcdFx0XCJzb3VyY2VcIjogXCJidWZmZXJlZFRyYWNlU291cmNlXCIsXHJcblx0XHRcdFwibGF5b3V0XCI6IHtcclxuXHRcdFx0XHRcInZpc2liaWxpdHlcIjogXCJ2aXNpYmxlXCJcclxuXHRcdFx0fSxcclxuXHRcdFx0XCJwYWludFwiOiB7XHJcblx0XHRcdFx0XCJmaWxsLWNvbG9yXCI6IFwicmdiKDAsMCwwKVwiLFxyXG5cdFx0XHRcdFwiZmlsbC1vcGFjaXR5XCI6IDEsXHJcblx0XHRcdFx0XCJmaWxsLXRyYW5zbGF0ZVwiOiBbXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMi41XHJcbiAgICAgICAgXSxcclxuXHRcdFx0XHRcImZpbGwtcGF0dGVyblwiOiBcImJhY2tncm91bmRfcGF0dGVyblwiXHJcblx0XHRcdH1cclxuXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBBZGQgRnVsbHNjcmVlbiBjb250cm9sIHRvIHRoZSBtYXAuXHJcblx0XHRtYXAuYWRkQ29udHJvbChuZXcgbWFwYm94Z2wuRnVsbHNjcmVlbkNvbnRyb2woKSk7XHJcblxyXG5cdFx0Ly8gQWRkIGdlb2xvY2F0ZSBjb250cm9sIHRvIHRoZSBtYXAuXHJcblx0XHRtYXAuYWRkQ29udHJvbChuZXcgbWFwYm94Z2wuR2VvbG9jYXRlQ29udHJvbCh7XHJcblx0XHRcdHBvc2l0aW9uT3B0aW9uczoge1xyXG5cdFx0XHRcdGVuYWJsZUhpZ2hBY2N1cmFjeTogdHJ1ZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHR0cmFja1VzZXJMb2NhdGlvbjogdHJ1ZVxyXG5cdFx0fSkpO1xyXG5cclxuXHRcdC8vIFdoZW4gYSBjbGljayBldmVudCBvY2N1cnMgb24gYSBmZWF0dXJlIGluIHRoZSBwbGFjZXMgbGF5ZXIsIG9wZW4gYSBwb3B1cCBhdCB0aGVcclxuXHRcdC8vIGxvY2F0aW9uIG9mIHRoZSBmZWF0dXJlLCB3aXRoIGRlc2NyaXB0aW9uIEhUTUwgZnJvbSBpdHMgcHJvcGVydGllcy5cclxuXHRcdG1hcC5vbihcImNsaWNrXCIsIFwibG9jYXRpb25zXCIsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHZhciBjdXJyZW50RmVhdHVyZSA9IGUuZmVhdHVyZXNbMF07XHJcblx0XHRcdC8vIDEuIENyZWF0ZSBQb3B1cFxyXG5cdFx0XHRjcmVhdGVQb3BVcChjdXJyZW50RmVhdHVyZSk7XHJcblxyXG5cdFx0XHQvLyAyLiBIaWdobGlnaHQgbGlzdGluZyBpbiBzaWRlYmFyIChhbmQgcmVtb3ZlIGhpZ2hsaWdodCBmb3Igb3RoZXIgbGlzdGluZylcclxuXHRcdFx0dmFyIGFjdGl2ZUl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaXMtYWN0aXZlXCIpO1xyXG5cdFx0XHRpZiAoYWN0aXZlSXRlbVswXSkge1xyXG5cdFx0XHRcdGFjdGl2ZUl0ZW1bMF0uY2xhc3NMaXN0LnJlbW92ZShcImlzLWFjdGl2ZVwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGhlYWRpbmdFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoZWFkaW5nXCIgKyBjdXJyZW50RmVhdHVyZS5wcm9wZXJ0aWVzLmlkKTtcclxuXHRcdFx0aWYgKGhlYWRpbmdFbGVtZW50KSB7XHJcblx0XHRcdFx0aGVhZGluZ0VsZW1lbnQuY2xhc3NMaXN0LmFkZChcImlzLWFjdGl2ZVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgY29sbGFwc2VFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb2xsYXBzZVwiICsgY3VycmVudEZlYXR1cmUucHJvcGVydGllcy5pZCk7XHJcblx0XHRcdGlmIChjb2xsYXBzZUVsZW1lbnQpIHtcclxuXHRcdFx0XHQkKGNvbGxhcHNlRWxlbWVudCkuY29sbGFwc2UoXCJzaG93XCIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0bWFwLm9uKFwibW92ZWVuZFwiLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8vIFF1ZXJ5IGFsbCB0aGUgcmVuZGVyZWQgcG9pbnRzIGluIHRoZSB2aWV3XHJcblx0XHRcdHZhciBmZWF0dXJlcyA9IG1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoe1xyXG5cdFx0XHRcdGxheWVyczogW1wibG9jYXRpb25zXCJdXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0aWYgKGZlYXR1cmVzKSB7XHJcblxyXG5cdFx0XHRcdC8vdmFyIHVuaXF1ZUZlYXR1cmVzID0gZ2V0VW5pcXVlRmVhdHVyZXMoZmVhdHVyZXMsIFwiQ2F0ZWdvcmllc1wiKTtcclxuXHJcblx0XHRcdFx0Ly8gUG9wdWxhdGUgZmVhdHVyZXMgZm9yIHRoZSBsaXN0aW5nIG92ZXJsYXkuXHJcblx0XHRcdFx0YnVpbGRMb2NhdGlvbkxpc3QoZmVhdHVyZXMpO1xyXG5cclxuXHRcdFx0XHQvLyBDbGVhciB0aGUgaW5wdXQgY29udGFpbmVyXHJcblx0XHRcdFx0ZmlsdGVyRWwudmFsdWUgPSBcIlwiO1xyXG5cclxuXHRcdFx0XHQvLyBTdG9yZSB0aGUgY3VycmVudCBmZWF0dXJlcyBpbiBzbiBgbG9jYXRpb25zX29uX21hcGAgdmFyaWFibGUgdG8gbGF0ZXIgdXNlIGZvciBmaWx0ZXJpbmcgb24gYGtleXVwYC5cclxuXHRcdFx0XHRsb2NhdGlvbnMgPSBmZWF0dXJlcztcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0bWFwLm9uKFwibW91c2Vtb3ZlXCIsIFwibG9jYXRpb25zXCIsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdC8vIENoYW5nZSB0aGUgY3Vyc29yIHN0eWxlIGFzIGEgVUkgaW5kaWNhdG9yLlxyXG5cdFx0XHRtYXAuZ2V0Q2FudmFzKCkuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0bWFwLm9uKFwibW91c2VsZWF2ZVwiLCBcImxvY2F0aW9uc1wiLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdG1hcC5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSBcIlwiO1xyXG5cdFx0XHRwb3B1cC5yZW1vdmUoKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdCQoXCIuZHJvcGRvd24taXRlbVwiKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgdmFsdWUgPSBub3JtYWxpemUoJCh0aGlzKS50ZXh0KCkpO1xyXG5cclxuXHRcdFx0dmFyIGZpbHRlcmVkID0gbWFwLnF1ZXJ5U291cmNlRmVhdHVyZXMoXCJsb2NhdGlvbnNfc291cmNlXCIpO1xyXG5cdFx0XHRpZiAodmFsdWUgIT09IFwiYWxsZVwiKSB7XHJcblx0XHRcdFx0Ly8gRmlsdGVyIHZpc2libGUgZmVhdHVyZXMgdGhhdCBkb24ndCBtYXRjaCB0aGUgaW5wdXQgdmFsdWUuXHJcblx0XHRcdFx0ZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuXHRcdFx0XHRcdHZhciBuYW1lID0gbm9ybWFsaXplKGZlYXR1cmUucHJvcGVydGllcy5uYW1lKTtcclxuXHRcdFx0XHRcdHZhciBDYXRlZ29yaWVzID0gbm9ybWFsaXplKGZlYXR1cmUucHJvcGVydGllcy5DYXRlZ29yaWVzKTtcclxuXHRcdFx0XHRcdHJldHVybiBuYW1lLmluZGV4T2YodmFsdWUpID4gLTEgfHwgQ2F0ZWdvcmllcy5pbmRleE9mKHZhbHVlKSA+IC0xO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghZmlsdGVyZWQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHR2YXIgdW5pcXVlRmVhdHVyZXMgPSBnZXRVbmlxdWVGZWF0dXJlcyhmaWx0ZXJlZCwgXCJDYXRlZ29yaWVzXCIpO1xyXG5cdFx0XHQvLyBQb3B1bGF0ZSB0aGUgc2lkZWJhciB3aXRoIGZpbHRlcmVkIHJlc3VsdHNcclxuXHRcdFx0YnVpbGRMb2NhdGlvbkxpc3QodW5pcXVlRmVhdHVyZXMpO1xyXG5cclxuXHRcdFx0Ly8gU2V0IHRoZSBmaWx0ZXIgdG8gcG9wdWxhdGUgZmVhdHVyZXMgaW50byB0aGUgbGF5ZXIuXHJcblx0XHRcdG1hcC5zZXRGaWx0ZXIoXCJsb2NhdGlvbnNcIiwgW1wiaW5cIiwgXCJuYW1lXCJdLmNvbmNhdCh1bmlxdWVGZWF0dXJlcy5tYXAoZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLm5hbWU7XHJcblx0XHRcdH0pKSk7XHJcblxyXG5cclxuXHRcdFx0dHh0Q2F0ZWdvcmllcy52YWx1ZSA9IHZhbHVlO1xyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8qICAgIGZpbHRlckVsLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmdW5jdGlvbihlKSB7XHJcblxyXG5cdFx0ICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplKGUudGFyZ2V0LnZhbHVlKTtcclxuXHJcblx0XHQgICAgICAvLyBGaWx0ZXIgdmlzaWJsZSBmZWF0dXJlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBpbnB1dCB2YWx1ZS5cclxuXHRcdCAgICAgIHZhciBmaWx0ZXJlZCA9IGxvY2F0aW9ucy5maWx0ZXIoZnVuY3Rpb24oZmVhdHVyZSkge1xyXG5cclxuXHRcdCAgICAgICAgdmFyIG5hbWUgPSBub3JtYWxpemUoZmVhdHVyZS5wcm9wZXJ0aWVzLm5hbWUpO1xyXG5cdFx0ICAgICAgICB2YXIgQ2F0ZWdvcmllcyA9IG5vcm1hbGl6ZShmZWF0dXJlLnByb3BlcnRpZXMuQ2F0ZWdvcmllcyk7XHJcblx0XHQgICAgICAgIHJldHVybiBuYW1lLmluZGV4T2YodmFsdWUpID4gLTEgfHwgQ2F0ZWdvcmllcy5pbmRleE9mKHZhbHVlKSA+IC0xO1xyXG5cdFx0ICAgICAgfSk7XHJcblxyXG5cdFx0ICAgICAgLy8gUG9wdWxhdGUgdGhlIHNpZGViYXIgd2l0aCBmaWx0ZXJlZCByZXN1bHRzXHJcblx0XHQgICAgICBidWlsZExvY2F0aW9uTGlzdChmaWx0ZXJlZCk7XHJcblxyXG5cdFx0ICAgICAgLy8gU2V0IHRoZSBmaWx0ZXIgdG8gcG9wdWxhdGUgZmVhdHVyZXMgaW50byB0aGUgbGF5ZXIuXHJcblx0XHQgICAgICBtYXAuc2V0RmlsdGVyKFwibG9jYXRpb25zXCIsIFtcImluXCIsIFwibmFtZVwiXS5jb25jYXQoZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGZlYXR1cmUpIHtcclxuXHRcdCAgICAgICAgcmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5uYW1lO1xyXG5cdFx0ICAgICAgfSkpKTtcclxuXHJcblx0XHQgICAgfSk7Ki9cclxuXHJcblx0fSk7XHJcbn0pO1xyXG5cclxuLy8gRGlyZWN0aW9uIGV2ZW50IGxpc3RlbmVyXHJcbm1hcERpcmVjdGlvbnMub24oXCJyb3V0ZVwiLCBmdW5jdGlvbiAoZSkge1xyXG5cdGZpbHRlck9uUm91dGUoKTtcclxufSk7XHJcblxyXG4vLyBEaXNwbGF5IERpcmVjdGlvblxyXG4kKFwiI2J0bkRpc3BsYXlDb250cm9sc1wiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XHJcblx0ZGlzcGxheURpcmVjdGlvbkNvbnRyb2xzKCk7XHJcbn0pXHJcbiIsIitmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9e2NhbGM6ITF9O2UuZm4ucnJzc2I9ZnVuY3Rpb24odCl7dmFyIGk9ZS5leHRlbmQoe2Rlc2NyaXB0aW9uOnIsZW1haWxBZGRyZXNzOnIsZW1haWxCb2R5OnIsZW1haWxTdWJqZWN0OnIsaW1hZ2U6cix0aXRsZTpyLHVybDpyfSx0KTtpLmVtYWlsU3ViamVjdD1pLmVtYWlsU3ViamVjdHx8aS50aXRsZSxpLmVtYWlsQm9keT1pLmVtYWlsQm9keXx8KGkuZGVzY3JpcHRpb24/aS5kZXNjcmlwdGlvbjpcIlwiKSsoaS51cmw/XCJcXG5cXG5cIitpLnVybDpcIlwiKTtmb3IodmFyIHMgaW4gaSlpLmhhc093blByb3BlcnR5KHMpJiZpW3NdIT09ciYmKGlbc109YShpW3NdKSk7aS51cmwhPT1yJiYoZSh0aGlzKS5maW5kKFwiLnJyc3NiLWZhY2Vib29rIGFcIikuYXR0cihcImhyZWZcIixcImh0dHBzOi8vd3d3LmZhY2Vib29rLmNvbS9zaGFyZXIvc2hhcmVyLnBocD91PVwiK2kudXJsKSxlKHRoaXMpLmZpbmQoXCIucnJzc2ItdHVtYmxyIGFcIikuYXR0cihcImhyZWZcIixcImh0dHA6Ly90dW1ibHIuY29tL3NoYXJlL2xpbms/dXJsPVwiK2kudXJsKyhpLnRpdGxlIT09cj9cIiZuYW1lPVwiK2kudGl0bGU6XCJcIikrKGkuZGVzY3JpcHRpb24hPT1yP1wiJmRlc2NyaXB0aW9uPVwiK2kuZGVzY3JpcHRpb246XCJcIikpLGUodGhpcykuZmluZChcIi5ycnNzYi1saW5rZWRpbiBhXCIpLmF0dHIoXCJocmVmXCIsXCJodHRwOi8vd3d3LmxpbmtlZGluLmNvbS9zaGFyZUFydGljbGU/bWluaT10cnVlJnVybD1cIitpLnVybCsoaS50aXRsZSE9PXI/XCImdGl0bGU9XCIraS50aXRsZTpcIlwiKSsoaS5kZXNjcmlwdGlvbiE9PXI/XCImc3VtbWFyeT1cIitpLmRlc2NyaXB0aW9uOlwiXCIpKSxlKHRoaXMpLmZpbmQoXCIucnJzc2ItdHdpdHRlciBhXCIpLmF0dHIoXCJocmVmXCIsXCJodHRwczovL3R3aXR0ZXIuY29tL2ludGVudC90d2VldD90ZXh0PVwiKyhpLmRlc2NyaXB0aW9uIT09cj9pLmRlc2NyaXB0aW9uOlwiXCIpK1wiJTIwXCIraS51cmwpLGUodGhpcykuZmluZChcIi5ycnNzYi1oYWNrZXJuZXdzIGFcIikuYXR0cihcImhyZWZcIixcImh0dHBzOi8vbmV3cy55Y29tYmluYXRvci5jb20vc3VibWl0bGluaz91PVwiK2kudXJsKyhpLnRpdGxlIT09cj9cIiZ0ZXh0PVwiK2kudGl0bGU6XCJcIikpLGUodGhpcykuZmluZChcIi5ycnNzYi12ayBhXCIpLmF0dHIoXCJocmVmXCIsXCJodHRwczovL3ZrLmNvbS9zaGFyZS5waHA/dXJsPVwiK2kudXJsKSxlKHRoaXMpLmZpbmQoXCIucnJzc2ItcmVkZGl0IGFcIikuYXR0cihcImhyZWZcIixcImh0dHA6Ly93d3cucmVkZGl0LmNvbS9zdWJtaXQ/dXJsPVwiK2kudXJsKyhpLmRlc2NyaXB0aW9uIT09cj9cIiZ0ZXh0PVwiK2kuZGVzY3JpcHRpb246XCJcIikrKGkudGl0bGUhPT1yP1wiJnRpdGxlPVwiK2kudGl0bGU6XCJcIikpLGUodGhpcykuZmluZChcIi5ycnNzYi1nb29nbGVwbHVzIGFcIikuYXR0cihcImhyZWZcIixcImh0dHBzOi8vcGx1cy5nb29nbGUuY29tL3NoYXJlP3VybD1cIitpLnVybCksZSh0aGlzKS5maW5kKFwiLnJyc3NiLXBpbnRlcmVzdCBhXCIpLmF0dHIoXCJocmVmXCIsXCJodHRwOi8vcGludGVyZXN0LmNvbS9waW4vY3JlYXRlL2J1dHRvbi8/dXJsPVwiK2kudXJsKyhpLmltYWdlIT09cj9cIiZhbXA7bWVkaWE9XCIraS5pbWFnZTpcIlwiKSsoaS5kZXNjcmlwdGlvbiE9PXI/XCImZGVzY3JpcHRpb249XCIraS5kZXNjcmlwdGlvbjpcIlwiKSksZSh0aGlzKS5maW5kKFwiLnJyc3NiLXBvY2tldCBhXCIpLmF0dHIoXCJocmVmXCIsXCJodHRwczovL2dldHBvY2tldC5jb20vc2F2ZT91cmw9XCIraS51cmwpLGUodGhpcykuZmluZChcIi5ycnNzYi1naXRodWIgYVwiKS5hdHRyKFwiaHJlZlwiLGkudXJsKSxlKHRoaXMpLmZpbmQoXCIucnJzc2ItcHJpbnQgYVwiKS5hdHRyKFwiaHJlZlwiLFwiamF2YXNjcmlwdDp3aW5kb3cucHJpbnQoKVwiKSxlKHRoaXMpLmZpbmQoXCIucnJzc2Itd2hhdHNhcHAgYVwiKS5hdHRyKFwiaHJlZlwiLFwid2hhdHNhcHA6Ly9zZW5kP3RleHQ9XCIrKGkuZGVzY3JpcHRpb24hPT1yP2kuZGVzY3JpcHRpb24rXCIlMjBcIjppLnRpdGxlIT09cj9pLnRpdGxlK1wiJTIwXCI6XCJcIikraS51cmwpKSwoaS5lbWFpbEFkZHJlc3MhPT1yfHxpLmVtYWlsU3ViamVjdCkmJmUodGhpcykuZmluZChcIi5ycnNzYi1lbWFpbCBhXCIpLmF0dHIoXCJocmVmXCIsXCJtYWlsdG86XCIrKGkuZW1haWxBZGRyZXNzP2kuZW1haWxBZGRyZXNzOlwiXCIpK1wiP1wiKyhpLmVtYWlsU3ViamVjdCE9PXI/XCJzdWJqZWN0PVwiK2kuZW1haWxTdWJqZWN0OlwiXCIpKyhpLmVtYWlsQm9keSE9PXI/XCImYm9keT1cIitpLmVtYWlsQm9keTpcIlwiKSl9O3ZhciBzPWZ1bmN0aW9uKCl7dmFyIHQ9ZShcIjxkaXY+XCIpLHI9W1wiY2FsY1wiLFwiLXdlYmtpdC1jYWxjXCIsXCItbW96LWNhbGNcIl07ZShcImJvZHlcIikuYXBwZW5kKHQpO2Zvcih2YXIgcz0wO3M8ci5sZW5ndGg7cysrKWlmKHQuY3NzKFwid2lkdGhcIixyW3NdK1wiKDFweClcIiksMT09PXQud2lkdGgoKSl7aS5jYWxjPXJbc107YnJlYWt9dC5yZW1vdmUoKX0sYT1mdW5jdGlvbih0KXtpZih0IT09ciYmbnVsbCE9PXQpe2lmKG51bGw9PT10Lm1hdGNoKC8lWzAtOWEtZl17Mn0vaSkpcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0KTt0PWRlY29kZVVSSUNvbXBvbmVudCh0KSxhKHQpfX0sbj1mdW5jdGlvbigpe2UoXCIucnJzc2ItYnV0dG9uc1wiKS5lYWNoKGZ1bmN0aW9uKHQpe3ZhciByPWUodGhpcyksaT1lKFwibGk6dmlzaWJsZVwiLHIpLHM9aS5sZW5ndGgsYT0xMDAvcztpLmNzcyhcIndpZHRoXCIsYStcIiVcIikuYXR0cihcImRhdGEtaW5pdHdpZHRoXCIsYSl9KX0sbD1mdW5jdGlvbigpe2UoXCIucnJzc2ItYnV0dG9uc1wiKS5lYWNoKGZ1bmN0aW9uKHQpe3ZhciByPWUodGhpcyksaT1yLndpZHRoKCkscz1lKFwibGlcIixyKS5ub3QoXCIuc21hbGxcIikuZXEoMCkud2lkdGgoKSxhPWUoXCJsaS5zbWFsbFwiLHIpLmxlbmd0aDtpZihzPjE3MCYmYTwxKXtyLmFkZENsYXNzKFwibGFyZ2UtZm9ybWF0XCIpO3ZhciBuPXMvMTIrXCJweFwiO3IuY3NzKFwiZm9udC1zaXplXCIsbil9ZWxzZSByLnJlbW92ZUNsYXNzKFwibGFyZ2UtZm9ybWF0XCIpLHIuY3NzKFwiZm9udC1zaXplXCIsXCJcIik7aTwyNSphP3IucmVtb3ZlQ2xhc3MoXCJzbWFsbC1mb3JtYXRcIikuYWRkQ2xhc3MoXCJ0aW55LWZvcm1hdFwiKTpyLnJlbW92ZUNsYXNzKFwidGlueS1mb3JtYXRcIil9KX0sbz1mdW5jdGlvbigpe2UoXCIucnJzc2ItYnV0dG9uc1wiKS5lYWNoKGZ1bmN0aW9uKHQpe3ZhciByPWUodGhpcyksaT1lKFwibGlcIixyKSxzPWkuZmlsdGVyKFwiLnNtYWxsXCIpLGE9MCxuPTAsbD1zLmVxKDApLG89cGFyc2VGbG9hdChsLmF0dHIoXCJkYXRhLXNpemVcIikpKzU1LGM9cy5sZW5ndGg7aWYoYz09PWkubGVuZ3RoKXt2YXIgZD00MipjLHU9ci53aWR0aCgpO2Qrbzx1JiYoci5yZW1vdmVDbGFzcyhcInNtYWxsLWZvcm1hdFwiKSxzLmVxKDApLnJlbW92ZUNsYXNzKFwic21hbGxcIiksaCgpKX1lbHNle2kubm90KFwiLnNtYWxsXCIpLmVhY2goZnVuY3Rpb24odCl7dmFyIHI9ZSh0aGlzKSxpPXBhcnNlRmxvYXQoci5hdHRyKFwiZGF0YS1zaXplXCIpKSs1NSxzPXBhcnNlRmxvYXQoci53aWR0aCgpKTthKz1zLG4rPWl9KTt2YXIgbT1hLW47bzxtJiYobC5yZW1vdmVDbGFzcyhcInNtYWxsXCIpLGgoKSl9fSl9LGM9ZnVuY3Rpb24odCl7ZShcIi5ycnNzYi1idXR0b25zXCIpLmVhY2goZnVuY3Rpb24odCl7dmFyIHI9ZSh0aGlzKSxpPWUoXCJsaVwiLHIpO2UoaS5nZXQoKS5yZXZlcnNlKCkpLmVhY2goZnVuY3Rpb24odCxyKXt2YXIgcz1lKHRoaXMpO2lmKHMuaGFzQ2xhc3MoXCJzbWFsbFwiKT09PSExKXt2YXIgYT1wYXJzZUZsb2F0KHMuYXR0cihcImRhdGEtc2l6ZVwiKSkrNTUsbj1wYXJzZUZsb2F0KHMud2lkdGgoKSk7aWYoYT5uKXt2YXIgbD1pLm5vdChcIi5zbWFsbFwiKS5sYXN0KCk7ZShsKS5hZGRDbGFzcyhcInNtYWxsXCIpLGgoKX19LS1yfHxvKCl9KX0pLHQ9PT0hMCYmdShoKX0saD1mdW5jdGlvbigpe2UoXCIucnJzc2ItYnV0dG9uc1wiKS5lYWNoKGZ1bmN0aW9uKHQpe3ZhciByLHMsYSxsLG8sYz1lKHRoaXMpLGg9ZShcImxpXCIsYyksZD1oLmZpbHRlcihcIi5zbWFsbFwiKSx1PWQubGVuZ3RoO3U+MCYmdSE9PWgubGVuZ3RoPyhjLnJlbW92ZUNsYXNzKFwic21hbGwtZm9ybWF0XCIpLGQuY3NzKFwid2lkdGhcIixcIjQycHhcIiksYT00Mip1LHI9aC5ub3QoXCIuc21hbGxcIikubGVuZ3RoLHM9MTAwL3Isbz1hL3IsaS5jYWxjPT09ITE/KGw9KGMuaW5uZXJXaWR0aCgpLTEpL3ItbyxsPU1hdGguZmxvb3IoMWUzKmwpLzFlMyxsKz1cInB4XCIpOmw9aS5jYWxjK1wiKFwiK3MrXCIlIC0gXCIrbytcInB4KVwiLGgubm90KFwiLnNtYWxsXCIpLmNzcyhcIndpZHRoXCIsbCkpOnU9PT1oLmxlbmd0aD8oYy5hZGRDbGFzcyhcInNtYWxsLWZvcm1hdFwiKSxuKCkpOihjLnJlbW92ZUNsYXNzKFwic21hbGwtZm9ybWF0XCIpLG4oKSl9KSxsKCl9LGQ9ZnVuY3Rpb24oKXtlKFwiLnJyc3NiLWJ1dHRvbnNcIikuZWFjaChmdW5jdGlvbih0KXtlKHRoaXMpLmFkZENsYXNzKFwicnJzc2ItXCIrKHQrMSkpfSkscygpLG4oKSxlKFwiLnJyc3NiLWJ1dHRvbnMgbGkgLnJyc3NiLXRleHRcIikuZWFjaChmdW5jdGlvbih0KXt2YXIgcj1lKHRoaXMpLGk9ci53aWR0aCgpO3IuY2xvc2VzdChcImxpXCIpLmF0dHIoXCJkYXRhLXNpemVcIixpKX0pLGMoITApfSx1PWZ1bmN0aW9uKHQpe2UoXCIucnJzc2ItYnV0dG9ucyBsaS5zbWFsbFwiKS5yZW1vdmVDbGFzcyhcInNtYWxsXCIpLGMoKSx0KCl9LG09ZnVuY3Rpb24oZSxpLHMsYSl7dmFyIG49dC5zY3JlZW5MZWZ0IT09cj90LnNjcmVlbkxlZnQ6c2NyZWVuLmxlZnQsbD10LnNjcmVlblRvcCE9PXI/dC5zY3JlZW5Ub3A6c2NyZWVuLnRvcCxvPXQuaW5uZXJXaWR0aD90LmlubmVyV2lkdGg6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoP2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDpzY3JlZW4ud2lkdGgsYz10LmlubmVySGVpZ2h0P3QuaW5uZXJIZWlnaHQ6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodD9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0OnNjcmVlbi5oZWlnaHQsaD1vLzItcy8yK24sZD1jLzMtYS8zK2wsdT10Lm9wZW4oZSxpLFwic2Nyb2xsYmFycz15ZXMsIHdpZHRoPVwiK3MrXCIsIGhlaWdodD1cIithK1wiLCB0b3A9XCIrZCtcIiwgbGVmdD1cIitoKTt1JiZ1LmZvY3VzJiZ1LmZvY3VzKCl9LGY9ZnVuY3Rpb24oKXt2YXIgdD17fTtyZXR1cm4gZnVuY3Rpb24oZSxyLGkpe2l8fChpPVwiRG9uJ3QgY2FsbCB0aGlzIHR3aWNlIHdpdGhvdXQgYSB1bmlxdWVJZFwiKSx0W2ldJiZjbGVhclRpbWVvdXQodFtpXSksdFtpXT1zZXRUaW1lb3V0KGUscil9fSgpO2UoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7dHJ5e2UoZG9jdW1lbnQpLm9uKFwiY2xpY2tcIixcIi5ycnNzYi1idXR0b25zIGEucG9wdXBcIix7fSxmdW5jdGlvbih0KXt2YXIgcj1lKHRoaXMpO20oci5hdHRyKFwiaHJlZlwiKSxyLmZpbmQoXCIucnJzc2ItdGV4dFwiKS5odG1sKCksNTgwLDQ3MCksdC5wcmV2ZW50RGVmYXVsdCgpfSl9Y2F0Y2godCl7fWUodCkucmVzaXplKGZ1bmN0aW9uKCl7dShoKSxmKGZ1bmN0aW9uKCl7dShoKX0sMjAwLFwiZmluaXNoZWQgcmVzaXppbmdcIil9KSxkKCl9KSx0LnJyc3NiSW5pdD1kfSh3aW5kb3csalF1ZXJ5KTsiXX0=
